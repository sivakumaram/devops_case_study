#############RBINIT (Groovy)###########


import groovy.json.*

def condition = "good";
def severity  = "good";
def summary   = "All parameters found";
def detail    = "";
def errorMsg = "";


//def email  = INPUTS.REQUESTER_EMAIL;
def csysid  = INPUTS.CATALOG_SYSID;
def fTICKTNO	= INPUTS.TICKETNO;
def function	= INPUTS.FUNCTION;
def JSDATA = INPUTS.JSON;
def JSON_FILE_OUTPUT = "";
def JSON_OBJ_COUNT = "";


//OUTPUTS.REQUESTER_EMAIL = email; 
OUTPUTS.TICKETNO = fTICKTNO;
OUTPUTS.CATALOG_SYSID = csysid;
OUTPUTS.FUNCTION = function;

//detail +="RequestorEmail= "+ OUTPUTS.REQUESTER_EMAIL +'\n';
detail +="RITMNO= "+ OUTPUTS.TICKETNO +'\n';
detail +="CatalogSysID="+ OUTPUTS.CATALOG_SYSID +'\n';
detail +="function="+ OUTPUTS.FUNCTION +'\n';
detail +='\n';
detail +='\n';


if(function.contains ("VERIFICATION"))
{
if(JSDATA)
{


def data = new JsonSlurper().parseText(JSDATA) 
def mappings = [
    server_name:            	{ n -> n.server_name },
    ip_address:       			{ n -> n.ip_address },
    datacenter:   	{ n -> n.datacenter }

]

detail += data;
detail +='\n';
data.each 
{ 
  item ->
  def row = mappings.collect { k, v -> v(item) }.join(',')
  JSON_FILE_OUTPUT += "#"+ row;
}

OUTPUTS.JSON_FILE_OUTPUT = JSON_FILE_OUTPUT;


detail +='\n';
JSON_OBJ_COUNT = JSON_FILE_OUTPUT.count("#");
OUTPUTS.JSON_OBJ_COUNT = JSON_OBJ_COUNT;

detail +="COUNT="+ OUTPUTS.JSON_OBJ_COUNT +'\n'
detail += OUTPUTS.JSON_FILE_OUTPUT +'\n'


	
}
else
{
//#Installation Block

def data = new JsonSlurper().parseText(JSDATA) 
def mappings = [
    server_name:            	{ n -> n.server_name },
    ip_address:       			{ n -> n.ip_address },
    datacenter:   	{ n -> n.datacenter }

]

detail +='\n';
data.each { item ->
  def row = mappings.collect { k, v -> v(item) }.join(',')
  JSON_FILE_OUTPUT += "#"+ row +'\n';
  detail += JSON_FILE_OUTPUT;
}
OUTPUTS.JSON_FILE_OUTPUT = JSON_FILE_OUTPUT;


detail +='\n';
JSON_OBJ_COUNT = JSON_FILE_OUTPUT.count("#");
OUTPUTS.JSON_OBJ_COUNT = JSON_OBJ_COUNT;

detail +="COUNT="+ OUTPUTS.JSON_OBJ_COUNT +'\n'
detail += OUTPUTS.JSON_FILE_OUTPUT +'\n'

}
}
if(function.contains ("POWERDOWN"))
{
if(JSDATA)
{



def data = new JsonSlurper().parseText(JSDATA) 
def mappings = [
    starConfigKey:            	{ n -> n.starConfigKey },
    vmname:       			{ n -> n.vmname },
    BackupMethod:   	{ n -> n.BackupMethod },
    VRABuild:   	{ n -> n.VRABuild },
    vCenter:   	{ n -> n.vCenter },
    RenamedVM:   	{ n -> n.RenamedVM },
    PowerState:   	{ n -> n.PowerState }

]

detail += data;
detail +='\n';
data.each 
{ 
  item ->
  def row = mappings.collect { k, v -> v(item) }.join(',')
  JSON_FILE_OUTPUT += "#"+ row;
}

OUTPUTS.JSON_FILE_OUTPUT = JSON_FILE_OUTPUT;


detail +='\n';
JSON_OBJ_COUNT = JSON_FILE_OUTPUT.count("#");
OUTPUTS.JSON_OBJ_COUNT = JSON_OBJ_COUNT;

detail +="COUNT="+ OUTPUTS.JSON_OBJ_COUNT +'\n'
detail += OUTPUTS.JSON_FILE_OUTPUT +'\n'


	
}
else
{
//#Installation Block

def data = new JsonSlurper().parseText(JSDATA) 
def mappings = [
    starConfigKey:            	{ n -> n.starConfigKey },
    vmname:       			{ n -> n.vmname },
    BackupMethod:   	{ n -> n.BackupMethod },
    VRABuild:   	{ n -> n.VRABuild },
    vCenter:   	{ n -> n.vCenter },
    RenamedVM:   	{ n -> n.RenamedVM },
    PowerState:   	{ n -> n.PowerState }

]

detail +='\n';
data.each { item ->
  def row = mappings.collect { k, v -> v(item) }.join(',')
  JSON_FILE_OUTPUT += "#"+ row +'\n';
  detail += JSON_FILE_OUTPUT;
}
OUTPUTS.JSON_FILE_OUTPUT = JSON_FILE_OUTPUT;


detail +='\n';
JSON_OBJ_COUNT = JSON_FILE_OUTPUT.count("#");
OUTPUTS.JSON_OBJ_COUNT = JSON_OBJ_COUNT;

detail +="COUNT="+ OUTPUTS.JSON_OBJ_COUNT +'\n'
detail += OUTPUTS.JSON_FILE_OUTPUT +'\n'
}	
}
if(function.contains ("DELETE"))
{
if(JSDATA)
{
	
def data = new JsonSlurper().parseText(JSDATA) 
def mappings = [
	starConfigKey: 	{ n -> n.starConfigKey },
	vmname:         { n -> n.vmname },
    BackupMethod:   { n -> n.BackupMethod },
    VRABuild:   	{ n -> n.VRABuild },
    vCenter:   	{ n -> n.vCenter },
    RenamedVM:   	{ n -> n.RenamedVM },
    PowerState:   	{ n -> n.VMPowerState }


]

detail += data;
detail +='\n';
data.each 
{ 
  item ->
  def row = mappings.collect { k, v -> v(item) }.join(',')
  JSON_FILE_OUTPUT += "#"+ row;
}

OUTPUTS.JSON_FILE_OUTPUT = JSON_FILE_OUTPUT;


detail +='\n';
JSON_OBJ_COUNT = JSON_FILE_OUTPUT.count("#");
OUTPUTS.JSON_OBJ_COUNT = JSON_OBJ_COUNT;

detail +="COUNT="+ OUTPUTS.JSON_OBJ_COUNT +'\n'
detail += OUTPUTS.JSON_FILE_OUTPUT +'\n'


	
}
else
{
//#Installation Block

def data = new JsonSlurper().parseText(JSDATA) 
def mappings = [
	starConfigKey: 	{ n -> n.starConfigKey },
	vmname:         { n -> n.vmname },
    BackupMethod:   { n -> n.BackupMethod },
    VRABuild:   	{ n -> n.VRABuild },
    vCenter:   	{ n -> n.vCenter },
    RenamedVM:   	{ n -> n.RenamedVM },
    PowerState:   	{ n -> n.VMPowerState }

]

detail +='\n';
data.each { item ->
  def row = mappings.collect { k, v -> v(item) }.join(',')
  JSON_FILE_OUTPUT += "#"+ row +'\n';
  detail += JSON_FILE_OUTPUT;
}
OUTPUTS.JSON_FILE_OUTPUT = JSON_FILE_OUTPUT;


detail +='\n';
JSON_OBJ_COUNT = JSON_FILE_OUTPUT.count("#");
OUTPUTS.JSON_OBJ_COUNT = JSON_OBJ_COUNT;

detail +="COUNT="+ OUTPUTS.JSON_OBJ_COUNT +'\n'
detail += OUTPUTS.JSON_FILE_OUTPUT +'\n'
}	
}
if(function.contains ("CONSOLECLEANUP"))
{
if(JSDATA)
{

def data = new JsonSlurper().parseText(JSDATA) 
def mappings = [
	starConfigKey: 	{ n -> n.starConfigKey },
	vmname:         { n -> n.vmname },
    BackupMethod:   { n -> n.BackupMethod },
    VRABuild:   	{ n -> n.VRABuild },
    vCenter:   	{ n -> n.vCenter },
    RenamedVM:   	{ n -> n.RenamedVM },
    PowerState:   	{ n -> n.VMPowerState },
    ipaddress:   	{ n -> n.ip_address }

]

detail += data;
detail +='\n';
data.each 
{ 
  item ->
  def row = mappings.collect { k, v -> v(item) }.join(',')
  JSON_FILE_OUTPUT += "#"+ row;
}

OUTPUTS.JSON_FILE_OUTPUT = JSON_FILE_OUTPUT;


detail +='\n';
JSON_OBJ_COUNT = JSON_FILE_OUTPUT.count("#");
OUTPUTS.JSON_OBJ_COUNT = JSON_OBJ_COUNT;

detail +="COUNT="+ OUTPUTS.JSON_OBJ_COUNT +'\n'
detail += OUTPUTS.JSON_FILE_OUTPUT +'\n'


	
}
else
{
//#Installation Block

def data = new JsonSlurper().parseText(JSDATA) 
def mappings = [
	starConfigKey: 	{ n -> n.starConfigKey },
	vmname:         { n -> n.vmname },
    BackupMethod:   { n -> n.BackupMethod },
    VRABuild:   	{ n -> n.VRABuild },
    vCenter:   	{ n -> n.vCenter },
    RenamedVM:   	{ n -> n.RenamedVM },
    PowerState:   	{ n -> n.VMPowerState },
    ipaddress:   	{ n -> n.ip_address }

]

detail +='\n';
data.each { item ->
  def row = mappings.collect { k, v -> v(item) }.join(',')
  JSON_FILE_OUTPUT += "#"+ row +'\n';
  detail += JSON_FILE_OUTPUT;
}
OUTPUTS.JSON_FILE_OUTPUT = JSON_FILE_OUTPUT;


detail +='\n';
JSON_OBJ_COUNT = JSON_FILE_OUTPUT.count("#");
OUTPUTS.JSON_OBJ_COUNT = JSON_OBJ_COUNT;

detail +="COUNT="+ OUTPUTS.JSON_OBJ_COUNT +'\n'
detail += OUTPUTS.JSON_FILE_OUTPUT +'\n'
}	
}


RESULT.condition = condition;
RESULT.severity  = severity;
RESULT.summary   = summary;
RESULT.detail    = detail;


########################################

#################VERIFY VRA#############

if(!(Get-Module -Name SqlServer))
{
    Import-Module -Name SqlServer
    if(!$?){ 
        Install-Module -Name SqlServer -ErrorAction SilentlyContinue -AllowClobber
        throw "Could not load SQL Module" 
     }
}
#Prepared statement for the insert

#change to your flow variable
$DB_TABLE         = "[test].[test].[test]"
$DB_HOST_2          = 'example.com'
#Prepared statement for the insert
#DB Credentials
	[ValidateNotNullOrEmpty()]
	$DB_USERNAME = '$INPUT{DB_USERNAME}'

	[ValidateNotNullOrEmpty()]
	$DB_USER_PASSWORD = ConvertTo-SecureString '$INPUT{DB_PASSWORD}' -AsPlainText -Force

	[ValidateNotNullOrEmpty()]
	$DB_HOST = '$INPUT{DB_HOSTNAME}'
	
$server_name = '$INPUT{SNAME}'	  
    function GetConnectionString ($user, $passwd, $dbhost)
{

  return "Server=$dbhost;Database=testDB;Integrated Security=False;User ID= $user ;Password= '$INPUT{DB_PASSWORD}' " 	
 }

$key = '$INPUT{VRAVMNAME}'
$dticket = '$INPUT{CHANGENO}'
$description = "_Decomm_VM_tool_" + "$dticket"
$note =  "VM Decommission performed through tool with change ticket " + "$dticket"
$decomtimestamp = get-date -Format d





function Build-dbInsert(){

    $selectSQL = "SELECT count(*) as count from $DB_TABLE WITH (NOLOCK) where servername = '$($key)'"
    Write-Host $selectSQL
    $insExist = Invoke-Sqlcmd -Query $selectSQL -ServerInstance $DB_HOST_2 -ErrorAction Stop
    $insertSQLCMD = $insertSQL -f $key, $dticket, $description, $note, $decomtimestamp, $DB_TABLE
    $insExist.Count
    if ($insExist.Count -ge 1){
           write-Host "$($key) is VRABuild"
           $writedb = "good"
        } 
        else {
            Write-Host "$($key) is NON-VRA Build "
            $writedb = "bad"
        } 
<#          
if ($writedb -eq "good")
{
#write to DB
			$query = @"
			UPDATE [dbo].[TOOL_REF_V2]
   			SET [vmSTARStatusUpdate] = 'Success'
 			WHERE `VMName`= '$server_name'
"@

			[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
			$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
			#$SqlConnection.ConnectionString = GetConnectionString
			$SqlConnection.ConnectionString = $connectionString
			$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
			$SqlCmd.CommandText = $query   
			$SqlCmd.Connection = $SqlConnection  
			$SqlConnection.Open()
	
			#Execute SQL Query
			$result = $SqlCmd.ExecuteNonQuery()

			if($result -eq 1)
			{
			#Create SQL Statement
			$query = @"
			SELECT vmSTARStatusUpdate FROM [dbo].[TOOL_REF_V2] 
			WHERE `VMName`= '$server_name'
"@
			$query
			[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
			$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
			#$SqlConnection.ConnectionString = GetConnectionString
			$SqlConnection.ConnectionString = $connectionString
			$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
			$SqlCmd.CommandText = $query  
			$SqlCmd.Connection = $SqlConnection  
	
			$SqlConnection.Open()

			$result = $SqlCmd.ExecuteReader()

			if($result)
			{
			#Add result to DataTable Object and Display it
			$table = new-object "System.Data.DataTable"
			$table.Load($result)

			Write-Host ($table | Format-Table | Out-String)
			$SqlConnection.Close()
			}

			else
			{
			write-host "Unsuccessful : $query"
			}
			}	
}
#>

    }

Build-dbInsert


##################################

##############VERIFY BACKUP METHOD#############

if(!(Get-Module -Name SqlServer))
{
    Import-Module -Name SqlServer
    if(!$?){ 
        Install-Module -Name SqlServer -ErrorAction SilentlyContinue -AllowClobber
        throw "Could not load SQL Module" 
     }
}
#Prepared statement for the insert

#change to your flow variable
$DB_TABLE         = "[test].[test].[test]"
$DB_HOST          = '$INPUT{DB_HOSTNAME}'
#Prepared statement for the insert
#DB Credentials
	[ValidateNotNullOrEmpty()]
	$DB_USERNAME = '$INPUT{DB_USERNAME}'

	[ValidateNotNullOrEmpty()]
	$DB_USER_PASSWORD = ConvertTo-SecureString '$INPUT{DB_PASSWORD}' -AsPlainText -Force

	
$key = '$INPUT{VRAVMNAME}'

function Build-dbInsert(){
	$checkquery = "select dv_u_backup_group from [test].[test].[test] where name = '$($key)'"
    $selectSQL = "SELECT count(*) as count from $DB_TABLE WITH (NOLOCK) where name = '$($key)'"
    #Write-Host $selectSQL
    #write-host $checkquery
    $insExist = Invoke-Sqlcmd -Query $selectSQL -ServerInstance $DB_HOST -ErrorAction Stop
    $insExist.Count
    if ($insExist.Count -ge 1) {
    	Invoke-Sqlcmd -Query $checkquery -ServerInstance $DB_HOST -ErrorAction Stop
    } 
    else {
        Write-Host "$($key) is NONFOUND"
    } 

    }

Build-dbInsert

#################################

################DECOMM PREVERIFY################

#$ErrorActionPreference = "silentlycontinue"

[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{USERNAME}'


[ValidateNotNullOrEmpty()]
[string] $vcenterserver = '$INPUT{VCENTER}'

[ValidateNotNullOrEmpty()]
	[string]$client = '$INPUT{VMNAME}'
	$ip 			= '$INPUT{IP}'
	$INVENTORYip 		= '$INPUT{INVENTORY_IP}'
	$INVENTORYstatus 	= '$INPUT{INVENTORY_STATUS}'
	$INVENTORYcheck		= '$INPUT{INVENTORY_CHECK}'
	$backupstatus 	= '$INPUT{BACKUP_STATUS}'
	$INVENTORYconfigkey  = '$INPUT{INVENTORY_CONFIGKEY}'
	$bkpmethod	    = '$INPUT{BACKUP_METHOD}'
	$vracheck		= '$INPUT{VRA_CHECK}'
	
#Densify Credentials
	[ValidateNotNullOrEmpty()]
	$DB_USERNAME 		= '$INPUT{DB_USERNAME}'

	[ValidateNotNullOrEmpty()]
	$DB_USER_PASSWORD 	= ConvertTo-SecureString '$INPUT{DB_PASSWORD}' -AsPlainText -Force

	[ValidateNotNullOrEmpty()]
	$DB_HOST 			= '$INPUT{DB_HOSTNAME}'
	
	
    #Credentials
    $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
    
    function GetConnectionString ($user, $passwd, $dbhost)
{

  return "Server=$dbhost;Database=Automation;Integrated Security=False;User ID= $user ;Password= '$INPUT{DB_PASSWORD}' " 	
  
}

$connectedServer                    = $global:defaultviserver

#This funtion is to Disconnect the Vcenter Server
function DisconnectVcenter ([string] $vCenter){
    # Disconnect from the current vCenter    
    Try{
        DisConnect-VIServer $vCenter -Confirm:$false  -Force  -ErrorAction Stop
        Write-Output "Disconnected from $vCenter"
        }
    catch{
        Write-output "Host is already Disconnected"
    }     
} 

# Check to see if already connected and Disconnect any leftover connections before INVENTORYting script.
If($null -eq $connectedServer){
    Try{
        DisConnect-VIServer -server *    -Confirm:$false -Force
    }
    catch {
        #Write-Host "Unable to Disconnect from vcenter Server"
    }
}


$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()

$tabaobj.Add("ActionTask", "VERIFICATION")

#if (($client -eq 'server1') -or ($client -eq 'server2' ) -or ($client -eq 'server3')) {

 
    if ($vcenterserver -eq 'vc1' -or $vcenterserver -eq 'vc2' -or $vcenterserver -eq 'vc3' ) {
        try {
            Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false -ErrorAction Stop | Out-Null
            $configset = "INFO No proxy has been set "
        }
        catch { $configset = "ERROR Setting Proxy has failed" }  
    }
    else {
        $configset = "INFO No proxy has been set "
    }
	
	
    if ($configset) {
        $tabaobj.Add("Proxy", $configset)
    }
   

    if (!(Get-Module -Name VMware.VimAutomation.Core)) {
        try {
            Import-Module -Name VMware.VimAutomation.Core -ErrorAction stop
            $moduleset = "INFOVmware module has been imported"
        }
        catch { $moduleset = "ERRORVmware module has not been imported" }

        if ($moduleset) {
            $tabaobj.Add("Modules", $moduleset)
        }
    	
        if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
        else {
            try {
                $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
                $cnvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
                $connected = "INFO Connected to vcenter Server $vcenterserver"
            
            }
            catch {
                $connectmsg = $_.Exception.Message
                $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
            }
            if ($connected) {
                $tabaobj.Add("Connection", $connected)
            }
        
        }
    }
    else {
        try {
            $CREDENTIALS = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD
            $connectvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
            $connected = "INFO Connected to vcenter Server $vcenterserver"
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
        }


        if ($connected) {
            if ($tabaobj.ContainsKey("Connection")) {
                $tabaobj["Connection"] = $connected
            }
            else {
                $tabaobj.Add("Connection", $connected)
            }
        }
     
    }


    if ($connected) {
        if ($connected -notlike "ERROR Could not connect to vCenter*") {
            try {
                $vm = get-vm -Name $client -ErrorAction Stop 
                $vmid = $vm.Id
                $vmfound = "INFO VM $client is found in $vcenterserver"
            }
            catch {
                $clientmsg = $_.Exception.Message
                if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                    try {
                        $decomclient = "$client-DECOM*"
                        $vm = get-vm -Name $decomclient -ErrorAction Stop 
                        $vmid = $vm.Id
                        #write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                        $vmfound = "ERROR :  VM $client in $vcenterserver is renamed for Decomission"
                    }
                    catch {
                        $clientmsg = $_.Exception.Message
                        #write-host "ERROR Unable to find VM $client in $vcenterserver $clientmsg"
                        $vmfound = "ERROR $clientmsg"
                    }
                }
            }
        }
        else {
            $vmfound = "ERROR VM $client is not found in $vcenterserver"
        }

    }


    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }


    if ($vmfound -eq "INFO VM $client is found in $vcenterserver") {
        if ($vm.Name -eq "$client") {
 				try {
				#VERIFICATION INVENTORYTS                    
                    try { 
                    	
                    	$powerstate = get-vm -name $client | Select -ExpandProperty PowerState | Out-String
						$powerstate = $powerstate -replace "\r" -replace "\n"
						$validationdate =  ((Get-Date).ToString('yyyy-MM-dd')).Trim()
						
						if ($INVENTORYcheck -match "GOOD" -and $powerstate -match "Powered"){
							$jresult = "success"
							$Comments = "No issues found in VM verification"
							$CompletionStatus = "Pending"

$query = @"
IF NOT EXISTS( SELECT `VMName` FROM [dbo].[TO0L_REF_V2] WHERE `VMName`= '$client')
BEGIN
     INSERT INTO [dbo].[TO0L_REF_V2] (VMName,VCenter,vmIP,ValidationDate,CompletionStatus,vmPowerOffState,vmDeletionState,vmINVENTORYConfKey,vmINVENTORYStatusUpdate,vmINVENTORYStatusUpdate,vmBackupMethod,vmVRABuild,cc_Database_Oracle,cc_Database_Sql,cc_ASWindows,cc_ASUnix,cc_ControlM,cc_Boks,cc_Backup,cc_cAk,cc_Patching,cc_monitoring,cc_Networkscanner,cc_tool,cc_srm) 
     VALUES ('$client','$vcenterserver','$ip','$validationdate','$CompletionStatus','Pending','Pending','$INVENTORYconfigkey','Pending','Pending','$bkpmethod','$vracheck','Pending','Pending','Pending','Pending','Pending','Pending','Pending','Pending','Pending','Pending','Pending','Pending','Pending')
END
"@

							[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
							$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
							#$SqlConnection.ConnectionString = GetConnectionString
							$SqlConnection.ConnectionString = $connectionString
							$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
							$SqlCmd.CommandText = $query   
							$SqlCmd.Connection = $SqlConnection  
							
							$SqlConnection.Open() 


							#Execute SQL Query
							$result = $SqlCmd.ExecuteNonQuery()

							$SqlConnection.Close()
							INVENTORYt-Sleep -Seconds 3

							if($result -eq 1){
#Create SQL Statement
$query = @"
SELECT * FROM dbo.TO0L_REF_V2 WHERE VMName = '$client'
"@

							[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
							$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
							#$SqlConnection.ConnectionString = GetConnectionString
							$SqlConnection.ConnectionString = $connectionString
							$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
							$SqlCmd.CommandText = $query  
							$SqlCmd.Connection = $SqlConnection  
							$SqlConnection.Open()
							$result = $SqlCmd.ExecuteReader()
							if($result){
								#Add result to DataTable Object and Display it
								$table = new-object "System.Data.DataTable"
								$table.Load($result)							
								#Write-Host ($table | Format-Table | Out-String)
								$addtodb = "Yes"
							}
							else {
								#write-host "Unsuccessful : $query"
								$addtodb = "write to DB failed"
							}
							$SqlConnection.Close()
							}
							else{
								$addtodb = "Record found in DB"
								#write-host "Record already found"
								}
							}
						elseif ($INVENTORYcheck -match "FAILED"){
								$jresult = "success"
								$Comments = "INVENTORY ENTRY MISMATCH"
								$addtodb = "NO"
							}
							
						else{
							$jresult = "fail"
							$addtodb = "NO"
							$Comments = "Cant Find VM"
						}
							
							if ($addtodb -match "Yes"){
								#Write-Output "Added to DB"
							}
								#write-host "Feth=|$vmname|$HOSTNM|$ip|$INVENTORYcheck|$bkpmethod|$vracheck|$powerstate|$validationdate|$addtodb|$Comments| >"
								
								$hashobj = New-Object System.Collections.Specialized.OrderedDictionary
							
								$hashobj.Add("vmname", $client)
								$hashobj.Add("vCenter", $vcenterserver)
								$hashobj.Add("vmip", $ip)
								$hashobj.Add("INVENTORYcheck", $INVENTORYcheck)
								$hashobj.Add("INVENTORYConfigKey", $INVENTORYconfigkey)
								$hashobj.Add("BackupMethod", $bkpmethod)
								$hashobj.Add("VRABuild", $vracheck)
								$hashobj.Add("VMPowerState", $powerstate)
								$hashobj.Add("result", $jresult)
								$hashobj.Add("message", $Comments)
							
								#$hashobj | ConvertTo-Json
                            	if ($tabaobj.ContainsKey("VMData")) {
                                $tabaobj["VMData"] = $hashobj
                            	}
                            	else {
                                $tabaobj.Add("VMData", $hashobj)
                            	}

                           

					    }

				    Catch {
                                $global:configmsg = $_.Exception.Message
                                #cut
                                if ($global:configmsg ) {
		                            if ($tabaobj.ContainsKey("VMData")) {
                                    $tabaobj["VMData"] = $global:configmsg
                                    }
                                    else {
                                    $tabaobj.Add("VMData", $global:configmsg)
                                    }
                                    }
                                #cut
                            }
                                    
                }                
   								
                catch {
                    $opitmalmsg = $_.Exception.Message
                    if ($opitmalmsg) {
                    	if ($tabaobj.ContainsKey("VMData")) {
                        $tabaobj["VMData"] = $opitmalmsg
                    	}
                    else {
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                	}
                    
                }
        }
    }
    else {
            $vmfound = "ERROR The VM $client not found in vCenter $vcenterserver"
            if ($vmfound) {
            	if ($tabaobj.ContainsKey("VmStatus")) {
                    $tabaobj["VmStatus"] = $vmfound
                }
                else {
                    $tabaobj.Add("VmStatus", $vmfound)
                }
            	$jresult = "fail"
				$addtodb = "NO"
				$Comments = "Cant Find VM in Vcenter"
            	$hashobj = New-Object System.Collections.Specialized.OrderedDictionary
							
				$hashobj.Add("vmname", $client)
				$hashobj.Add("vCenter", $vcenterserver)
				$hashobj.Add("vmip", $ip)
				$hashobj.Add("INVENTORYcheck", $INVENTORYcheck)
				$hashobj.Add("INVENTORYConfigKey", $INVENTORYconfigkey)
				$hashobj.Add("BackupMethod", $bkpmethod)
				$hashobj.Add("VRABuild", $vracheck)
				$hashobj.Add("VMPowerState", "Not Applicable")
				$hashobj.Add("result", $jresult)
				$hashobj.Add("message", $Comments)
			
				#$hashobj | ConvertTo-Json
                if ($tabaobj.ContainsKey("VMData")) {
                	$tabaobj["VMData"] = $hashobj
                }
                else {
                	$tabaobj.Add("VMData", $hashobj)
                }
            }
        }
   
    $tabaobj | ConvertTo-Json
    DisConnect-VIServer $vcenterserver -Confirm:$false  -Force  -ErrorAction Stop
#}

############################

#################UPDATE INVENTORY(POWEROFF)#############

if(!(Get-Module -Name SqlServer))
{
    Import-Module -Name SqlServer
    if(!$?){ 
        Install-Module -Name SqlServer -ErrorAction SilentlyContinue -AllowClobber
        throw "Could not load SQL Module" 
     }
}
#Prepared statement for the insert

#change to your flow variable
$DB_TABLE         = "[test].[tst].[test]"
$DB_HOST_2          = 'sample.com'
#Prepared statement for the insert
#DB Credentials
	[ValidateNotNullOrEmpty()]
	$DB_USERNAME = '$INPUT{DB_USERNAME}'

	[ValidateNotNullOrEmpty()]
	$DB_USER_PASSWORD = ConvertTo-SecureString '$INPUT{DB_PASSWORD}' -AsPlainText -Force

	[ValidateNotNullOrEmpty()]
	$DB_HOST = '$INPUT{DB_HOSTNAME}'
	
$server_name = '$INPUT{SNAME}'	  
    function GetConnectionString ($user, $passwd, $dbhost)
{

  return "Server=$dbhost;Database=Automation;Integrated Security=False;User ID= $user ;Password= '$INPUT{DB_PASSWORD}' " 	
  
}
$insertSQL = @'
        INSERT INTO {5}
        (ConfigItems_key,DecommTicketNumber,Description,NoteValue,DecommDateStamp)
        VALUES ('{0}', '{1}', '{2}', '{3}', '{4}')      
'@


$dticket = '$INPUT{CHANGENO}'
$description = "$server_name" + "_Decomm_VM_TOOL_" + "$dticket"
$note =  "VM Decommission performed through tool with change ticket " + "$dticket"
$decomtimestamp = get-date -Format d


$getquery = @"
			SELECT vmSTARConfKey FROM [dbo].[TOOL_DECOMM_DEL_REF_V2] 
			WHERE `VMName`= '$server_name'
"@
			$query
			[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
			$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
			#$SqlConnection.ConnectionString = GetConnectionString
			$SqlConnection.ConnectionString = $connectionString
			$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
			$SqlCmd.CommandText = $getquery  
			$SqlCmd.Connection = $SqlConnection  
	
			$SqlConnection.Open()

			$result = $SqlCmd.ExecuteReader()

			if($result)
			{
			#Add result to DataTable Object and Display it
			$table = new-object "System.Data.DataTable"
			$table.Load($result)
            $starkey = $table.vmSTARConfKey
			$SqlConnection.Close()
			}

			else
			{
			write-host "Unsuccessful : $query"
			}

$starkey

function Build-dbInsert(){

    $selectSQL = "SELECT count(*) as count from $DB_TABLE WITH (NOLOCK) where ConfigItems_key = '$($starkey)'"
    #Write-Host $selectSQL
    $insExist = Invoke-Sqlcmd -Query $selectSQL -ServerInstance $DB_HOST_2 -ErrorAction Stop
    $insertSQLCMD = $insertSQL -f $starkey, $dticket, $description, $note, $decomtimestamp, $DB_TABLE
    
    if ($insExist.Count -ge 1){
           write-Host "Entry already exist : $($starkey)"
           $writedb = "bad"
        } 
        else {
            Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST_2 -ErrorAction Stop
            #Write-Host $insertSQLCMD
            Write-Host "Inserted new entry : $($starkey)"
            $writedb = "good"
        } 
          
if ($writedb -eq "good")
{
#write to DB
			$query = @"
			UPDATE [dbo].[TEST_REF_V2]
   			SET [vmSTARStatusUpdate] = 'Success'
 			WHERE `VMName`= '$server_name'
"@

			[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
			$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
			#$SqlConnection.ConnectionString = GetConnectionString
			$SqlConnection.ConnectionString = $connectionString
			$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
			$SqlCmd.CommandText = $query   
			$SqlCmd.Connection = $SqlConnection  
			$SqlConnection.Open()
	
			#Execute SQL Query
			$result = $SqlCmd.ExecuteNonQuery()

			if($result -eq 1)
			{
			#Create SQL Statement
			$query = @"
			SELECT vmSTARStatusUpdate FROM [dbo].[TEST_REF_V2] 
			WHERE `VMName`= '$server_name'
"@
			$query
			[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
			$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
			#$SqlConnection.ConnectionString = GetConnectionString
			$SqlConnection.ConnectionString = $connectionString
			$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
			$SqlCmd.CommandText = $query  
			$SqlCmd.Connection = $SqlConnection  
	
			$SqlConnection.Open()

			$result = $SqlCmd.ExecuteReader()

			if($result)
			{
			#Add result to DataTable Object and Display it
			$table = new-object "System.Data.DataTable"
			$table.Load($result)

			Write-Host ($table | Format-Table | Out-String)
			$SqlConnection.Close()
			}

			else
			{
			write-host "Unsuccessful : $query"
			}
			}	
}


    }
   

Build-dbInsert


####################


###############UPDATE CM SNOW INVENTORY(Mark Pending)(POWEROFF)#########

$server_name = '$INPUT{SNAME}'
$spass = '$INPUT{SPASS}'
$slink = '$INPUT{sLINK}'
$msg = @"
$INPUT{CHANGENO}
"@
	
#DB Credentials
	[ValidateNotNullOrEmpty()]
	$DB_USERNAME = '$INPUT{DB_USERNAME}'

	[ValidateNotNullOrEmpty()]
	$DB_USER_PASSWORD = ConvertTo-SecureString '$INPUT{DB_PASSWORD}' -AsPlainText -Force

	[ValidateNotNullOrEmpty()]
	$DB_HOST = '$INPUT{DB_HOSTNAME}'
	
	  
    function GetConnectionString ($user, $passwd, $dbhost)
{

  return "Server=$dbhost;Database=testdb;Integrated Security=False;User ID= $user ;Password= '$INPUT{DB_PASSWORD}' " 	
 
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$sysid =@()

function getsysid ($server)
{
try
{

	$ErrorActionPreference = "SilentlyContinue"
	$errorAction = "stop"
            
            $Requests=$Null
            $user = 'resolve'
            $password = ConvertTo-SecureString $spass -AsPlainText -Force
            $credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $user,$password
   			$URI = "$slink/api/now/table/cmdb_ci_server?sysparm_query=name%3D$server&sysparm_fields=sys_id&sysparm_limit=1"
            $Requests = Invoke-RestMethod -Uri $URI -Credential $credential -Method GET -ContentType "application/json"
            $sysid=$Requests.result.sys_id
            
            
}

catch [Exception]
{   
    $sysid += "<==FAIL==>: " + $_.Exception.GetType().FullName + $_.Exception.Message + "`n";
    $sysid += ($_.Exception|format-list -force).toString();
}
finally
{
$sysid
}
}

$serversysid = getsysid -server $server_name

write-host "System sysid is $serversysid"

$Requestcmdb=@()
try
{

	$ErrorActionPreference = "SilentlyContinue"
	$errorAction = "stop"
$bodyd=@()
         
$bodyd = @{
'operational_status' = "3"
'u_change_log' = "Refer change $msg"
}

  $bodyJson = $bodyd | ConvertTo-Json

                  
            $Requests=$Null
            $user = 'resolve'
            $password = ConvertTo-SecureString $spass -AsPlainText -Force
            $credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $user,$password
   			$URI1 = "$slink/api/now/table/cmdb_ci_server/$serversysid"
            $URI1
            $Requestcmdb = Invoke-RestMethod -Uri $URI1 -Credential $credential -Method Put -Body $bodyJson -ContentType "application/json"
            $opsstatus = $Requestcmdb.result.operational_status
            $opsstatus
            if($opsstatus -eq '3')
{		
#write to DB
			write-host "$server_name Marked as PendingDecom" 
			$query = @"
			UPDATE [dbo].[TOOL_REF_V2]
   			SET [vmCMDBStatusUpdate] = 'InProgress'
 			WHERE `VMName`= '$server_name'
"@

			[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
			$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
			#$SqlConnection.ConnectionString = GetConnectionString
			$SqlConnection.ConnectionString = $connectionString
			$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
			$SqlCmd.CommandText = $query   
			$SqlCmd.Connection = $SqlConnection  
			$SqlConnection.Open()
	
			#Execute SQL Query
			$result = $SqlCmd.ExecuteNonQuery()

			if($result -eq 1)
			{
			#Create SQL Statement
			$query = @"
			SELECT vmCMDBStatusUpdate FROM [dbo].[TOOL_REF_V2] 
			WHERE `VMName`= '$server_name'
"@
			$query
			[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
			$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
			#$SqlConnection.ConnectionString = GetConnectionString
			$SqlConnection.ConnectionString = $connectionString
			$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
			$SqlCmd.CommandText = $query  
			$SqlCmd.Connection = $SqlConnection  
	
			$SqlConnection.Open()

			$result = $SqlCmd.ExecuteReader()

			if($result)
			{
			#Add result to DataTable Object and Display it
			$table = new-object "System.Data.DataTable"
			$table.Load($result)

			Write-Host ($table | Format-Table | Out-String)
			$SqlConnection.Close()
			}

			else
			{
			write-host "Unsuccessful : $query"
			}
			}	
}
            elseif($opsstatus -eq '10' -or $opsstatus -eq '1' )
             {
             	write-host "$server_name changed to Active" 
                }
            else{write-host "$server_name CMDB update failed!!" 
                }
            
           
            

}
catch [Exception]
{   
    $Requestcmdb += "<==FAIL==>: " + $_.Exception.GetType().FullName + $_.Exception.Message + "`n";
    $Requestcmdb += ($_.Exception|format-list -force).toString();
}
finally
{
$Requestcmdb.result | select operational_status, u_change_log
}


#########################

###################CYBERARK ADD to safe##################



$computerName  = '$INPUT{COMPUTERNAME}'
$username 	   = '$INPUT{USERNAME}'
$password 	   = ConvertTo-SecureString '$INPUT{PASSWORD}'  -AsPlainText -Force
$credential    = New-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password
$lob_name = '$INPUT{lob_NAME}'
$Safe = '$INPUT{SAFE_SEARCH}'

#connecting star db 
    [ValidateNotNullOrEmpty()]
	$DB_USERNAME = '$INPUT{DB_USERNAME}'  #star username 

	[ValidateNotNullOrEmpty()]
	$DB_USER_PASSWORD = ConvertTo-SecureString '$INPUT{DB_PASSWORD}' -AsPlainText -Force #star pass

	[ValidateNotNullOrEmpty()]
	$DB_HOST = '$INPUT{DB_HOSTNAME}' #star hostname 

$CyberarkUrl = 'cark.sample.com'
$computerlist = @()
$decom_server = '$INPUT{DECOM_SERVER}'

foreach($computer in $computerName){
	
				$computerlist =$computer.Split(",") 
	
      }

	foreach($item in $computerlist){
	
	             if(Test-Connection -ComputerName $item -Quiet){
	             	      
	             	       try{
	              	
							     $CyberarkLoginResult = Invoke-command -ComputerName $item -ScriptBlock {
			
			
                  		     	$headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
														$headers.Add("Content-Type", "application/json")
														$user = '$INPUT{USERNAME}'
														$user = $user.Split("\")[1]
														$pass = '$INPUT{PASSWORD}'
														$body = @"
														{
														"username": "$user",
														"password": "$pass",
														"useRadiusAuthentication": "false",
														"connectionNumber": "1"
														}
"@
			
		             	$response = Invoke-RestMethod 'https://cark.sample.com/PasswordVault/WebServices/auth/Cyberark/CyberArkAuthenticationService.svc/Logon' -Method POST -Headers $headers -Body $body -ea silentlycontinue
	     	            $cyberarkLogon = $response.CyberArkLogonResult
	          
			            $headers1 = @{
								    Authorization = $cyberarkLogon
								   "Content-Type" = "application/json"
			                }
			            $path = 'https://'+$using:CyberarkUrl+"/PasswordVault/api/Safes"
			            $Returnres = Invoke-RestMethod -Uri $path -Method GET -Headers $headers1  -ea silentlycontinue
				        #return $Returnres
				        
				        $res = $Returnres.Safes
				        $checkSafe  = $res | where {$_.SafeName -eq "Sample SafeBox"}
				        $ResponseAuthentication = @()
				        if($checksafe){
				        									$headers2 = @{
 																    Authorization = $cyberarkLogon
 																   "Content-Type" = "application/json"
 			                                                   }
 			                                                   $decom_object = $using:decom_server
 			                                                   $add = $using:decom_server+'.sample.com' 
 			                                                   $accountname  = $using:decom_server+'.pr-sampleacc'
 			                                                   $body1 = @"
 														      {
 														        "account" :{ 
 														        "safe" : "$using:Safe",
 														        "platformID":"User Managed",
 														        "address": "$add",
 														        "accountName":"$accountname",
 														        "password":"none",
 														        "username":"sampleacc",
 														        "disableAutoMgmt":"false",
 														        "disableAutoMgmtReaso":"N/A",
 														        "groupName":"",
 														        "groupPlatformID":"",
 														        "properties":
 														        [
														          
 														          {"Key":"AccountDescription", "Value":"0.0.0.0"},
 														          {"Key":"lobName", "Value":"$using:lob_name"}, 
 														        ]
 														        }
														     
 														}
"@
                       $response1 = Invoke-RestMethod 'https://cark.sample.com/PasswordVault/WebServices/PIMServices.svc/Account' -Method 'POST' -Headers $headers2 -Body $body1  -ea silentlycontinue
                       $response1 
                       if($response1 -eq "")
                       { 
                       	 
                       	   $ResponseAuthentication = [pscustomobject] @{
				        		
				        									"Result"  = "Successful"
				        									#"Server"  =  $decom_object
				        									#"Os" = "Windows"
				        									"Description" = "Server $decom_object is added successfully to the safe $using:Safe"
				        									
				        									
				        								}
                       	   
                       	}
                       
				        
				         else{
				         $ResponseAuthentication = [pscustomobject] @{
				        		
				        									"Result"  = "Warning"
				        									#"Server"  =  $decom_object
				        									#"Os"= "Windows"
				        									"Description" = "Server $decom_object already Exist to the safe $using:Safe"
				        								    
				        									
				        				        	}
				        	
				        }# End Else
				        	
				        }# End check if         
						Return $ResponseAuthentication
							     
							     
			    
}-SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck -ProxyAccessType NoProxyServer) 
}#try end 
catch
{
	$error.ErrorMessage
	}
break
}#count if end 					           	   	          
else{
	   Write-host "Not able to connect Front-end servers $item"
					           	   		   
 	}
					          
}#item foreach end
	      write-host "@"
          $CyberarkLoginResult |Select -Property * -ExcludeProperty PSComputerName,RunSpaceID,PSShowComputerName|Convertto-Json
        
         
        


##################################

################DECOMM POWEROFF#################

#$ErrorActionPreference = "silentlycontinue"

[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{USERNAME}'


[ValidateNotNullOrEmpty()]
[string] $vcenterserver = '$INPUT{VCENTER}'

[ValidateNotNullOrEmpty()]
	[string]$client = '$INPUT{VMNAME}'
	$changeno 		= '$INPUT{CHANGENUMBER}'
	$CHNSTATUS 		= '$INPUT{CHANGE_STATUS}'
	$CHNSTATUS 		= $CHNSTATUS.Trim('[]')
	$changestrtdate =  '$INPUT{CHANGEstrTDATE}'
	$ip 			= '$INPUT{IP}'
	$strip 		= '$INPUT{str_IP}'
	$backupstatus 	= '$INPUT{BACKUP_STATUS}'
	$strconfigkey  = '$INPUT{str_CONFIGKEY}'
	$bkpmethod	    = '$INPUT{BACKUP_METHOD}'
	$vracheck		= '$INPUT{VRA_CHECK}'
	$INVENTORYstatus		= '$INPUT{INVENTORYRESOUT}'
	$strstatus		= '$INPUT{strRESOUT}'
	$castatus		= '$INPUT{CARESOUT}'
#Densify Credentials
	[ValidateNotNullOrEmpty()]
	$DB_USERNAME 		= '$INPUT{DB_USERNAME}'

	[ValidateNotNullOrEmpty()]
	$DB_USER_PASSWORD 	= ConvertTo-SecureString '$INPUT{DB_PASSWORD}' -AsPlainText -Force

	[ValidateNotNullOrEmpty()]
	$DB_HOST 			= '$INPUT{DB_HOSTNAME}'
	
	
    #Credentials
    $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
    
    function GetConnectionString ($user, $passwd, $dbhost)
{

  return "Server=$dbhost;Database=Automation;Integrated Security=False;User ID= $user ;Password= '$INPUT{DB_PASSWORD}' " 	

}

$connectedServer                    = $global:defaultviserver

#This funtion is to Disconnect the Vcenter Server
function DisconnectVcenter ([string] $vCenter){
    # Disconnect from the current vCenter    
    Try{
        DisConnect-VIServer $vCenter -Confirm:$false  -Force  -ErrorAction Stop
        Write-Output "Disconnected from $vCenter"
        }
    catch{
        Write-output "Host is already Disconnected"
    }     
} 

# Check to see if already connected and Disconnect any leftover connections before strting script.
If($null -eq $connectedServer){
    Try{
        DisConnect-VIServer -server *    -Confirm:$false -Force
    }
    catch {
        #Write-Host "Unable to Disconnect from vcenter Server"
    }
}


$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()

$tabaobj.Add("ActionTask", "POWERDOWN")

if (($client -eq 'server1') -or ($client -eq 'server2' ) -or ($client -eq 'server3')) {

 
    if ($vcenterserver -eq 'vc1' -or $vcenterserver -eq 'vc2' -or $vcenterserver -eq 'vc3' ) {
        try {
            Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false -ErrorAction Stop | Out-Null
            $configset = "INFO No proxy has been set "
        }
        catch { $configset = "ERROR Setting Proxy has failed" }  
    }
    else {
        $configset = "INFO No proxy has been set "
    }
	
	
    if ($configset) {
        $tabaobj.Add("Proxy", $configset)
    }
   

    if (!(Get-Module -Name VMware.VimAutomation.Core)) {
        try {
            Import-Module -Name VMware.VimAutomation.Core -ErrorAction stop
            $moduleset = "INFOVmware module has been imported"
        }
        catch { $moduleset = "ERRORVmware module has not been imported" }

        if ($moduleset) {
            $tabaobj.Add("Modules", $moduleset)
        }
    	
        if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
        else {
            try {
                $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
                $cnvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
                $connected = "INFO Connected to vcenter Server $vcenterserver"
            
            }
            catch {
                $connectmsg = $_.Exception.Message
                $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
            }
            if ($connected) {
                $tabaobj.Add("Connection", $connected)
            }
        
        }
    }
    else {
        try {
            $CREDENTIALS = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD
            $connectvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
            $connected = "INFO Connected to vcenter Server $vcenterserver"
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
        }


        if ($connected) {
            if ($tabaobj.ContainsKey("Connection")) {
                $tabaobj["Connection"] = $connected
            }
            else {
                $tabaobj.Add("Connection", $connected)
            }
        }
     
    }


    if ($connected) {
        if ($connected -notlike "ERROR Could not connect to vCenter*") {
            try {
                $vm = get-vm -Name $client -ErrorAction Stop 
                $vmid = $vm.Id
                $vmfound = "INFO VM $client is found in $vcenterserver"
            }
            catch {
                $clientmsg = $_.Exception.Message
                if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                    try {
                        $decomclient = "$client_DECOM*"
                        $vm = get-vm -Name $decomclient -ErrorAction Stop 
                        $vmid = $vm.Id
                        #write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                        $vmfound = "ERROR :  VM $client in $vcenterserver is renamed for Decomission"
                    }
                    catch {
                        $clientmsg = $_.Exception.Message
                        #write-host "ERROR Unable to find VM $client in $vcenterserver $clientmsg"
                        $vmfound = "ERROR $clientmsg"
                    }
                }
            }
        }
        else {
            $vmfound = "ERROR VM $client is not found in $vcenterserver"
        }

    }


    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }


    if ($vmfound -eq "INFO VM $client is found in $vcenterserver") {
        if ($vm.Name -eq "$client") {
 				try {
 				
				#POWEROFF EXECUTION strTS                    
                    try { 

                    	#Check Poweron Status
						$powerstate = $vm | Select -ExpandProperty PowerState | Out-String
						$powerstate = $powerstate -replace "\r" -replace "\n"
						$vmrename = "$client" + "_DECOM_" + "$changeno"
						if ($powerstate -match "PoweredOn"){
							#Disconnect NIC card
							$job1 = $vm | Get-NetworkAdapter | Set-NetworkAdapter -Connected:$false -strtConnected:$false -Confirm:$false
							#$job1.ConnectionState.Connected
							#poweroff VM
							
							$job2 = Stop-VM -VM $client -confirm:$false
							#$job2.PowerState
							#Rename VM
							$job3 = Get-VM $client | Set-vm -name $vmrename -confirm:$false
							#$job3.Name
							if(($job1.ConnectionState.Connected -eq $false)  -and ($job2.PowerState -match "PoweredOff") -and ($job3.Name -match $vmrename)){
							    $comments = "JobCompleted"
							    $completionStatus = "JobCompleted"
							    $vmoff = "VM RenameDisconnectPowerOff"
							    $jresult = "success"
							    $pcomments = "$client RenameDisconnectPowerOff successfully"
							}
							else{
							    $comments = "ProcessFailed"
							    $completionStatus = "JobPending"
							    $vmoff = "Poweroff Failed"
							    $jresult = "fail"
							    $pcomments = "$client RenameDisconnectPowerOff Failed"
							}
							
							}
						elseif ($powerstate -match "PoweredOff") {
							$comments = "VM Already Poweredoff"
							$completionStatus = "JobPending"
							$vmoff = "Poweroff Failed"
							$jresult = "fail"
							$pcomments = "$client already PoweredOff. No Action required"
						}
						else {
							$vmoff = "Poweroff Failed"
							$completionStatus = "JobPending"
							$Comments = "Cant Find VM"
							$jresult = "fail"
							$pcomments = "$client not Found in Vcenter"
						}
						if ($completionStatus -match "JobCompleted") {
#write to DB
$query = @"
UPDATE [dbo].[TEST_REF_V2]
   SET [RenamedVMName] = '$vmrename',
   	   [vmPowerOffState] = 'Success'
   
 WHERE `VMName`= '$client'
"@
							
						[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
						$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
						#$SqlConnection.ConnectionString = GetConnectionString
						$SqlConnection.ConnectionString = $connectionString
						$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
						$SqlCmd.CommandText = $query   
						$SqlCmd.Connection = $SqlConnection  
						
						$SqlConnection.Open()
								
						#Execute SQL Query
						$result = $SqlCmd.ExecuteNonQuery()
						
						if($result -eq 1) {
#Create SQL Statement
$query = @"
SELECT VMName,vmPowerOffState,RenamedVMName FROM [dbo].[TEST_REF_V2] WITH (NOLOCK)
WHERE `VMName`= '$client'
"@
						[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
						$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
						$SqlConnection.ConnectionString = $connectionString
						$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
						$SqlCmd.CommandText = $query  
						$SqlCmd.Connection = $SqlConnection  
						
						$SqlConnection.Open()
					
						$result = $SqlCmd.ExecuteReader()
						
						if($result)
						{
						#Add result to DataTable Object and Display it
						$table = new-object "System.Data.DataTable"
						$table.Load($result)
						
						#Write-Host ($table | Format-Table | Out-String)
						$SqlConnection.Close()
						}
						
						else
						{
							write-host "Unsuccessful : $query"
						}
						}
						}
					
						#write-host "Feth=|$vmname|$vmrename|$HOSTNM|$changeno|$CHNSTATUS|$changestrtdate|$timer|$vmoff|$CompletionStatus|$Comments| >"
													
		
								$hashobj = New-Object System.Collections.Specialized.OrderedDictionary
								$hashobj.Add("INVENTORYMarkPendingDecom", $INVENTORYstatus)
								$hashobj.Add("strUpdate", $strstatus)
								$hashobj.Add("carkUpdate", $castatus)
								$hashobj.Add("vmname", $client)
								$hashobj.Add("vCenter", $vcenterserver)
								$hashobj.Add("VMPowerState", $powerstate)
								$hashobj.Add("RenamedVM", $vmrename)
								$hashobj.Add("result", $jresult)
								$hashobj.Add("message", $pcomments)

<#
								$vmrename = "$client" + "_DECOM_" + "$changeno"		
								$hashobj = New-Object System.Collections.Specialized.OrderedDictionary
								$hashobj.Add("INVENTORYMarkPendingDecom", $INVENTORYstatus)
								$hashobj.Add("strUpdate", $strstatus)
								$hashobj.Add("carkUpdate", $castatus)
								$hashobj.Add("vmname", $client)
								$hashobj.Add("vCenter", $vcenterserver)
								$hashobj.Add("VMPowerState", "PoweredOff")
								$hashobj.Add("RenamedVM", $vmrename)
								$hashobj.Add("result", "success")
								$hashobj.Add("message", "$client RenameDisconnectPowerOff successfully")
#>
								#$hashobj | ConvertTo-Json
                            	if ($tabaobj.ContainsKey("VMData")) {
                                $tabaobj["VMData"] = $hashobj
                            	}
                            	else {
                                $tabaobj.Add("VMData", $hashobj)
                            	}

					    }
					#END POWEROFF
				    Catch {
                                $global:configmsg = $_.Exception.Message
                                #cut
                                if ($global:configmsg ) {
		                            if ($tabaobj.ContainsKey("VMData")) {
                                    $tabaobj["VMData"] = $global:configmsg
                                    }
                                    else {
                                    $tabaobj.Add("VMData", $global:configmsg)
                                    }
                                    }
                                #cut
                            }
                                    
                }                
   								
                catch {
                    $opitmalmsg = $_.Exception.Message
                    if ($opitmalmsg) {
                    	if ($tabaobj.ContainsKey("VMData")) {
                        $tabaobj["VMData"] = $opitmalmsg
                    	}
                    else {
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                	}
                    
                }
        } 
    }
    else {
            $vmfound = "ERROR The VM $client not found in vCenter $vcenterserver"
            if ($vmfound) {
            	if ($tabaobj.ContainsKey("VmStatus")) {
                    $tabaobj["VmStatus"] = $vmfound
                }
                else {
                    $tabaobj.Add("VmStatus", $vmfound)
                }
            	$jresult = "fail"
				$addtodb = "NO"
				$Comments = "Cant Find VM in Vcenter"
            	$hashobj = New-Object System.Collections.Specialized.OrderedDictionary
							
				$hashobj.Add("vmname", $client)
				$hashobj.Add("vCenter", $vcenterserver)
				$hashobj.Add("vmip", $ip)
				$hashobj.Add("strcheck", $strcheck)
				$hashobj.Add("strConfigKey", $strconfigkey)
				$hashobj.Add("BackupMethod", $bkpmethod)
				$hashobj.Add("VRABuild", $vracheck)
				$hashobj.Add("VMPowerState", "Not Applicable")
				$hashobj.Add("result", $jresult)
				$hashobj.Add("message", $Comments)
			
				#$hashobj | ConvertTo-Json
                if ($tabaobj.ContainsKey("VMData")) {
                	$tabaobj["VMData"] = $hashobj
                }
                else {
                	$tabaobj.Add("VMData", $hashobj)
                }
            }
        }
   
    $tabaobj | ConvertTo-Json
    DisConnect-VIServer $vcenterserver -Confirm:$false  -Force  -ErrorAction Stop
}

#######################

###############VRA DESTROY#########


if(!(Get-Module -Name powervRA))
	{
    	Import-Module -Name powervRA
    	if(!$?){ throw "Could not load powerVRA" }  
    }

[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

#DB Credentials
	[ValidateNotNullOrEmpty()]
	$DB_USERNAME = '$INPUT{DB_USERNAME}'

	[ValidateNotNullOrEmpty()]
	$DB_USER_PASSWORD = ConvertTo-SecureString '$INPUT{DB_PASSWORD}' -AsPlainText -Force

	[ValidateNotNullOrEmpty()]
	$DB_HOST = '$INPUT{DB_HOSTNAME}'
	
	  
    function GetConnectionString ($user, $passwd, $dbhost)
{

  return "Server=$dbhost;Database=Automation;Integrated Security=False;User ID= $user ;Password= '$INPUT{DB_PASSWORD}' " 	
  
}
$testserver = 'server1'

$username = '$INPUT{VRAUSER}'
$password = ConvertTo-SecureString '$INPUT{VRAPASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password
$servertodecom = '$INPUT{SNAME}'
$baseserver = 'vraexample.com'
$tenant     = 'testcompany'



function DisconnectVRA(){
    # Disconnect from the current vCenter    
    Try{
        Disconnect-vRAServer -Confirm:$false -ErrorAction Stop
        Write-host   "------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
        Write-Output "Disconnected from VRAHOST"
        }
    catch{
        Write-output "Already Disconnected"
        Write-host   "------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
    }     
}


$vraconn = Connect-vRAServer -Server $baseserver  -Tenant $tenant  -Credential $credential -IgnoreCertRequirements

Write-Host " Server to destroy $servertodecom"
Write-Host "================================="
Write-Host ""
$ResourceActionId = (Get-vRAResource -Name $servertodecom | Get-vRAResourceAction | Where-Object {$_.Name -eq "Reboot"}).id
$ResourceActionId

$execdestroy = Request-vRAResourceAction -Id $ResourceActionId -ResourceName $servertodecom -Confirm:$false -Wait
$execdestroy
if ($execdestroy.RequestCompletion.requestCompletionState -eq 'SUCCESSFUL')
{
$CompletionStatus = $execdestroy.RequestCompletion.requestCompletionState
#write to DB
			write-host "Executed VRA destroy for $servertodecom" 
			$query = @"
			UPDATE [dbo].[TEST_REF_V2]
   			SET [vmVRADestroy] = 'Success',
   			[CompletionStatus] = 'Success'
   			WHERE `VMName`= '$servertodecom'
"@
$query
			[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
			$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
			#$SqlConnection.ConnectionString = GetConnectionString
			$SqlConnection.ConnectionString = $connectionString
			$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
			$SqlCmd.CommandText = $query   
			$SqlCmd.Connection = $SqlConnection  
			$SqlConnection.Open()
	
			#Execute SQL Query
			$result = $SqlCmd.ExecuteNonQuery()

			if($result -eq 1)
			{
			#Create SQL Statement
			$query = @"
			SELECT vmVRADestroy FROM [dbo].[TEST_REF_V2] 
			WHERE `VMName`= '$servertodecom'
"@
			$query
			[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
			$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
			#$SqlConnection.ConnectionString = GetConnectionString
			$SqlConnection.ConnectionString = $connectionString
			$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
			$SqlCmd.CommandText = $query  
			$SqlCmd.Connection = $SqlConnection  
	
			$SqlConnection.Open()

			$result = $SqlCmd.ExecuteReader()

			if($result)
			{
			#Add result to DataTable Object and Display it
			$table = new-object "System.Data.DataTable"
			$table.Load($result)

			Write-Host ($table | Format-Table | Out-String)
			$SqlConnection.Close()
			}

			else
			{
			write-host "Unsuccessful : $query"
			}
			}	
Write-host "Changeupdate=|$CompletionStatus|"
}
else{write-host "$servertodecom VRA DESTROY failed to execute!!" 
                }

DisconnectVRA



######################


###########DECOM DELETE SC#################


#$ErrorActionPreference = "silentlycontinue"

[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{USERNAME}'


[ValidateNotNullOrEmpty()]
[string] $vcenterserver = '$INPUT{VCENTER}'
[String]$renamedvmname = '$INPUT{CSV_RENAMEDVMNAME}'

[ValidateNotNullOrEmpty()]
	[string]$client = '$INPUT{VMNAME}'
	$changeno 		= '$INPUT{CHANGENUMBER}'
	$CHNSTATUS 		= '$INPUT{CHANGE_STATUS}'
	$CHNSTATUS 		= $CHNSTATUS.Trim('[]')
	$changestartdate =  '$INPUT{CHANGESTARTDATE}'
	$vracheck		= '$INPUT{VRA_CHECK}'
	$poweroffdate = '$INPUT{CSV_VMPOWEROFFSTATE}'
	
#Densify Credentials
	[ValidateNotNullOrEmpty()]
	$DB_USERNAME 		= '$INPUT{DB_USERNAME}'

	[ValidateNotNullOrEmpty()]
	$DB_USER_PASSWORD 	= ConvertTo-SecureString '$INPUT{DB_PASSWORD}' -AsPlainText -Force

	[ValidateNotNullOrEmpty()]
	$DB_HOST 			= '$INPUT{DB_HOSTNAME}'
	
	
    #Credentials
    $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
    
    function GetConnectionString ($user, $passwd, $dbhost)
{

  return "Server=$dbhost;Database=Automation;Integrated Security=False;User ID= $user ;Password= '$INPUT{DB_PASSWORD}' " 	

}

$connectedServer                    = $global:defaultviserver

#This funtion is to Disconnect the Vcenter Server
function DisconnectVcenter ([string] $vCenter){
    # Disconnect from the current vCenter    
    Try{
        DisConnect-VIServer $vCenter -Confirm:$false  -Force  -ErrorAction Stop
        Write-Output "Disconnected from $vCenter"
        }
    catch{
        Write-output "Host is already Disconnected"
    }     
} 

# Check to see if already connected and Disconnect any leftover connections before starting script.
If($null -eq $connectedServer){
    Try{
        DisConnect-VIServer -server *    -Confirm:$false -Force
    }
    catch {
        #Write-Host "Unable to Disconnect from vcenter Server"
    }
}


$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()

$tabaobj.Add("ActionTask", "DELETE")

#if (($client -eq 'server1') -or ($client -eq 'server2' )) {

 
    if ($vcenterserver -eq 'vc1' -or $vcenterserver -eq 'vc2' -or $vcenterserver -eq 'vc3' ) {
        try {
            Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false -ErrorAction Stop | Out-Null
            $configset = "INFO No proxy has been set "
        }
        catch { $configset = "ERROR Setting Proxy has failed" }  
    }
    else {
        $configset = "INFO No proxy has been set "
    }
	
	
    if ($configset) {
        $tabaobj.Add("Proxy", $configset)
    }
   

    if (!(Get-Module -Name VMware.VimAutomation.Core)) {
        try {
            Import-Module -Name VMware.VimAutomation.Core -ErrorAction stop
            $moduleset = "INFOVmware module has been imported"
        }
        catch { $moduleset = "ERRORVmware module has not been imported" }

        if ($moduleset) {
            $tabaobj.Add("Modules", $moduleset)
        }
    	
        if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
        else {
            try {
                $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
                $cnvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
                $connected = "INFO Connected to vcenter Server $vcenterserver"
            
            }
            catch {
                $connectmsg = $_.Exception.Message
                $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
            }
            if ($connected) {
                $tabaobj.Add("Connection", $connected)
            }
        
        }
    }
    else {
        try {
            $CREDENTIALS = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD
            $connectvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
            $connected = "INFO Connected to vcenter Server $vcenterserver"
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
        }


        if ($connected) {
            if ($tabaobj.ContainsKey("Connection")) {
                $tabaobj["Connection"] = $connected
            }
            else {
                $tabaobj.Add("Connection", $connected)
            }
        }
     
    }


    if ($connected) {
        if ($connected -notlike "ERROR Could not connect to vCenter*") {
            try {
                $vm = get-vm -Name $renamedvmname -ErrorAction Stop 
                $vmid = $vm.Id
                $vmfound = "INFO VM $client is found in $vcenterserver"
            }
            catch {
                $clientmsg = $_.Exception.Message
                if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                    try {
                        $decomclient = "$client_DECOM*"
                        $vm = get-vm -Name $decomclient -ErrorAction Stop 
                        $vmid = $vm.Id
                        #write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                        $vmfound = "ERROR :  VM $client in $vcenterserver is renamed for Decomission"
                    }
                    catch {
                        $clientmsg = $_.Exception.Message
                        #write-host "ERROR Unable to find VM $client in $vcenterserver $clientmsg"
                        $vmfound = "ERROR $clientmsg"
                    }
                }
            }
        }
        else {
            $vmfound = "ERROR VM $client is not found in $vcenterserver"
        }

    }


    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }


    if ($vmfound -eq "INFO VM $client is found in $vcenterserver") {
        if ($vm.Name -eq "$renamedvmname") {
 				try {
 				
				#DELETETASK EXECUTION STARTS                    
                    try {

                        $vm = Get-VM -name $renamedvmname | Get-NetworkAdapter
                        #Check NIC card status    
                        if($vm.ConnectionState.Connected -eq $false) {                        
                            $Nicstate = "Disconnected"
                        }                        
                        else {
                            $Nicstate = "Connected"
                        }
                        #Check Poweron Status
                        $powerstate = get-vm -name $renamedvmname | Select -ExpandProperty PowerState | Out-String
                        $powerstate = $powerstate -replace "\r" -replace "\n"
                        
                        if (($Nicstate -match "Disconnected") -and ($powerstate -match "PoweredOff")) {
                            $job1 = Remove-VM -VM $renamedvmname -DeletePermanently -Confirm:$false
                            $comments = "JobCompleted"
							$completionStatus = "JobCompleted"
							$VMDeletion = "VM Deleted"
							$jresult = "success"
							$pcomments = "$client Deleted successfully"
                        }
                        elseif ($Nicstate -cmatch "Connected") {
						    $comments = "ProcessFailed"
						    $completionStatus = "JobPending"
						    $VMDeletion = "NIC still connected"
						    $jresult = "fail"
						    $pcomments = "$client Deletion Failed. NIC still Connected"
                        }
                        elseif ($powerstate -match "PoweredOn") {
                            $comments = "ProcessFailed"
						    $completionStatus = "JobPending"
						    $VMDeletion = "VM still poweredon"
						    $jresult = "fail"
						    $pcomments = "$client Deletion Failed. VM still poweredOn"
                        }
                        else {
                            $Comments = "ProcessFailed"
                            $completionStatus = "JobPending"
							$VMDeletion = "Cant Find VM"
							$jresult = "fail"
							$pcomments = "$client not Found in Vcenter"
                        }
                        if ($completionStatus -match "JobCompleted") {
#write to DB
$query = @"
UPDATE [dbo].[TEST_REF_V2]
   SET [vmDeletionState] = 'Success',
   	   [CompletionStatus] = 'Success'
WHERE `VMName`= '$client'
"@
                        
                        	[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
                        	$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
                        	#$SqlConnection.ConnectionString = GetConnectionString
                        	$SqlConnection.ConnectionString = $connectionString
                        	$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
                        	$SqlCmd.CommandText = $query   
                        	$SqlCmd.Connection = $SqlConnection  
                        	
                        	$SqlConnection.Open()
	
                            #Execute SQL Query
                            $result = $SqlCmd.ExecuteNonQuery()
                            $SqlConnection.close()
                            if($result -eq 1) {
#Create SQL Statement
$query = @"
SELECT VMName,vmPowerOffState,vmDeletionDate,CompletionStatus FROM [dbo].[TEST_REF_V2] WITH (NOLOCK)
WHERE `VMName`= '$client'
"@

                                [string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD -dbhost $DB_HOST
                            	$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
                            	#$SqlConnection.ConnectionString = GetConnectionString
                            	$SqlConnection.ConnectionString = $connectionString
                            	$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
                            	$SqlCmd.CommandText = $query  
                            	$SqlCmd.Connection = $SqlConnection	
                            	$SqlConnection.Open()
                                $result = $SqlCmd.ExecuteReader()
                                if($result) {
                                    #Add result to DataTable Object and Display it
                                    $table = new-object "System.Data.DataTable"
                                    $table.Load($result)
                                   
                                    Write-Host ($table | Format-Table | Out-String)
                                    $SqlConnection.Close()
                                }
                                else {
                            	    write-host "Unsuccessful : $query"
                                }
                                }
                                }                  
					
								$hashobj = New-Object System.Collections.Specialized.OrderedDictionary
								$hashobj.Add("vmname", $client)
								$hashobj.Add("vCenter", $vcenterserver)
								$hashobj.Add("RenamedVM", $renamedvmname)
								$hashobj.Add("VMStatus", $VMDeletion)
								$hashobj.Add("result", $jresult)
								$hashobj.Add("message", $pcomments)

				
<#								#$hashobj | ConvertTo-Json
								$hashobj = New-Object System.Collections.Specialized.OrderedDictionary
								$hashobj.Add("vmname", $client)
								$hashobj.Add("vCenter", $vcenterserver)
								$hashobj.Add("RenamedVM", $renamedvmname)
								$hashobj.Add("DeletionStatus", "VM Deleted")
								$hashobj.Add("result", "success")
								$hashobj.Add("message", "$client Deleted successfully")
#>
                            	if ($tabaobj.ContainsKey("VMData")) {
                                $tabaobj["VMData"] = $hashobj
                            	}
                            	else {
                                $tabaobj.Add("VMData", $hashobj)
                            	}

					    }
					#END DELETETASK
				    Catch {
                                $global:configmsg = $_.Exception.Message
                                #cut
                                if ($global:configmsg ) {
		                            if ($tabaobj.ContainsKey("VMData")) {
                                    $tabaobj["VMData"] = $global:configmsg
                                    }
                                    else {
                                    $tabaobj.Add("VMData", $global:configmsg)
                                    }
                                    }
                                #cut
                            }
                                    
                }                
   								
                catch {
                    $opitmalmsg = $_.Exception.Message
                    if ($opitmalmsg) {
                    	if ($tabaobj.ContainsKey("VMData")) {
                        $tabaobj["VMData"] = $opitmalmsg
                    	}
                    else {
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                	}
                    
                }
        } 
    }
    else {
            $vmfound = "ERROR The VM $client not found in vCenter $vcenterserver"
            if ($vmfound) {
            	if ($tabaobj.ContainsKey("VmStatus")) {
                    $tabaobj["VmStatus"] = $vmfound
                }
                else {
                    $tabaobj.Add("VmStatus", $vmfound)
                }
            	$jresult = "fail"
				$addtodb = "NO"
				$Comments = "Cant Find VM in Vcenter"
				$hashobj = New-Object System.Collections.Specialized.OrderedDictionary
				$hashobj.Add("vmname", $client)
				$hashobj.Add("vCenter", $vcenterserver)
				$hashobj.Add("RenamedVM", $renamedvmname)
				$hashobj.Add("DeletionStatus", "VM Deleted")
				$hashobj.Add("result", $jresult)
				$hashobj.Add("message", $Comments)
			
				#$hashobj | ConvertTo-Json
                if ($tabaobj.ContainsKey("VMData")) {
                	$tabaobj["VMData"] = $hashobj
                }
                else {
                	$tabaobj.Add("VMData", $hashobj)
                }
            }
        }
   
    $tabaobj | ConvertTo-Json
    DisConnect-VIServer $vcenterserver -Confirm:$false  -Force  -ErrorAction Stop
#}



###################


############BKS ACC#########


#!/bin/bash
# bks console cleanup process for decommissioned servers

HostInput='$INPUT{HOSTNAME}'
targetHost=`echo $HostInput | tr '[:upper:]' '[:lower:]'`

VALIDATE () {
    /usr/boksm/bin/suexec /security/SCRIPTS/company.bin/decom_system.sh -h $targetHost -m validate 2> /tmp/validateServerFinal
}

if [ `VALIDATE | grep -i "HOST FOUND" | wc -l` != 0 ]; then
    echo "`VALIDATE | grep -i 'HOST FOUND' | awk -F! '{print $1}'`|"
    /usr/boksm/bin/suexec /security/SCRIPTS/company.bin/decom_system.sh -h $targetHost -m stage 2> /tmp/stageServerFinal
    cat /tmp/stageServerFinal | egrep -i "WARNING|connecting" | grep -v "#" | awk 'NF'
else
    echo "$targetHost Host not found"
fi

######################


###############WIN service restart##############

$script = {
    if (Get-Command ConvertTo-Json -CommandType Cmdlet -ErrorAction SilentlyContinue) {
    	stop-service -Name '$INPUT{SERVICE_NAME}' -EA ignore
        $serviceget = Get-Service -Name '$INPUT{SERVICE_NAME}' -EA ignore
        
        if ($serviceget.StartType) {
            $serviceget | select @{Label = "Status"; Expression = { $_.Status.ToString() } }, @{Label = "StartType"; Expression = { $_.StartType.ToString() } }
        }
        else {
            gwmi win32_service | where { $_.Name -eq '$INPUT{SERVICE_NAME}' } | select @{Label = "Status"; Expression = { $_.State.ToString() } }, @{Label = "StartType"; Expression = { $_.StartMode.ToString() } }
        }
    }
    else {
        $serviceget = Get-Service -Name '$INPUT{SERVICE_NAME}'

        if ($serviceget.StartType) {
            $serviceget | select @{Label = "Status"; Expression = { $_.Status.ToString() } }, @{Label = "StartType"; Expression = { $_.StartType.ToString() } }
        }
        else {
            gwmi win32_service | where { $_.Name -eq '$INPUT{SERVICE_NAME}' } | select @{Label = "Status"; Expression = { $_.State.ToString() } }, @{Label = "StartType"; Expression = { $_.StartMode.ToString() } }
        }
    }
}

$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password

try {
    $servicestatus = Invoke-Command -ComputerName $INPUT{COMPUTER_NAME} -Credential $credential -Scriptblock $script -EA Stop
}
catch {
    $servicestatus = Invoke-Command -ComputerName $INPUT{COMPUTER_NAME} -Credential $credential -usessl -Scriptblock $script -ErrorVariable errmsg
}
finally {
    if (!$servicestatus) { Write-Output "An error occurred retrieving the service status" }elseif ($servicestatus.Status -eq 'Running') { Write-Output "Service already in Running status" }elseif ($servicestatus.StartType.toLower() -notlike "*auto*") { Write-Output "Service Startup Type is not Automatic" }else {
        $script = {
            if (Get-Command ConvertTo-Json -CommandType Cmdlet -ErrorAction SilentlyContinue) {
                Restart-Service '$INPUT{SERVICE_NAME}' -Force -PassThru -WarningAction silentlyContinue | select-object Name, @{Label = "Status"; Expression = { $_.Status.ToString() } } | ConvertTo-Json
            }
            else {
                Restart-Service '$INPUT{SERVICE_NAME}' -Force -PassThru -WarningAction silentlyContinue | Select-Object Name, @{Label = "Status"; Expression = { $_.Status.ToString() } }
            }
        }
        $restartcount = 0
        do {
            try {
                $restartresults = Invoke-Command -ComputerName $INPUT{COMPUTER_NAME} -Credential $credential -Scriptblock $script -EA Stop
            }
            catch {
                $restartresults = Invoke-Command -ComputerName $INPUT{COMPUTER_NAME} -Credential $credential -usessl -Scriptblock -ErrorVariable errmsg
            }
            finally {
                if (!$restartresults) {
                    Write-Output "An error occurred restarting the service" 
                    $failed = 'True'
                }
                else {
                    $failed = 'false' 
                    Write-Output "Service restarted Successfully"
                }
            }
            $restartcount = $restartcount + 1
        }until(($failed -eq 'false') -or { $restartcount -eq 3 })
    }
}




####################

#############SERVER UTILCMD##########


$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password

 

$script = {
$INPUT{UTIL}
}

 

#Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock{ 
    
#    $possible=$args[0]
#
#write-host "Command results for $env:COMPUTERNAME"
#powershell.exe "$possible"
#} -ArgumentList $UTIL -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)

 

 

Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock $script -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)



###################

#################SERVER UTIL MAIN##

$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password
$UTIL = '$INPUT{UTIL}'
$LOGMAN = '$INPUT{LOGMAN}'

Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {

$UTIL=$args[0].trim()
$runtime=$args[1].trim()

write-host "$UTIL for $env:COMPUTERNAME"

switch($UTIL){
	
("Initiate Logman") {$logmanRunning=""


#Check for LogMan Installation
if (!(test-path c:\windows\system32\logman.exe)){
                                                Write-Output "Logman Not Installed Please install and Try Again"
                                                Exit
                                                }
else                                            {
                                                Write-Output "Logman is installed on Server"

# Verify the PerfLog-Long Counter exist if not create it
                                                [string]$PerfLoglongExist= Logman
                                                If (!($PerfLoglongExist.Contains("PerfLog-Long"))) {
                                                                                   write-output "Create Perf Counter"
                                                                                   logman.exe create counter PerfLog-Long -o "C:\perflogs\PerfLog-Long.blg" -f bincirc -v mmddhhmm -max 300 -c "\LogicalDisk(*)\*" "\Memory\*" "\.NET CLR Memory(*)\*" "\Cache\*" "\Network Interface(*)\*" "\Netlogon(*)\*" "\Paging File(*)\*" "\PhysicalDisk(*)\*" "\Processor(*)\*" "\Processor Information(*)\*" "\Process(*)\*" "\Redirector\*" "\Server\*" "\System\*" "\Server Work Queues(*)\*" "\Terminal Services\*" -si 00:05:00 
                                                                                  }
                                                else                              {
                                                                                   write-output "Perf Counter already Exist"
                                                                                   }
                                                }

# Start Logman Collection.
$LogManRunning = Logman PerfLog-long

If ($logManRunning -contains "Running")	{
					Write-OutPut "`n PerfLog-Long is already Running, so Exiting `n"
					Exit
					}
else                {
					Write-Output "`n Starting PerfLog-Long..... `n"
					invoke-expression "Logman.exe start PerfLog-Long"
					}
#Schedule Job on Local Server to Stop Logmon when Run Time Expire the default is 24 hours.
$SchedTsksExist = get-scheduledjob |where-object {$_.name -like "*LogManStop*"}
if ($SchedTsksExist) {
                    Write-output "Current Schedule: `n" $SchedTsksExist "`n"
                    get-jobtrigger -name "LogManStop"
                   }

$RunHours = ((get-date).addhours($runtime))

if ($SchedTsksExist){
                    write-output "Job exist already updating the scheduledtask"
                    $Trigger =  New-JobTrigger  -once -At $RunHours
                    Get-ScheduledJob -name "LogManStop" | Set-ScheduledJob -Trigger $Trigger
                    Write-output "Updated Schedule: `n" $SchedTsksExist "`n" 
                    get-jobtrigger -name "LogManStop"
                    }
else
                    {
                    Write-output  "Creating LogManStop scheduled task"
                    $Trigger =  New-JobTrigger   -once -At $RunHours
                    Register-ScheduledJob -Name LogManStop -Trigger $Trigger -ScriptBlock {Logman.exe stop PerfLog-Long}
                    Write-output "New Schedule Created: `n" $SchedTsksExist
                    }
	}

("Fetch Disk Block Size"){

try
{
$devices=(gwmi win32_logicaldisk).DeviceID
foreach($dev in $devices)
{
   Write-host "Fetching the details for Drive $dev"
   Write-host " "
    &cmd /c "fsutil fsinfo ntfsinfo $dev"
   Write-host " "
}
}
catch
{
  Write-host "Error Fetching the details using FSUTIL"
}




try{
Write-host "Fetching the details for Drive using WMIC"


    Get-WmiObject -Class Win32_Volume | Select-Object Name,Label, BlockSize | Format-Table -AutoSize
}
catch
{
  Write-host "Error Fetching the details using WMIC"
}

	
	
	}


("DNS Check - company.com"){

$ServerName = gc env:computername
Write-host " "
Write-host $ServerName
Write-host " "
$DnsCheck = Resolve-DnsName -name company.com -DnsOnly -Type NS | Format-table -Property name,Type,TTL,Section,NameHost -AutoSize

$DnsCheck	
	
	}
	
("DNS Check - company.com"){

$ServerName = gc env:computername
Write-host " "
Write-host $ServerName
Write-host " "
$DnsCheck = Resolve-DnsName -name company.com -DnsOnly -Type NS | Format-table -Property name,Type,TTL,Section,NameHost -AutoSize

$DnsCheck	
	
	}
	
("Verify Admin Groups"){

$members = net localgroup administrators
$domain1 = (Get-WmiObject Win32_ComputerSystem).Domain
$domain = Echo "$domain1".trimend(".com")
$users = "$domain\ETS-DS Windows Support-Internal-AG","$domain\Global-Local Server Admins"
$env:COMPUTERNAME

ForEach ($user in $users) {
    If ($members -contains $user) {
      Write-Host "$user exists in the Administrators group"
 } Else {
      Write-Host "$user does not exist in the Administrators group"
}}	
	
	}

	
("DNS Check - company.com"){

$ServerName = gc env:computername
Write-host " "
Write-host $ServerName
Write-host " "
$DnsCheck = Resolve-DnsName -name company.com.com -DnsOnly -Type NS | Format-table -Property name,Type,TTL,Section,NameHost -AutoSize

$DnsCheck	
	
	}
	
("DNS Check - company.com"){

$ServerName = gc env:computername
Write-host " "
Write-host $ServerName
Write-host " "
$DnsCheck = Resolve-DnsName -name company.com -DnsOnly -Type NS | Format-table -Property name,Type,TTL,Section,NameHost -AutoSize

$DnsCheck	
	
	}

("Check CPU Usage") {$CpuCores = (Get-WMIObject Win32_ComputerSystem).NumberOfLogicalProcessors
(get-counter "\Process(*)\% Processor Time").CounterSamples | Select InstanceName,@{Name="CPU %";Expression={[Decimal]::Round(($_.CookedValue / $CPUCores),2)}} | Format-Table -autosize
}

("Get CPU Details") {$CpuCores = (Get-WMIObject Win32_ComputerSystem).NumberOfLogicalProcessors
Write-host "$env:COMPUTERNAME has $CpuCores cores"

write-host "---------------------------------"


[array]$Cpusocket = gwmi win32_Processor  | select-object SocketDesignation
$Cpusocketcount = $Cpusocket.Count
[array]$cpuinfo=gwmi win32_Processor | select-object NumberOfCores,DeviceID,Name
$fcpu=@()
Foreach($cpu in $cpuinfo)
{
$cpuname=$cpu.Name
$cpusocket=$cpu.DeviceID
$cpucores=$cpu.NumberOfCores
$fcpu +="Name:$cpuname,Socket:$cpusocket,Cores:$cpucores"
}
write-host "Total CPU Socket $Cpusocketcount"

 $fcpu


}

("Check Memory Usage") {


$opers=gwmi -Class win32_operatingsystem | select TotalVisibleMemorySize,FreePhysicalMemory
$usage="{0:N2}" -f ((($opers.TotalVisibleMemorySize - $opers.FreePhysicalMemory)*100)/ $opers.TotalVisibleMemorySize) 

Write-host " "

Write-host "Memory Usage for $env:COMPUTERNAME is  $usage %"

Write-host " "

Write-host "Memory Handles for $env:COMPUTERNAME are shown below"

Write-host " "
get-process | Select-Object -Property Name,
			@{Name='PM(MB)';Expression={[math]::round($_.pm / 1024kb)}},
			@{Name='WS(MB)';Expression={[math]::round($_.ws / 1024kb)}},
			@{Name='VM(MB)';Expression={[math]::round($_.vm / 1024kb)}},
			Handles,
			NPM,
			ID,
			ProcessName,
			Description | Sort-Object 'PM(MB)' -Descending

}

("Last 30 days user logon"){
$ErrorActionPreference = 'SilentlyContinue'
$Result = @()
 Write-Host "Gathering Event Logs, this can take awhile..."
 $ELogs = Get-EventLog System -Source Microsoft-Windows-WinLogon -After (Get-Date).AddDays(-30) 
 If ($ELogs)
 { Write-Host "Processing..."
 ForEach ($Log in $ELogs)
 { If ($Log.InstanceId -eq 7001)
   { $ET = "Logon"
   }
   Else
   { Continue
   }

   $ftime=$Log.TimeWritten
   $mtype=$ET
   $muser=(New-Object System.Security.Principal.SecurityIdentifier $Log.ReplacementStrings[1]).Translate([System.Security.Principal.NTAccount])

   $Result += "$ftime - $mtype - $muser"
 }
 
 $Result
 Write-Host "Done."
 
 Write-host " "
 Write-host "Checking the last access time of User profiles avaialble in machine for 30 days"
 Get-ChildItem c:\users | where {$_.LastAccessTime -gt (get-date).AddDays(-30)} |sort-object -Property LastAccessTime -Descending
 
 }
 Else
 { Write-Host "Problem with Computer."
 Write-Host "If you see a 'Network Path not found' error, try starting the Remote Registry service on that computer."
 Write-Host "Or there are no logon/logoff events (XP requires auditing be turned on)"
 }
 }

("Get Memory Details") {

$opers=gwmi -Class win32_operatingsystem

$TotMem=[math]::Round($opers.TotalVisibleMemorySize/1024kb)
$FreeMem=[math]::Round($opers.FreePhysicalMemory/1024kb)

Write-host "$env:COMPUTERNAME has Total : $TotMem GB and Free : $FreeMem GB"

}

("Get Page File Info"){$pginfo=gwmi win32_pagefile |select MaximumSize,InitialSize,System,Status,Description,Filesize
$usage= gwmi win32_PageFileusage | select PeakUsage,CurrentUsage,TempPageFile
$pgmin=$pginfo.MaximumSize/1024
$pgmax=$pginfo.InitialSize/1024
$pgsize=$pginfo.Filesize/1GB
$pgpeak=$usage.PeakUsage
$pgcurrent=$usage.CurrentUsage
$pgtempstatus=$usage.TempPageFile


if(($pgmin -eq 0) -and ($pgmax -eq 0))
{
write-host "Results : System Managed Page file did not match company standards | Total: $pgsize - Minimum: $pgmin - Maximum: $pgmax  - Peakusage: $pgpeak - Currentusage: $pgcurrent - Temppagefile: $pgtempstatus"
}
elseif((($pgmin -eq 4) -and ($pgmax -eq 4)))
{

write-host "Results : Custom Managed Page file matches company standards | Total: $pgsize - Minimum: $pgmin - Maximum: $pgmax  - Peakusage: $pgpeak - Currentusage: $pgcurrent - Temppagefile: $pgtempstatus"
}
else
{
write-host "Results : Custom Managed Page file did not match company standards | Total: $pgsize - Minimum: $pgmin - Maximum: $pgmax  - Peakusage: $pgpeak - Currentusage: $pgcurrent - Temppagefile: $pgtempstatus"

}
write-host "`n`nPagefile Details"
write-host "================="
wmic pagefile list /format:list


}


("Get Drives PWWN"){Set-PSDebug -Strict

Function Main {

    $diskdrives = get-wmiobject Win32_DiskDrive | sort Index

    $colSize = @{Name='Size';Expression={Get-HRSize $_.Size}}

    foreach ( $disk in $diskdrives ) {

        $scsi_details = 'SCSI ' + $disk.SCSIBus         + ':' +
                                  $disk.SCSILogicalUnit + ':' +
                                  $disk.SCSIPort        + ':' +
                                  $disk.SCSITargetID
        write $( 'Disk ' + $disk.Index + ' - ' + $scsi_details +
                 ' - ' + ( Get-HRSize $disk.size) )
       
        $ID        = get-disk $disk.index | select uniqueid
        

        $part_query = 'ASSOCIATORS OF {Win32_DiskDrive.DeviceID="' +
                      $disk.DeviceID.replace('\','\\') +
                      '"} WHERE AssocClass=Win32_DiskDriveToDiskPartition'

        $partitions = @( get-wmiobject -query $part_query | 
                         sort StartingOffset )
        foreach ($partition in $partitions) {

            $vol_query = 'ASSOCIATORS OF {Win32_DiskPartition.DeviceID="' +
                         $partition.DeviceID +
                         '"} WHERE AssocClass=Win32_LogicalDiskToPartition'
            $volumes   = @(get-wmiobject -query $vol_query)
            

            write $( '    Partition ' + $partition.Index + '  ' +
                     ( Get-HRSize $partition.Size) + '  ' +
                     $partition.Type
                       
                   )

            foreach ( $volume in $volumes) {
                write $( '        ' + $volume.name + 
                         ' [' + $volume.FileSystem + '] ' + 
                         ( Get-HRSize $volume.Size ) + ' ( ' +
                         ( Get-HRSize $volume.FreeSpace ) + ' free )'
                       )

            } # end foreach vol

        } # end foreach part

    write $('       ' + $ID )

        write ''
        
    } # end foreach disk

}

#--------------------------------------------------------------------
function Get-HRSize {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$True, ValueFromPipeline=$True)]
        [INT64] $bytes
    )
    process {
        if     ( $bytes -gt 1pb ) { "{0:N2} PB" -f ($bytes / 1pb) }
        elseif ( $bytes -gt 1tb ) { "{0:N2} TB" -f ($bytes / 1tb) }
        elseif ( $bytes -gt 1gb ) { "{0:N2} GB" -f ($bytes / 1gb) }
        elseif ( $bytes -gt 1mb ) { "{0:N2} MB" -f ($bytes / 1mb) }
        elseif ( $bytes -gt 1kb ) { "{0:N2} KB" -f ($bytes / 1kb) }
        else   { "{0:N} Bytes" -f $bytes }
    }
} # End Function:Get-HRSize

Main | Out-File .\diskwwn.txt


$data = Get-Content -Path  .\diskwwn.txt

$text = ($data) -join "`r`n"
($text | Select-String '(?s)(?<=\Disk )(.+?)(?=\})' -AllMatches).Matches | % {
        $text = $text.Replace($_.Value, ($_.Value -split "`r`n" | % { $_.Trim() }) -join " ")
          
        
}


        
        
        
        
$textfinder1 = "- SCSI"
$textfinder2 = " - "
$textfinder3 = "(?s)(?<=\$textfinder1)(.+?)(?=$textfinder2)"
$textfinder4 = "Partition"
$textfinder5 = "@{uniqueid="
$textfinder6 = "(?s)(?<=$textfinder4)(.+?)(?=$textfinder5)"



$text1 = ($text)  | foreach-Object {
  $_ -replace "$textfinder3", '' `
     -replace "," ,'' `
     -replace "$textfinder6", '' `
     -replace "- SCSI - ", ',' `
     -replace "Partition@{uniqueid=", ',' `
     -replace "", "" `
     -replace "}", '' `
     
     } 
     
#foreach ($line in $text1)

 
[array]$header = "Disk_Number,Size,PWWN"

$Arrrayofdisks = $header + $text1

$Servername = $env:computername

$whodidthat = $env:UserName

$thepath = (".\disk_numbers_pwwn_" + "$Servername" + "_" + "$whodidthat" + ".csv")

$Arrrayofdisks | Out-File (".\disk_numbers_pwwn_" + "$Servername" + "_" + "$whodidthat" + ".txt")

[array]$CSCcontent = gc (".\disk_numbers_pwwn_" + "$Servername" + "_" + "$whodidthat" + ".txt") | ? {$_.trim() -ne "" }

$finalmout=@()

$var4=($CSCcontent -replace "Disk","`r`nDisk").split("`r`n")
$var3=($text -replace "Disk","`r`nDisk").split("`r`n")

$diskseq=@()

foreach($v2 in $var3)
{
if($v2 -ne ""){
$disknumber=$v2.split("-")[0]
$diskletter=$v2.split(" ") -match "[A-Z]:"
$diskseq +="$disknumber,$diskletter"
}
}

foreach($v4 in $var4)
{
foreach($ds in $diskseq)
{
$temp=$ds.split(",")[0]
if($v4 -match $temp)
{
$finalmout += $v4 -replace "$temp","$ds"
}
}
}
if($finalmout)
{
write-host "Details for" $Servername
#write-host "Disk_Number,DriveLetter,Size,PWWN"

$finalmout
}
else
{
write-host "No details found"
}






Remove-Item (".\disk_numbers_pwwn_" + "$Servername" + "_" + "$whodidthat" + ".txt") }


("Get Disk Details"){ 
[array]$mdisk=gwmi win32_logicaldisk
$diskcount='0'
foreach($MID in $mdisk)
{
$col=$col+1
$dtype=$NUll
$fper=$Null
$dfree=$NUll
$dtype=$MID.DriveType
if(($dtype -ne '0') -and ($dtype -ne '2')-and ($dtype -ne '6') -and ($dtype -ne '5')){
$diskcount=$diskcount+1
$tid=$MID.DeviceID
$dfree='{0:P0}' -f (( $MID.FreeSpace/1gb)/($MID.Size/1gb))
$dsize=($MID.Size/1gb)
$dtype=$MID.DriveType
if($dtype -eq '3'){ $dtype = 'Local Disk'}
if($dtype -eq '4'){ $dtype = 'Network Drive'}
$fper= $tid +' with diskspace '+[math]::round($dsize)  +' GB and free space '+$dfree +' which is '+ $dtype
$fper
}
}



}

("Get scheduled tasks"){$a=@()
$b=@()
$a=Get-ScheduledTask | Get-ScheduledTaskInfo| select TaskName,LastTaskResult,LastRunTime,NextRunTime 

$b=Get-ScheduledTask | select TaskName,State,Author,Triggers,Actions


$i = 0
$b | ForEach-Object { 
    Add-Member -inputobject $a[$i] -name State -value $_.State -membertype NoteProperty;
    Add-Member -inputobject $a[$i] -name Author -value $_.Author -membertype NoteProperty; 
    $i++}
$a | ft -wrap
}

("Get user sessions") {qwinsta}

("Top 10 services"){$ram=(gwmi Win32_PhysicalMemory | Measure-Object -Property capacity -Sum).sum /1gb
write-host ""
write-host "----------------------Top process based on pagefile-------------------------"
write-host ""
$parentv= gwmi win32_process
$pfile=(gwmi win32_process | select-object Name,Path,PageFileUsage | Sort-Object -Property PageFileUsage -Descending)[0..9]
foreach($pf in $pfile)
{
$aname=$pf.Name
$apath=$pf.Path
$ausage=$pf.PageFileUsage
write-host "Name: $aname ,usage: $ausage, Path: $apath"
}
write-host ""
write-host "----------------------Top process based on Memory-------------------------"
write-host ""
$mfile=($parentv | Sort-Object -Property WS -Descending)[0..9]
foreach($mf in $mfile)
{
$bname=$mf.Name
$bpath=$mf.Path
$busage=([math]::Round(($_.WS/1Mb)/$ram*100,2))
write-host "Name: $bname , usage: $busage %,Path: $bpath, "
}
write-host ""

write-host ""
write-host "----------------------Top process based on CPU usage---------------------"
write-host ""
$cores = (Get-WmiObject Win32_ComputerSystem).NumberOfLogicalProcessors
$cpuvalues=Get-WmiObject Win32_PerfFormattedData_PerfProc_Process | select-object -property Name,PercentProcessorTime,IDProcess | Sort-Object -Property PercentProcessorTime -Descending| Select-Object -First 10
$finalvalues=@()
foreach($cvalue in $cpuvalues)
{
 if($cvalue.Name -notmatch "^(idle|_total|system)$")
 {
    if($cvalue.PercentProcessorTime -ne 0)
    {
        $name=$cvalue.Name
        $usage=$cvalue.PercentProcessorTime/$cores
        $id=$cvalue.IDProcess
        $finalvalues+="Name: $name, usage: $usage %,PID: $id "
    }
    else
    {
        $name=$cvalue.Name
        $usage=$cvalue.PercentProcessorTime
        $id=$cvalue.IDProcess
        $finalvalues+="Name: $name, usage: $usage %,PID: $id "
    }
    $cvalue=$Null
    }
}
$finalvalues 
}

("Create Perfmon Dump"){$stamp=get-date
 $nlist=@()
 $CtrList = @("\Cache\*",
"\LogicalDisk(*)\*",
"\Memory\*",
"\Network Interface(*)\*",
"\Paging File(*)\*",
"\PhysicalDisk(*)\*",
"\Processor(*)\*",
"\Process(*)\*",
"\Redirector\*",
"\Server\*",
"\Server Work Queues\*",
"\System\*"
)
get-date
foreach($ctrl in $CtrList)
{
$fs=($ctrl -replace ' ','z')
$sfs=$fs -Replace '[\W]',''
$mfs=$sfs -replace 'z',' '
if(get-Counter -ListSet "$mfs" -ErrorAction SilentlyContinue)
{
[array]$nlist += $ctrl
}
else
{
$invalids += $mfs
}
}

$stamp=get-date
$string="perfmondump_$stamp"
$string=(($string.Replace(" ","_")).Replace("/","_")).replace(":","_")
$outdump="C:\Temp\$string.blg"

Get-Counter -Counter $nlist -SampleInterval 60 -MaxSamples 10 -ErrorAction SilentlyContinue | export-counter -path $outdump -FileFormat BLG -Force


write-host "dump file is $outdump"


}

("User Profile healthcheck"){
$muserprofiles=(get-childitem "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList").Name
foreach($mprofiles in $muserprofiles)
{
$nprofile=$mprofiles.replace("HKEY_LOCAL_MACHINE","HKLM:")
$fstring=(get-itemproperty "$nprofile").ProfileImagePath
if($nprofile -like "*.bak")
{
$LW=(get-item $fstring -ErrorAction SilentlyContinue).LastWriteTime
if($LW)
{
write-host "$nprofile - $fstring - $LW - corrupted"
}
else
{
write-host "$nprofile - $fstring - Folder missing "
}
}
else
{
$LW=(get-item $fstring -ErrorAction SilentlyContinue).LastWriteTime
if($LW)
{
write-host "$fstring - $LW - Healthy"
}
else
{
write-host "$nprofile - $fstring - Folder missing "
}
}
}

}

("Get installed Softwares"){$mmuserprofiles=get-itemproperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*"
foreach($mmprofiles in $mmuserprofiles)
{
if($mmprofiles.DisplayName -notlike "")
{
write-host "Software: "$mmprofiles.DisplayName "Version: "$mmprofiles.DisplayVersion
}
else
{
write-host " "
write-host "######################################################"
write-host "$mmprofiles Doesn’t have enough information in registry"
write-host "######################################################"
write-host " "
}
}}

("Get Event logs"){write-host "###########################################SYSTEM LOGS############################################"
Get-EventLog -LogName System -Newest 100 -EntryType Error | Sort-Object -Property TimeGenerated -Descending | format-table -Property EventID,Source,TimeGenerated,Message -Wrap
write-host "###########################################APPLICATION LOGS#######################################"
Get-EventLog -LogName Application -Newest 100 -EntryType Error | Sort-Object -Property TimeGenerated -Descending | format-table -Property EventID,Source,TimeGenerated,Message -Wrap
}
("Get Windows Updates installed"){get-hotfix | Sort-Object InstalledOn -Descending}

("Get Powershell Version"){$PSVersionTable.PSVersion}

("Get NIC info"){
	$ct=gwmi win32_networkadapterConfiguration | where {$_.IPAddress -like "*.*.*.*"} | select IPAddress,IPSubnet,DefaultIPGateway,MACAddress,DNSDomain,DNSServerSearchOrder,Description

$final=@()

foreach($cts in $ct)
{

$check=gwmi win32_networkadapter | where {$_.MACAddress -eq $cts.MACAddress} | select Speed,NetConnectionID
Add-Member -InputObject $cts -Name Speed -Value $check.Speed -membertype NoteProperty
Add-Member -InputObject $cts -Name AdapName -Value $check.NetConnectionID -membertype NoteProperty
$mid=$check.NetConnectionID
$final += " "
$final += "-------------------------$mid---------------------------"
$final += $cts
$final += "---------------------------------------------------------"
$final += " "
}

$final
 }

("Get UPtime"){$var=gwmi win32_operatingsystem
((get-date)-($var.ConvertToDateTime($var.LastBootUpTime))) | select TotalDays,TotalHours,TotalMinutes}

("Get Disk I\O"){(gwmi Win32_PerfFormattedData_PerfProc_Process | sort IOReadBytesPersec -des | select  Name,IOReadBytesPersec,IOWriteBytesPersec | ft -AutoSize)[0..9]}

("Netstat"){netstat -ano}

("Netstat and process"){
	
clear-content c:\temp\pid1.txt
netstat -a -n -o > c:\temp\pid1.txt
$final=@()
$lines=get-content c:\temp\pid1.txt

foreach($line in $lines)
{

$final+=get-process | where {$_.Id -eq $line.split(" ")[-1]} | Select ProcessName,Id

}

$final	
	
	
	}

("Get Network Bandwidth Utilization"){$startTime = get-date
$endTime = $startTime.addMinutes(0.5)
$timeSpan = new-timespan $startTime $endTime

$count = 0
$totalBandwidth = 0

while ($timeSpan -gt 0)
{
   # Get an object for the network interfaces, excluding any that are currently disabled.
   $colInterfaces = Get-WmiObject -class Win32_PerfFormattedData_Tcpip_NetworkInterface |select BytesTotalPersec, CurrentBandwidth,PacketsPersec|where {$_.PacketsPersec -gt 0}

   foreach ($interface in $colInterfaces) {
      $bitsPerSec = $interface.BytesTotalPersec * 8
      $totalBits = $interface.CurrentBandwidth

      # Exclude Nulls (any WMI failures)
      if ($totalBits -gt 0) {
         $result = (( $bitsPerSec / $totalBits) * 100)
         Write-Host "Bandwidth utilized:`t $result %"
         $totalBandwidth = $totalBandwidth + $result
         $count++
      }
   }
   Start-Sleep -milliseconds 100

   # recalculate the remaining time
   $timeSpan = new-timespan $(Get-Date) $endTime
}

"Measurements:`t`t $count"

$averageBandwidth = $totalBandwidth / $count
$value = "{0:N2}" -f $averageBandwidth
Write-Host "Average Bandwidth utilized:`t $value %"
}

("Get PSDrive(Lists all available drives)"){Get-PSDrive -PSProvider FileSystem | ft -Wrap }
	
("Get Stopped Services"){Get-Service | where {($_.StartType -eq "Automatic") -and ($_.Status -eq "Stopped")}}
("Get .Net Version"){
$out=Get-ChildItem 'HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP' -Recurse |
  Get-ItemProperty -name Version, Release -EA 0 |
  Where-Object { $_.PSChildName -match '^(?![SW])\p{L}'} |
  Select-Object @{name = ".NET Framework"; expression = {$_.PSChildName}}, 
@{name = "Product"; expression = {$Lookup[$_.Release]}}, 
Version, Release
$out | ft

Write-host " "
Write-host "++++++++++++++++++++++++++++++"
Write-host "Below is the .Net version"
Write-host "++++++++++++++++++++++++++++++"
Write-host " "

$out | where {$_.".NET Framework" -eq "Full"} | ft
	}
("Get Binding Order"){
	Function Get-BindOrder
{
  $Binding = (Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Linkage").Bind
  $Return = New-Object PSobject
  $BindingOrder = @()
 ForEach ($Bind in $Binding)
 {
  $DeviceId = $Bind.Split("\")[2]
  $Adapter = (Get-WmiObject Win32_Networkadapter | Where {$_.GUID -eq $DeviceId }).NetConnectionId
  $BindingOrder += $Adapter
 }
  $Env:ComputerName
  $BindingOrder
}#EndFunction
CLS
Get-BindOrder
	
	}

("Get Host file entries"){
$final=@()
$files=(get-childitem -Path 'c:\windows\system32\drivers\etc\' | where-object {$_.Name -eq "hosts"}).Name
if($files -eq "hosts")
{
$count= 0

$hostfile= get-content "c:\windows\system32\drivers\etc\$files"

Foreach($lines in $hostfile)
{
if (($lines -notlike "#*********") -and ($lines -like "*.*.*.*"))
{
$count=$count+1
$final += "$lines | "
}
}
if ($count -gt "0")
{
write-host "Host:$env:COMPUTERNAME have $count Host entries available and they are as follows"
write-host " "
$final.split('|')

}
else
{write-host "Host entries not available"
}
}
else
{
write-host "file not available"

}


}



}

} -ArgumentList ($UTIL,$LOGMAN) -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)


################


##################VMWARE UTILITIES################



	if(!(Get-Module -Name VMware.VimAutomation.Core))
	{
    	Import-Module -Name VMware.VimAutomation.Core

    	if(!$?){ throw "Could not load VMware.VimAutomation.Core" }
    }

    #Declarations

	[ValidateNotNullOrEmpty()]
	$USER_PASSWORD                 =   ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force

	[ValidateNotNullOrEmpty()]
	[string]$USERNAME              =  '$INPUT{USERNAME}'

	[ValidateNotNullOrEmpty()]
    [string] $vCenterServer        =  '$INPUT{VCENTERSERVER}'
    
	[ValidateNotNullOrEmpty()]
    [string]$paramMenuOption          =  '$INPUT{VMENU}'
    
    [ValidateNotNullOrEmpty()]
    [string]$paramOpt              =  '$INPUT{CIOPTIONS}'
    
    [ValidateNotNullOrEmpty()]
    [string]$paramComponent        =  '$INPUT{Components}'
    
    
    
    if($paramMenuOption -like "*,*")
    {
		[array]$paramMenuOption=$paramMenuOption.split(",")
    }
    
    
    if ($vCenterServer -eq 'vc1' -or $vCenterServer -eq 'vc2' -or $vCenterServer -eq 'vc3' )
	{
		Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false | Out-Null
	}
    
    
    #Credentials
    $CREDENTIALS             = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
    $Connect                 = Connect-VIServer  -Server $vCenterServer  -Credential $CREDENTIALS   -ErrorAction SilentlyContinue 

    #Check the Connectivity
     if ($connect)
        {
             # $OutConnect   = "Connected to vCenter Server :  $($connect.name)"
              Write-Output $OutConnect
      
        
    
    #Functions Definations
    
    function Get-VMDetails($VMName){
	$vmReport = @()
	 Get-VM -name $VMName | Sort Name -Descending | ForEach-Object {
	     $vm = Get-View $_.ID 
	     $procs= @{ VMName = $vm.Name 
	                Hostname = $vm.guest.hostname 
	                IPAddress = $vm.guest.ipAddress 
	                OS = $vm.Config.GuestFullName 
	                Boottime = $vm.Runtime.BootTime 
	                VMState = $vm.summary.runtime.powerState 
	                TotalCPU = $vm.summary.config.numcpu 
	                CPUAffinity = $vm.Config.CpuAffinity 
	                CPUHotAdd = $vm.Config.CpuHotAddEnabled 
	                CPUShare = $vm.Config.CpuAllocation.Shares.Level 
	                TotalMemory = $vm.summary.config.memorysizemb 
	                MemoryHotAdd = $vm.Config.MemoryHotAddEnabled 
	                MemoryShare = $vm.Config.MemoryAllocation.Shares.Level 
	                TotalNics = $vm.summary.config.numEthernetCards 
	                OverallCpuUsage = $vm.summary.quickStats.OverallCpuUsage 
	                MemoryUsage = $vm.summary.quickStats.guestMemoryUsage 
	                ToolsStatus = $vm.guest.toolsstatus 
	                ToolsVersion = $vm.config.tools.toolsversion 
	                TimeSync = $vm.Config.Tools.SyncTimeWithHost 
	                HardwareVersion = $vm.config.Version 
	                MemoryLimit = $vm.resourceconfig.memoryallocation.limit 
	                MemoryReservation = $vm.resourceconfig.memoryallocation.reservation 
	                CPUreservation = $vm.resourceconfig.cpuallocation.reservation 
	                CPUlimit = $vm.resourceconfig.cpuallocation.limit 
	                CBT = $vm.Config.ChangeTrackingEnabled 
	                Swapped = $vm.Summary.QuickStats.SwappedMemory 
	                Ballooned = $vm.Summary.QuickStats.BalloonedMemory 
	                Compressed = $vm.Summary.QuickStats.CompressedMemory 
	            }
	        $vms = [pscustomobject]$procs    
	        $vmReport += $vms 
	    }
	    Return $vmReport
	
	}
	
	function Get-Version (){
		   $info = $global:DefaultVIServers | Select Name,Version
		   $version= $info.version
		   return $version
    }
    
	function Get-VIServices ($viserver, $CREDENTIALS ){
	try{	
	   If ($viserver){
	      $Services = get-wmiobject win32_service -Credential $credential -ComputerName $viserver -ea Stop| Where {$_.DisplayName -like "VMware*" }
	   } Else {
	      $Services = get-wmiobject win32_service -ComputerName $viserver -ea stop| Where {$_.DisplayName -like "VMware*" }
	   }
	}
	catch{
		Write-host "Unable to reach the vcenter Server"
		}
	 
	   $myCol = @()
	   Foreach ($service in $Services){
	      If ($service.StartMode -eq "Auto") {
	         if ($service.State -eq "Stopped") {
	            $MyDetails = New-Object -TypeName PSObject -Property @{
	               Name = $service.Displayname
	               State = $service.State
	               StartMode = $service.StartMode
	               Health = "Unexpected State"
	            }
	         }
	      }
	 
	      If ($service.StartMode -eq "Auto") {
	         if ($service.State -eq "Running") {
	            $MyDetails = New-Object -TypeName PSObject -Property @{
	               Name = $service.Displayname
	               State = $service.State
	               StartMode = $service.StartMode
	               Health = "OK"
	            }
	         }
	      }
	      If ($service.StartMode -eq "Disabled"){
	         If ($service.State -eq "Running"){
	            $MyDetails = New-Object -TypeName PSObject -Property @{
	               Name = $service.Displayname
	               State = $service.State
	               StartMode = $service.StartMode
	               Health = "Unexpected State"
	            }
	         }
	      }
	      If ($service.StartMode -eq "Disabled"){
	         if ($service.State -eq "Stopped"){
	            $MyDetails = New-Object -TypeName PSObject -Property @{
	               Name = $service.Displayname
	               State = $service.State
	               StartMode = $service.StartMode
	               Health = "OK"
	            }
	         }
	      }
	      $myCol += $MyDetails
	   }
	   
	   
	   Write-output $myCol
	}
    
    function Get-VcenterCounts() {
	    try{
		    $Clusters= Get-VmHost -ea Stop |measure-object
		    $DataCenters= Get-Datacenter -ea stop |measure-object
		    $Hosts=Get-vmHost -ea Stop |measure-object
		    $VMs= Get-VM -ea Stop|measure-object
		    $results= @()
		    $Results += "Virtual Centers Items Count"
		    $Results += New-Object -TypeName PSObject -Property @{
						               Cluster = $ClusterCount.count
						               DataCenters= $DataCenterCount.count
						               Hosts = $HostCount.count
						               VMs = $VMs.count
		               }
	    }
	    catch{
	    	$error[0].exception.message
	    	}
	    Return $results
    }
    
 
    
    if ($paramComponent -eq "guest_name" )	{
    	$vmdetail = Get-VMDetails -VMName $paramOpt

    }
    
    Try{
    	
    
    
    switch( $paramMenuOption ){
#vm
		101 { 
				(Get-VM -name $paramOpt).VMHost
			
			}
		102 { 
			Write-Output  "Guest IP address"
			"--------------------------------------------------------"
			Write-Output "Guest IP address : $($vmdetail.IPAddress)"
			}
		103 { 
			 Write-Output "Boot Time"
			 "--------------------------------------------------------"
			 Write-Output "Boot Time  : $($vmdetail.BootTime )"
			
			}
		104 { 
			Write-Output "Power State"
			"--------------------------------------------------------"
			Write-Output "VM Power State  : $($vmdetail.VMState)"
			
			}
		105 {
			Write-Output  "CPU Status  (NumCPU)"
			"--------------------------------------------------------"
			Write-Output "Total CPU : $($vmdetail.TotalCPU)"
			}
		106 {
			Write-Output  "CPU Affinity"
			"--------------------------------------------------------"
			Write-Output "Total CPU Affinity  : $($vmdetail.CpuAffinity )"
				
			}
		107	{ 
			Write-Output  "CPU Hot Plug"
			"--------------------------------------------------------"
			Write-Output "CPU HotPlug   : $($vmdetail.CPUHotAdd  )"
			}
		108 { 
			Write-Output  "CPU Share Level"
			"--------------------------------------------------------"
			 Write-Output "CPU Share  Level   : $($vmdetail.CPUShare  )"
			}
		109 { 
			Write-Output  "Guest Memory Usage"
			"--------------------------------------------------------"
			Write-Output "Guest Memory Usage   : $($vmdetail.MemoryUsage  )"
			}
		110	{ 
				Write-Output  "Ethernet Cards"
				"--------------------------------------------------------"
				Write-Output "Ethernet Adapters   : $($vmdetail.TotalNics  )"
			}
		111	{
			Write-Output  "Tools Status"
			"--------------------------------------------------------"
			Write-Output "Tools Status   : $($vmdetail.ToolsStatus   )"
			}
		112	{ 
			Write-Output  "Tools Version"
			"--------------------------------------------------------"
			Write-Output "Tools Version   : $($vmdetail.ToolsVersion   )"
			}
		113	{
			Write-Output  "Hardware Version"
			"--------------------------------------------------------"
			Write-Output "Hardware Version   : $($vmdetail.HardwareVersion   )"
			}
		114	{ 
			Write-Output  "Time Sync"
			"--------------------------------------------------------"
			Write-Output "Time Sync   : $($vmdetail.TimeSync)"
			}
		115	{ 
			Write-Output  "Memory Limit"
			"--------------------------------------------------------"
			Write-Output "Memory Limit   : $($vmdetail.MemoryLimit)"
			}
		116	{
			Write-Output  "Memory Reservation"
			"--------------------------------------------------------"
			Write-Output "Memory Reservation : $($vmdetail.MemoryReservation)"
			}
		117	{ 
			Write-Output  "CPU Limit"
			"--------------------------------------------------------"
			Write-Output "CPU limit : $($vmdetail.CPUlimit)"
			
			}
		118	{ 
			Write-Output  "CPU Reservation"
			"--------------------------------------------------------"
			Write-Output "CPU Reservation : $($vmdetail.CPUreservation)"
			}
		119 {
			Write-Output  "Change Tracking"
			"--------------------------------------------------------"
			Write-Output "Change Tracking : $($vmdetail.CBT)"
			}
		120	{ 
			Write-Output  "Swapped Memory"
			"--------------------------------------------------------"
			Write-Output "Swapped Memory : $($vmdetail.Swapped)"
			}
		121	{ 
			Write-Output  "Balooned Memory"
			"--------------------------------------------------------"
			Write-Output  "Balooned Memory : $($vmdetail.Ballooned)"
			}
		122 {
			Write-Output  "Compressed Memory"
			"--------------------------------------------------------"
			 Write-Output "Compressed Memory : $($vmdetail.Compressed)"
			}
		

#Vcenter

		201 { 
            Write-Output "Get Host List"
            $hostsname=  get-vmhost 
            if($hostsname){      
 
                #Total Hosts
                Write-Output "`n                                     Host(s) Summary                         "
                [int]$totalVmHosts = ($hostsname).count
                $outVMList= $hostsname | Select-Object Name,ConnectionState, PowerState, NumCpu, CpuUsageMhz, CpuTotalMhz, 
                @{n='MemoryUsageGB'; e={'{0:N2}' -f ($psitem.MemoryUsageGB)}},
                @{n='MemoryTotalGB'; e={'{0:N2}' -f ($psitem.MemoryTotalGB)} } | Format-Table -Wrap
                $outVMList | Format-Table -AutoSize -Wrap 
                #Maintenance Mode
                Write-Output "`n                               Host(s) in Maintenance Mode                         `n"
                $MaintenanceMode = $hostsname | Where-Object {$PSItem.ConnectionState -eq "Maintenance"}
                $MaintenanceMode  | Select-Object Name, ConnectionState, PowerState |  Format-Table -Wrap
                Write-Output "`n "
 
                #Host Disconnected
                
                Write-Output "`n                                    Host(s) Disconnected                         `n"
                $Disconnected =    $hostsname | Where-Object {($_.ConnectionState -ne "Connected") -and ($_.ConnectionState -ne "Maintenance") } | Select-Object Name, Model
                $Disconnected | Select-Object Name, Model | Format-Table -AutoSize -Wrap
                #count
                [int]$countNConnected= ($Disconnected).count
                [int]$countMM      = ($MaintenanceMode).count            
                Write-Output       "Total Hosts                 = $totalVmHosts"
                if ($totalVmHosts -ne 0){
                Write-Output       "Hosts Under Maintenance    = $countMM "
                }
                if ($countNConnected -ne 0){
                Write-Output       "Hosts in Disconnected Mode = $countNConnected "
                }
                
            }
        else
        {
            Write-Output "No Host(s) found" 
        }
      }
	    202 {  
	            Write-output "VM List - Summary `n"
	            #$varVMs = get-vm | select Name, PowerState, numcpu, memorygb 
	            $varVMs = Get-View -ViewType VirtualMachine | Select Name,@{N='PowerState';E={$_.Runtime.ConnectionState}},@{N="TotalCPUs";E={$_.summary.config.numcpu}},@{N="MemoryinMB";E={$_.summary.config.memorysizemb }}
	            if($varVMs){
	            	[int]$totalVmss = ($varVMs).count
	            	Write-output "`n"
	            	Write-Output $varVMs
	            	Write-Output "`n`nVM Guests  = $totalVmss"
	            	}
	            else{
	            	Write-output "No Virtual Machines found"	
	            	}
	     }
		203 {
				Write-Output "Plugin Report"
				$varPlugins = Get-View ExtensionManager |Select -ExpandProperty ExtensionList | select @{N='Name';E={$_.Description.Label}},Version,Company
				if($varPlugins){
					$varPlugins | Format-Table -Wrap -AutoSize
					}
				else {
					Write-Output "No information is available for this vCenter"
					}
		}		
		204 {	
				Write-Output "License Manager"
				$LicenseManager= Get-view LicenseManager
				$LicenseManager.Licenses | Format-Table Name, EditionKey, @{Name = "Total Licences"; e= {$PSItem.Total};a="right"},@{Name= "Used Licences"; e= {$psitem.Used};a="right"}, @{Name= "Cost Unit"; e= {$psitem.CostUnit};a="right"}, CostUnit -Wrap -ErrorAction Stop
			}
		205 {
			Write-Output "Users and Permission"
			Get-ViPermission -Server $vCenterServer | ft -Wrap -AutoSize
			
			}
		206 {
			Write-Output "Version Info"
			$server= $paramOpt
			Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false
			#	Connect-VIServer -server $server



			$version= Get-Version
			write-output "The current version of vcenter running on $server is $version"
			#$info.version
			#disconnect-viserver $paramOpt -force
			}
		207 {
			
			Write-host "vCenter Services"
            #[string]$viserver = $paramOp
            try{
            	Write-Host "Vcenter Server is  =  $($paramOpt)"
				Get-VIservices -viserver $paramOpt -credential $CREDENTIALS  -ea Stop
            }
            catch{
            	Write-Host "vCenter is not Reachable"
            	}
			
			}
		208 {
			Try{
				Write-host "vCenter Stats"
				$server= Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -Confirm:$false -erroraction Stop
				Get-VcenterCounts -ea stop
			}
			catch{
				 $error[0].exception.message
				}
			
			}
		
		
#Cluster		
		401 {
            $cluview=get-cluster | Where-Object {$_.Name -eq $paramOpt } | get-view    
            $clustername=$cluview.Name
            write-host ""
            Write-host "                                     Current Resource utilization of Cluster $clustername                       "
            write-host ""
            $cluview.GetResourceUsage() | select CpuUsedMHz,CpuCapacityMHz,`
            @{"Label"="CPUUsed(%)";"Expression"={"{0:N2}" -f (($_.CpuUsedMHz/$_.CpuCapacityMHz)*100)}},MemUsedMB,MemCapacityMB,`
            @{"Label"="MEMUsed(%)";"Expression"={"{0:N2}" -f (($_.MemUsedMB/$_.MemCapacityMB)*100)}},StorageUsedMB,StorageCapacityMB,`
            @{"Label"="StorageUsed(%)";"Expression"={"{0:N2}" -f (($_.StorageUsedMB/$_.StorageCapacityMB)*100)}} | ft -AutoSize
            write-host ""
            Write-host "                                      Current Resource Summary of Cluster $clustername                       "
            write-host ""
            $cluview.Summary | select NumVmotions,NumCpuCores,NumCpuThreads,EffectiveCpu,EffectiveMemory,NumHosts,TotalCpu,`
             @{"Label"="TotalMemoryGB";"Expression"={"{0:N2}" -f ($_.TotalMemory/1GB) -as [float]}} | ft -Wrap
            
        } 
		402 {
			    $clu=get-cluster | Where-Object {$_.Name -eq $paramOpt }
			    $clustername=$clu.Name
			    write-host ""
			    Write-host "                                     Vmotion events for last 10 days in $clustername                       "
			    write-host ""
			    $disevents=get-cluster | 
			    Where-Object {$_.Name -eq $clustername} | 
			    get-vmhost | Get-VM | 
			    Get-VIEvent -Types Info,Error,Warning -Start (get-date).AddDays(-10) | 
			    Where-Object {$_.FullFormattedMessage -like "Migrat*"} | 
			    Select-Object CreatedTime,FullFormattedMessage | 
			    Sort-Object -Property CreatedTime -Descending | Format-Table -wrap -ea Stop
			    if($disevents)
			    {
			    	$disevents
			    }
			    else
			    {
			       	write-host "                                     NO Vmotion events found for cluster $clustername                                                                                         "
			    }
		}
		403 {
			$clu=get-cluster | Where-Object {$_.Name -eq $paramOpt }
			$clustername=$clu.Name
			write-host ""
			Write-host "                                  Host Disconnected events for last 10 days in $clustername                       "
			write-host ""
			$disevents=get-cluster | Where-Object {$_.Name -eq $clustername} | 
			            get-vmhost | Get-VIEvent -Types Info,Error,Warning -Start (get-date).AddDays(-10) | 
			            Where-Object {$_.FullFormattedMessage -like "Disconnect*"} | 
			            Select-Object CreatedTime,FullFormattedMessage | Format-Table -Wrap
			if($disevents)
			    {
			     $disevents
			    }
			else
			    {
			     write-host "                                   NO Disconnected events found for cluster $clustername                                                                                         "
			    }
			}
		404 {
			try{
			    $cluview=get-cluster -ea Stop | Where-Object {$_.Name -eq $paramOpt } | get-view
			    $clustername=$cluview.Name
			    write-host ""
			    Write-host "`n`n                                      DRS Status for Cluster $clustername                       "
			    write-host ""
			    $drsstatus=$cluview.Configuration.DrsConfig | Format-Table -AutoSize
			    if($drsstatus)
			    {
			        $drsstatus
			    }
			    else
			    {
			        write-host "                              DRS data not available for cluster $clustername                                 "
			    }
			}
			catch{
					 $error[0].exception.message
				}
		}
		405 {
			try{
					$cluview=get-cluster -ea Stop | Where-Object {$_.Name -eq $paramOpt } | get-view
					$clustername=$cluview.Name
					$HAinfo=get-cluster | Where-Object {$_.Name -eq $clustername} |
					Select-Object Name,HAAdmissionControlEnabled,
					    @{N='Host failures cluster tolerates';E={$_.ExtensionData.Configuration.DasConfig.AdmissionControlPolicy.FailOverLevel}},
					    @{N='Define host failover capacity by';E={
					        switch($_.ExtensionData.Configuration.DasConfig.AdmissionControlPolicy.GetTYpe().Name){
					        'ClusterFailoverHostAdmissionControlPolicy' {'Dedicated Failover Hosts (H)'}
					        'ClusterFailoverResourcesAdmissionControlPolicy' {'Cluster Resource Percentage (R)'}
					        'ClusterFailoverLevelAdmissionControlPolicy' {'Slot Policy (s)'}
					        }}},
					    @{N='(H) Failover Hosts ';E={(Get-View -Id $_.ExtensionData.Configuration.DasConfig.AdmissionControlPolicy.FailOverHosts -Property Name).Name -join '|'}},
					    @{N='(R) Override calculated failover capacity';E={
					        if($_.ExtensionData.Configuration.DasConfig.AdmissionControlPolicy.AutoComputePercentages){'True'}
					        else{'False (R-O)'}}},
					    @{N='(R-O) CPU %';E={$_.ExtensionData.Configuration.DasConfig.AdmissionControlPolicy.CpuFailoverResourcesPercent}},
					    @{N='(R-O) Memory %';E={$_.ExtensionData.Configuration.DasConfig.AdmissionControlPolicy.MemoryFailoverResourcesPercent}},
					    @{N='(S) Slot Policy ';E={
					        if($_.ExtensionData.Configuration.DasConfig.AdmissionControlPolicy.SlotPolicy){'Fixed Slot Size (S-F)'}
					        else{'Cover all powered-on VM'}
					    }},
					    @{N='(S-F) CPU MhZ';E={$_.ExtensionData.Configuration.DasConfig.AdmissionControlPolicy.SlotPolicy.Cpu}},
					    @{N='(S-F) Memory MB';E={$_.ExtensionData.Configuration.DasConfig.AdmissionControlPolicy.SlotPolicy.Memory}},
					    @{N='HA Admission Policy ResourceReductionToToleratePercent';E={$_.ExtensionData.Configuration.DasConfig.AdmissionControlPolicy.ResourceReductionToToleratePercent}},
					    @{N='Hearthbeat Datastore Policy';E={
					        switch($_.ExtensionData.Configuration.DasConfig.HBDatastoreCandidatePolicy){
					        'allFeasibleDs' {'Automatically Select-Object datastores accessible from the host'}
					        'allFeasibleDsWithUserPreference' {'Use datastores from the specified list and complement automatically (L)'}
					        'userSelect-ObjectedDs' {'Use datastores only from the specified list (L)'}
					        }
					    }},
					    @{N='(L) Hearthbeat Datastore';E={(Get-View -Id $_.ExtensionData.Configuration.DasConfig.HeartbeatDatastore -property Name).Name -join '|'}},
					    @{N='Host Monitoring';E={$_.ExtensionData.Configuration.DasConfig.HostMonitoring}},
					    @{N='Host Failure Response';E={
					        if($_.ExtensionData.Configuration.DasConfig.DefaultVmSettings.RestartPriority -eq 'disabled'){'Disabled'}
					        else{'Restart VMs'}}},
					    @{N='Host Isolation Response';E={$_.ExtensionData.Configuration.DasConfig.DefaultVmSettings.IsolationResponse}},
					    @{N='Datastore with PDL';E={$_.ExtensionData.Configuration.DasConfig.DefaultVmSettings.VmComponentProtectionSettings.VmStorageProtectionForPDL}},
					    @{N='Datastore with APD';E={$_.ExtensionData.Configuration.DasConfig.DefaultVmSettings.VmComponentProtectionSettings.VmStorageProtectionForAPD}},
					    @{N='VM Monitoring';E={$_.ExtensionData.Configuration.DasConfig.VmMonitoring}}
					    write-host ""
					    Write-host "                                       HA Status for Cluster $clustername                       "
					    write-host ""
					    if($HAinfo)
					    {
					        $HAinfo
					    }
					    else
					    {
					        write-host "                                   DRS data not available for cluster $clustername                                                                                         "
					    }
			}
			catch{
				 $error[0].exception.message
		}
}
		406 {
			try{
			    $cluview=get-cluster -ea stop| Where-Object {$_.Name -eq $paramOpt }
			    $clustername=$cluview.Name
			    write-host ""
			    write-host "                                                 EVC Status for cluster $clustername                      "
			    $EVCout=$cluview.ExtensionData.Summary.CurrentEVCModeKey
			    if($EVCout)
			        {
			        write-host ""
			        write-host "Cluster has been Configured with EVC mode: $EVCout"
			        write-host ""
			        $hostevc=$cluview | get-vmhost -ea stop | Select-Object Name,MaxEVCMode,`
			        @{"Label"="ClusterEVC";"Expression"= {if($_.Parent.EVCMode){"NotConfigured"}else{"NotConfigured"}}} | Format-Table -AutoSize
			        if($hostevc)
			        {
			            write-host " "
			            write-host "                                                 EVC Host Status for cluster $clustername                      "
			            $hostevc
			        }
			        else
			            {
			            write-host ""
			            write-host "                                            NO EVC Host Status for cluster $clustername                      "
			            }
			        }
			        else
			        {
			            write-host ""
			            write-host "                                            EVC not configured for cluster $clustername "
			        }
			}
			catch{
				 $error[0].exception.message
				}
		}
		407 {
	        $cluview=get-cluster | Where-Object {$_.Name -eq $paramOpt } | get-view
	        $clustername=$cluview.Name
	        	$clustername=$cluview.Name
			
			write-host ""
			write-host "                                                 DRS Rules on VM                   "
			write-host ""
            
		    $DRSRules = Get-DrsRule -Cluster $clustername -Type VMHostAffinity,VMAffinity,VMAntiAffinity
		    
			ForEach($DRSRule in $DRSRules){
 			write-host ""
 			write-host "Rule Name	: " $DRSRule.Name
 			write-host ""
            write-host "Type 		: " $DRSRule.Type
            write-host ""
            write-host "Enabled 	: " $DRSRule.Enabled
 			write-host ""
 			if($DRSRule.Type -eq "VMHostAffinity")
 			{
 			write-host ""
 			write-host "              Hosts Associated      "
            write-host ""
            if($DRSRule.AffineHostIds)
            {
 			(Get-View -Id $DRSRule.AffineHostIds).Name
            }
            else
            {
            write-host "No Hosts associated"
            }
 			write-host ""
 			}
 			write-host ""
 			write-host "               VMs Associated       "
 			write-host ""
 			if($DRSRule.VMIds)
 			{
            (Get-View -Id $DRSRule.VMIds).Name
 			}
 			else
 			{
 			write-host "No VM associated"
 			}
			}
        }
		408 {
		
			$cluview=get-cluster | where {$_.Name -eq $paramOpt } 
			$clustername=$cluview.Name
			
			write-host ""
			write-host "                                                 DRS Rules on VM                   "
			write-host ""

		    $DRSRules = Get-DrsRule -Cluster $clustername -Type VMHostAffinity,VMAffinity,VMAntiAffinity
			ForEach($DRSRule in $DRSRules){
 			write-host ""
 			write-host "Rule Name	: " $DRSRule.Name
 			write-host ""
            write-host "Type 		: " $DRSRule.Type
            write-host ""
            write-host "Enabled 	: " $DRSRule.Enabled
 			write-host ""
 			if($DRSRule.Type -eq "VMHostAffinity")
 			{
 			write-host ""
 			write-host "              Hosts Associated      "
            write-host ""
            if($DRSRule.AffineHostIds)
            {
 			(Get-View -Id $DRSRule.AffineHostIds).Name
            }
            else
            {
            write-host "No Hosts associated"
            }
 			write-host ""
 			}
 			write-host ""
 			write-host "               VMs Associated       "
 			write-host ""
 			if($DRSRule.VMIds)
 			{
            (Get-View -Id $DRSRule.VMIds).Name
 			}
 			else
 			{
 			write-host "No VM associated"
 			}
            write-host ""
            write-host "##################################################################################################"
            write-host ""
            write-host ""
			}
			
			
			
			write-host ""
			write-host "                                                 SubObjects for cluster $clustername                      "
			write-host ""
			write-host "                                                 Virtual machine of Cluster $clustername                   "
			write-host ""
			
			get-cluster | where {$_.Name -eq $clustername} | get-vm | select Name,PowerState,NumCpu,MemoryGB,Folder,`
			@{"Label"="Guest";"Expression"={($_.ExtensionData.Config.GuestFullName)}},VMHost,`
			@{"Label"="ProvisionedSpaceGB";"Expression"={"{0:N2}" -f ($_.ProvisionedSpaceGB) -as [float]}},`
			@{"Label"="UsedSpaceGB";"Expression"={"{0:N2}" -f ($_.UsedSpaceGB) -as [float]}},`
			@{"Label"="VMversion";"Expression"={($_.ExtensionData.Config.Version)}}," " | fl
			
			
			write-host ""
			write-host "                                                 Hosts of Cluster $clustername                   "
			write-host ""
			
			get-cluster | where {$_.Name -eq $clustername} | get-vmhost | Select Name,ConnectionState,PowerState,Manufacturer,Model,Version,Build,Parent,CpuTotalMhz,CpuUsageMhz,NumCpu,` 
			@{"Label"="MemoryTotalGB";"Expression"={"{0:N2}" -f ($_.MemoryTotalGB) -as [float]}},@{"Label"="MemoryUsageGB";"Expression"={"{0:N2}" -f ($_.MemoryUsageGB) -as [float]}},`
			@{"Label"="Bios";"Expression"={($_.ExtensionData.Hardware.BiosInfo.BiosVersion+"-"+$_.ExtensionData.Hardware.BiosInfo.ReleaseDate)}},`
			@{"Label"="NicInfo";"Expression"={$_.ExtensionData.Config.Network.Pnic | foreach-object {$_.Device+"-"+$_.Mac} | out-string -Width 160}},`
			@{"Label"="IPinfo";"Expression"={$_.ExtensionData.Config.Network.Vnic | foreach-object {$_.Device+"-"+$_.Spec.Ip.IpAddress} | out-string -Width 160}} | fl
				
		    
		    
		}
		409 {
			
			
				$1ds=get-cluster -Name $paramOpt | select -ExpandProperty ExtensionData
				[array]$2ds=$1ds.Datastore | select value
				foreach($2dsvalue in $2ds)
				{
				$2dsval=$2dsvalue.Value
				[array]$mds=get-cluster -Name $paramOpt  | get-datastore | where {$_.Id -like "*$2dsval"} | get-view | select -expandproperty summary| select Name,Capacity,FreeSpace,Uncommitted,Url
				foreach($myds in $mds)
				{
				$fmname=$myds.Name
				$fcapacity=[math]::round($myds.Capacity/1GB)
				$ffree=[math]::round($myds.FreeSpace/1GB)
				$funused=[math]::round($myds.Uncommitted/1GB)
				$fprovisioned=[math]::round(($myds.Capacity - $myds.FreeSpace + $myds.Uncommitted)/1GB)
				$furl=$myds.Url
				
				$mylun=get-cluster -Name $paramOpt  | get-datastore| where {$_.Id -like "*$2dsval"}
				
				if($mylun.Type -eq "NFS")
				{
				$mnamelun=$mylun.Name
				[array]$flun=$mylun.ExtensionData.Info.Nas
				[int]$cpa=($flun.Capacity)/1GB
				$fslun = $flun.RemoteHost,$flun.RemotePath,$cpa -Join(",")
				
				$mr += "$fmname|$fcapacity|$ffree|$funused|$fprovisioned|$furl|$fslun >"
				
				$fslun=$Null
				}
				else
				{
				[array]$flun=$mylun.ExtensionData.Info.Vmfs.Extent | Select DiskName
				foreach($flund in $flun)
				{
				$filun = $flund.DiskName
				$fslun+="$filun,"
				}
				
				$mr += "$fmname|$fcapacity|$ffree|$funused|$fprovisioned|$furl|$fslun >"
				
				$fslun=$Null
				}
				}
				}
				
				$marr=@()
				$marr=$mr.split(">")
				$total=@()
				
				foreach($mmr in $marr)
				{
					
					
					$fmr=$mmr.split("|")
					
					$result = New-Object System.Object
					
					$result | Add-Member -MemberType NoteProperty -Name "Datastorename" -Value $fmr[0]
					$result | Add-Member -MemberType NoteProperty -Name "Capacity GB" -Value $fmr[1]
					$result | Add-Member -MemberType NoteProperty -Name "Free GB" -Value $fmr[2]
					$result | Add-Member -MemberType NoteProperty -Name "Unused GB" -Value $fmr[3]
					$result | Add-Member -MemberType NoteProperty -Name "Provisioned GB" -Value $fmr[4]
					$result | Add-Member -MemberType NoteProperty -Name "DSURL" -Value $fmr[5]
					$result | Add-Member -MemberType NoteProperty -Name "Details" -Value $fmr[6]
					
					$total += $result
					
				}
				
				$total | format-table -wrap -ea Stop


			
			}
	
		410 {
			

get-view -viewtype HostSystem -SearchRoot (get-cluster $Paramopt).id |
     % {
           Write-Output "`n`n`nESXi Host : $($PSITEM.NAME)"
           Write-Output "`nLog Hosts :  "
           $result = get-view $_.ConfigManager.AdvancedOption | 
           select -ExpandProperty Setting  |?{$_.Key -like "Syslog.global.logHost"} 
           $collect = $result.Value -split ','
           $collect
         }
			
			}
		
		411{$mhosts = get-cluster $Paramopt | get-vmhost
		
		foreach($myhost in $mhosts)
		{

		write-host " "	
		Write-host "$myhost"
		write-host " "
		
		write-host '--------------------------------------------'
		write-host "Network Info for $myhost"
		write-host '--------------------------------------------'
		try{
			$networkinfo = $myhost | Get-VMHostNetworkAdapter | select VMhost, Name, IP, SubnetMask, Mac, PortGroupName, vMotionEnabled, mtu, FullDuplex, BitRatePerSec
	
			$networkinfo | ft -wrap
			$esxcli2 = Get-ESXCLI -VMHost $myhost  -V2
			$niclist = $esxcli2.network.nic.list.invoke()
			$nicdetails = @()
			$NicinfoView = @()
	 		foreach ($nic in $niclist) {
	    		$args = $esxcli2.network.nic.get.createargs()
	    		$args.nicname = $nic.name
	    		$nicdetail = $esxcli2.network.nic.get.Invoke($args)
	    		$nicdetails += $nicdetail
	      		}
	            ForEach ($nicdetail in $nicdetails){
			        		$NICReport = [PSCustomObject] @{
					        Host = $esxHost.Name
					        vmnic = $nicdetail.Name
					        LinkStatus = $nicdetail.LinkStatus
					        BusInfo = $nicdetail.driverinfo.BusInfo
					        Driver = $nicdetail.driverinfo.Driver
					        FirmwareVersion = $nicdetail.driverinfo.FirmwareVersion
					        DriverVersion = $nicdetail.driverinfo.Version}
			        		$NicinfoView+= $NICReport} 
			         
	 				$NicinfoView | ft -wrap
			}
	 catch {
		write-host "Code Execution failed"
		}
		
		
		}
		
		}

		413 {
			
		try {
			$cluhostslist = Get-Cluster $Paramopt | Get-VMHost| Sort Name

#$cluhostslist = $cluhostslist.Name

$multipolicy = $cluhostslist | foreach {Get-ScsiLun -LunType disk -VmHost $_} | select-object vmhost,canonicalname,multipathpolicy
$multipolicy | ft
<#$Policylist = @()
    foreach ($policy in $multipolicy){
         $PolicyReport = [PSCustomObject] @{
		 Canonicalname = $policy.CanonicalName
   		 multipathpolicy = [system.String]$policy.MultipathPolicy }
   $Policylist += $PolicyReport 
   }
   $Policylist |ft
		#>
		}
		
		catch {
				write-host "Code Execution failed"
			}
			
			
			}
			


#Datacenter
		301 {
			#cluster List 
			
				get-datacenter -Name $paramOpt | get-cluster -ea Stop
			}
		302 {
			get-datacenter -Name $paramOpt | get-vmhost -ea Stop
			}
		303 {
			#vm List 
			get-datacenter -Name $paramOpt | get-vm -ea Stop
			}
		304 {
			get-datacenter -Name $paramOpt | Get-VDSwitch | Select Name,@{"Label"="NumHosts";"Expression"={$_.ExtensionData.Summary.NumHosts}},NumPorts,Mtu,Version,Vendor,LinkDiscoveryProtocol,LinkDiscoveryProtocolOperation,@{"Label"="Portgroups";"Expression"={$_.ExtensionData.Summary.PortgroupName | out-string -Width 160}} | fl  -ea Stop


			}


	}# the End
	
    }
    Catch {
    		Write-host "Error Occured `n" 
    		Write-Output $Error.Exception.Message
    	}
    	
    	
   	disconnect-viserver -confirm:$false
    }
     else
        {
              Write-Output "`nError connecting to vCenter Server  $($connect.name)"
        }  	

#########################


##############VCENTER HC##############

Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false | Out-Null
try

{
	if(!(Get-Module -Name VMware.VimAutomation.Core))
	{
    	Import-Module -Name VMware.VimAutomation.Core
    	if(!$?){ throw "Could not load VMware.VimAutomation.Core" }  
    }

	[ValidateNotNullOrEmpty()]
	$USER_PASSWORD = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force

    [ValidateNotNullOrEmpty()]

	$USERNAME = '$INPUT{USERNAME}'

	[ValidateNotNullOrEmpty()]
	$HOSTNM = '$INPUT{HOSTNAME}'

	[ValidateNotNullOrEmpty()]
	$SelectedOption = '$INPUT{SELECTREPORT}'
	

    #Credentials
    $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )

    $CountDRS = $Null
    $CountHA = $Null
    $countNConnected = $Null
    $countMM = $Null

    if ($HOSTNM -eq 'vc1' -or $HOSTNM -eq 'vc2' -or $HOSTNM -eq 'vc3' )
	{
		[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls
	}	


    #script started for Maintenance Mode and Disconnected Status  ------>
    #Connect VI Server
  $connect = Connect-VIServer $HOSTNM -Credential $CREDENTIALS  -ErrorAction Stop
  #Check the Connectivity
     if ($connect)
        {
              $OutConnect = "`nConnected to  $HOSTNM"
              Write-Output $OutConnect
        }
     else
        {
              Write-Output "`nError connecting to Virtual Center $HOSTNM"
        }
  #$selection = Read-Host $SelectedOption
	switch -regex($SelectedOption)
 {
     'Perform VCenter Health Check' {
     
    #Checking the HEalth of the ESXi Hosts


    if((get-vmhost) -ne $Null)
    {
        #Maintenance Mode
        $MaintenanceMode = Get-VMHost | Where-Object {$_.ConnectionState -eq "Maintenance"} | Select-Object Name
        # Export-Excel "d:\test\VcenterHealthCheck.xlsx" -WorkSheetname "HOSTSinMaintenanceMode"
        Write-Output " "

        #Host Disconnected
        $Disconnected = get-vmhost | Where-Object {($_.ConnectionState -ne "Connected") -and ($_.ConnectionState -ne "Maintenance") } | Select-Object Name, Model | Select-Object Name 
        # Export-Excel "d:\test\VcenterHealthCheck.xlsx" -WorkSheetname "HostDisconnectedState"


        #count
        [int]$countNConnected= ($Disconnected).count
        [int]$countMM= ($MaintenanceMode).count
        Write-Output ""

    }
    else
    {
        Write-Output "Host(s) not found"
    }
    if((get-cluster) -ne $Null)
    {
        #Cluster without HA

        $nonHA = get-cluster | Where-Object {$_.HAEnabled -eq $false} | Select-Object Name, HAEnabled 
        # Export-Excel "d:\test\VcenterHealthCheck.xlsx" -WorkSheetname "ClusterwithoutHA"
        [int]$CountHA = ($nonHA).count
       

        #CLuster without DRS
        $nonDRS= get-cluster | Where-Object {$_.DrsEnabled -eq $false} | Select-Object Name, DrsEnabled 
        #Export-Excel "d:\test\VcenterHealthCheck.xlsx" -WorkSheetname "ClusterwithoutDRS"
        [int]$CountDRS =  ($nonDRS).count

        function summary {
        
        Write-Output "-----------------------------------------------------------------"
        Write-Output "S U M M A R Y"
        Write-Output "-----------------------------------------------------------------"
        Write-Output "vCenter Server                    : $HOSTNM"
        Write-Output "Number of Host(s) in Maintenance  : $countMM "
        Write-Output "Total Host(s) Disconnected        : $countNConnected"
        Write-Output "Total Clusters without DRS        : $CountDRS "
        Write-Output "Total Cluster without HA          : $CountHA"
        Write-Output ""
        Write-Output "-----------------------------------------------------------------"
        Write-Output ""
        Write-Output ""
        Write-Output "D E T A I L S"
        Write-Output "-----------------------------------------------------------------"
        Write-Output ""
        if ($countMM -ne 0){
            Write-Output "-----------------------------------------------------------------"
            Write-Output "Host(s) in Maintenance Mode "
            Write-Output "-----------------------------------------------------------------"
            Write-Output ""
            Write-Output $MaintenanceMode.name
            Write-Output "-----------------------------------------------------------------"
            Write-Output ""
        }
        if ($countNConnected -ne 0){
            Write-Output "-----------------------------------------------------------------"
            Write-Output "Host(s) Disconnected"
            Write-Output "-----------------------------------------------------------------"
            Write-Output ""
            Write-Output $Disconnected.name
            Write-Output "-----------------------------------------------------------------"
            Write-Output ""
        }
        if ($CountDRS -ne 0){
            Write-Output "Cluster without HA"
            Write-Output "-----------------------------------------------------------------"
            Write-Output ""
            Write-Output $nonHA.Name
            Write-Output "-----------------------------------------------------------------"
            Write-Output ""
        }
        if ($CountDRS -ne 0){
            
            Write-Output "Clusters without DRS"
            Write-Output "-----------------------------------------------------------------"
            Write-Output ""
            Write-Output $nonDRS.Name
            Write-Output "-----------------------------------------------------------------"
        }
	}
summary | Export-Excel "d:\test\$HOSTNM-VcenterHealthCheck.xlsx" -WorkSheetname "SUMMARY"
$MaintenanceMode | Export-Excel "d:\test\$HOSTNM-VcenterHealthCheck.xlsx" -WorkSheetname "HOSTSinMaintenanceMode"
$Disconnected | Export-Excel "d:\test\$HOSTNM-VcenterHealthCheck.xlsx" -WorkSheetname "HostDisconnectedState"
$nonHA | Export-Excel "d:\test\$HOSTNM-VcenterHealthCheck.xlsx" -WorkSheetname "ClusterwithoutHA"
$nonDRS | Export-Excel "d:\test\$HOSTNM-VcenterHealthCheck.xlsx" -WorkSheetname "ClusterwithoutDRS"
$outdump = "d:\test\$HOSTNM-VcenterHealthCheck.xlsx"

    }
    else
    {
        Write-Output "Cluster(s) not found"
    }
    #Script Ended for Maintenance Mode and Disconnected Status  ------>"

     }
     'Inventory Hardware' {
     Write-Output "INVENTORY HARDWARE"
	
	$listhardware = Get-ESXInventory -Hardware -ExportExcel -folderpath d:\test\
	$newname = "$HOSTNM-InventoryHardware.xlsx"
	Get-ChildItem -Path d:\test\ -Filter "*Inventory*" -Recurse | Rename-Item -NewName {$newname}
	$outdump = "d:\test\$HOSTNM-InventoryHardware.xlsx"
	   }
     'Inventory Configuration' {
      Write-Output "INVENTORY CONFIGURATION"
	$listconfiguration = Get-ESXInventory -Configuration -ExportExcel -folderpath d:\test\
	$newname = "$HOSTNM-InventoryConfiguration.xlsx"
	Get-ChildItem -Path d:\test\ -Filter "*Inventory*" -Recurse | Rename-Item -NewName {$newname}
	$outdump = "d:\test\$HOSTNM-InventoryConfiguration.xlsx"
	     } 
     'Inventory Physical Adapters' {
    Write-Output ""
	Write-Output "NETWORK PHYSICAL ADAPTERS"
	$listphysicaladapters = Get-ESXNetworking -PhysicalAdapters -ExportExcel -folderpath d:\test\
	$newname = "$HOSTNM-InventoryPhysicalAdapters.xlsx"
	Get-ChildItem -Path d:\test\ -Filter "*Networking*" -Recurse | Rename-Item -NewName {$newname}
	$outdump = "d:\test\$HOSTNM-InventoryPhysicalAdapters.xlsx"
	     }
     'Inventory Virtual Switches' {
    Write-Output ""
	write-output "NETWORK VIRTUAL SWITCHES"
	$listvirtualswitches = Get-ESXNetworking -VirtualSwitches -ExportExcel -folderpath d:\test\
	$newname = "$HOSTNM-InventoryVirtualSwitches.xlsx"
	Get-ChildItem -Path d:\test\ -Filter "*Networking*" -Recurse | Rename-Item -NewName {$newname}
	$outdump = "d:\test\$HOSTNM-InventoryVirtualSwitches.xlsx"
	     }
     'Inventory VMKernel Adapters' {
    $listvirtualadapters = Get-ESXNetworking -VMKernelAdapter -ExportExcel -folderpath d:\test\
	$newname = "$HOSTNM-InventoryVMKernelAdapters.xlsx"
	Get-ChildItem -Path d:\test\ -Filter "*Networking*" -Recurse | Rename-Item -NewName {$newname}
	$outdump = "d:\test\$HOSTNM-InventoryVMKernelAdapters.xlsx"
     }
     'Inventory IO Devices' {
    write-output "INVENTORY IO DEVICES"
	$listiodevices = Get-ESXIODevice -ExportExcel -folderpath d:\test\
	$newname = "$HOSTNM-IODevices.xlsx"
	Get-ChildItem -Path d:\test\ -Filter "*IODevice*" -Recurse | Rename-Item -NewName {$newname }
	$outdump = "d:\test\$HOSTNM-IODevices.xlsx"
	     }
     'Inventory Datastores' {
    Write-Output ""
	Write-Output "INVENTORY DATASTORES"
	$listdatastores = Get-ESXStorage -ExportExcel -folderpath d:\test\
	$newname = "$HOSTNM-InventoryDatastores.xlsx"
	Get-ChildItem -Path d:\test\ -Filter "*Storage*" -Recurse | Rename-Item -NewName {$newname }
	$outdump = "d:\test\$HOSTNM-InventoryDatastores.xlsx"
	  }
     'Inventory vSAN Info' {
    write-output ""
	write-output "INVENTORY vSAN info"
	$listvsaninfo = Get-vSANInfo -ExportExcel -folderpath d:\test\
	$newname = "$HOSTNM-vSanINfo.xlsx"
	Get-ChildItem -Path d:\test\ -Filter "*SAN*" -Recurse | Rename-Item -NewName {$newname }
	$outdump = "d:\test\$HOSTNM-vSanINfo.xlsx"
	     }
     'Inventory ESX Speculative Report' {
    write-output ""
	write-output "INV ESX SPECULATIVE REPORT"
	$listesxspeculativereport = Get-ESXSpeculativeExecution -ExportExcel -folderpath d:\test\
	$newname = "$HOSTNM-ESXSpeculativeReport.xlsx"
	Get-ChildItem -Path d:\test\ -Filter "*SpeculativeExecution*" -Recurse | Rename-Item -NewName {$newname }
	$outdump = "d:\test\$HOSTNM-ESXSpeculativeReport.xlsx"
	write-output ""
     }
     'Inventory VM Speculative Report' {
    write-output ""
	write-output "INV VM SPECULATIVE REPORT"
	Get-VMHost | Get-VM | Get-VMSpeculativeExecution | Export-Excel "d:\test\$HOSTNM-VMspeculativereport.xlsx" -WorkSheetname "VMresults"
	$outdump = "d:\test\$HOSTNM-VMspeculativereport.xlsx"
	write-output ""
     }
     'Inventory LUN multipathing Details' {
     	Write-Output ""
	Write-Output "Inventory LUN multipathing Details"
	
	$views = Get-View -ViewType "HostSystem" -Property Name,Config.StorageDevice
$result = @()
 
foreach ($view in $views | Sort-Object -Property Name) {
    Write-Host "Checking" $view.Name
 
    $view.Config.StorageDevice.ScsiTopology.Adapter |?{ $_.Adapter -like "*FibreChannelHba*" } | %{
        $hba = $_.Adapter.Split("-")[2]
 
        $active = 0
        $standby = 0
        $dead = 0
 
        $_.Target | %{ 
            $_.Lun | %{
                $id = $_.ScsiLun
 
                $multipathInfo = $view.Config.StorageDevice.MultipathInfo.Lun | ?{ $_.Lun -eq $id }
 
                $a = [ARRAY]($multipathInfo.Path | ?{ $_.PathState -like "active" })
                $s = [ARRAY]($multipathInfo.Path | ?{ $_.PathState -like "standby" })
                $d = [ARRAY]($multipathInfo.Path | ?{ $_.PathState -like "dead" })
 
                $active += $a.Count
                $standby += $s.Count
                $dead += $d.Count
            }
        }
 
        $result += "{0},{1},{2},{3},{4}" -f $view.Name, $hba, $active, $dead, $standby
    }
}
 
ConvertFrom-Csv -Header "VMHost", "HBA", "Active", "Dead", "Standby" -InputObject $result | ft -AutoSize | out-file "d:\test\tempoutputpath.csv" -Append
	
	$outputpath1 = "d:\test\tempoutputpath.csv"
	$outputexcel = "d:\test\Multipathingstatusreport.xlsx"
	$newname = "$HOSTNM-InventorymultipathDetails.xlsx"
	Import-Csv -Path $outputpath1 | Export-Excel -NoHeader $outputexcel
	Get-ChildItem -Path d:\test\ -Filter "*pathing*" -Recurse | Rename-Item -NewName {$newname }
	$outdump = "d:\test\$HOSTNM-InventorymultipathDetails.xlsx"
	remove-item d:\test\tempoutputpath.csv -Force
         
     } 
 }

	
$outfiles=(get-childitem 'd:\test' | where{($_.Name -like '*.xlsx') -and ($_.Name -notlike '*Error*.xlsx')} | Sort-Object -Property LastWriteTime -Descending).FullName

if($outfiles.count -gt 1)
{
$outfiles=$outfiles[0]	
}

write-host "Vcenterheathcheck report located in $outfiles and dump file=$outdump"
else
{
write-host "dump file is $outdump"
}
}




catch [VMware.VimAutomation.ViCore.Types.V1.ErrorHandling.InvalidLogin]
{
	Write-Output "RS_ERROR: Invalid Login: $Error"
}
catch
{
    Write-Output "RS_ERROR: PowerShell Script Error: $Error"
}


    



  
       



######################

#############UPLOAD FILE TO SNOW as Attach#############

$serviceUser = '$INPUT{USERNAME}'
$servicePass = '$INPUT{PASSWORD}'
$attachpath = '$INPUT{DUMPPATH}'
$servername = '$INPUT{SERVERNAME}'


$result = ""

try
{
	
	if($serviceUser -and $servicePass -and $attachpath )
	{
		$servicePass = ConvertTo-SecureString $servicePass -AsPlainText -Force
	    $credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $serviceUser, $servicePass
	   


$site=Invoke-WebRequest -uri "https://company.service-now.com/api/now/table/cmdb_ci_win_server?name=$servername" -Credential $credential 
$newv=$site.Content

$lines=$newv.split(",")

foreach($line in $lines)
{

if($line | select-string "sys_id")
{
$isys_id=(($line.split(":"))[-1]).replace('"',"")
$isys_id=$isys_id.Trim()
}

}

[string]$mnow=get-date
$fstamp=(($mnow.replace(" ","_")).replace("/","_")).replace(":","_")

$Resolve_upload="Resolve_Upload_Vcenterhealthcheck_$fstamp"

$uri = "https://company.service-now.com/api/now/attachment/file?table_name=cmdb_ci_win_server&table_sys_id=$isys_id&file_name=$Resolve_upload"

$outuri = "https://company.service-now.com/cmdb_ci_win_server.do?sys_id=$isys_id"

$searchext="."+$attachPath.split(".")[-1]
$searchparent=$attachPath.split(".")[0]

if (!(Test-Path HKCR:\)) {
			
				##New-PSDrive usage info can be found at (https://technet.microsoft.com/en-us/library/Hh849829.aspx)
				New-PSDrive -Name HKCR -PSProvider Registry -Root HKEY_CLASSES_ROOT | Out-Null
			}
		$Regkey = Get-Item "HKCR:\$searchext" -ErrorAction Stop
		$values = Get-ItemProperty $Regkey.PSPath -ErrorAction Stop
		$mime = $values.'Content Type'

if($mime)
{
$response=Invoke-WebRequest -uri $uri -Method Post -Infile $attachpath -ContentType $mime -Credential $credential
$recode=$response.StatusCode
write-host "Response is $recode"
}
else
{
$destine="$searchparent.Zip"
Compress-Archive -LiteralPath $attachPath -CompressionLevel Optimal -DestinationPath $destine -Force
$response=Invoke-WebRequest -uri $uri -Method Post -Infile $destine -ContentType 'application/x-zip-compressed' -Credential $credential
$recode=$response.StatusCode
write-host "Response is $recode"
}
	   
	   
	   
	    if($recode -eq 201){
	    $result += "Report for vCenter $servername saved in servicenow CI record. Click the below link to access the report"
	    $result += "`r`n"
	     $result += "`r`n"
	    $result += $outuri
	    $result += "`r`n"
	    $result += "`r`n"
	    #$result += "SysID is"
	    #$result += $isys_id
	    $result += "Successful Response code = " + $recode + "`n"	
	    $result += $recode
	    }
	    else{
	    $result += "There is a problem in the URL and following is the response code " + $recode + "`n"	
	    }		    
	}
	else
	{
		$result += "<==FAIL==>: Missing INPUTS: "
		if(!$serviceUser){ $result += "SERVICENOW_USER " }
		if(!$servicePass){ $result += "SERVICENOW_PASSWORD " }
		if(!$url) { $result += "URL " }
		if(!$ipaddress) { $result += "IPAddress " }
	}

}
catch [Exception]
{   
    $result += "<==FAIL==>: " + $_.Exception.GetType().FullName + $_.Exception.Message + "`n";
    $result += ($_.Exception|format-list -force).toString();
}
finally
{
    echo $result
}

if(test-path $attachpath -ErrorAction SilentlyContinue)
{
remove-item $attachpath -Force	
}

######################

##############send mail########

Send-MailMessage -from "company.com" `
                       -to '$INPUT{EMAIL}' `
                       -subject "vCenter health Check" `
                       -body "Hi, PFA vCenter Report" `
                       -Attachment '$INPUT{DUMPPATH}' -smtpServer companyrel.compnay.com

$attachpath = '$INPUT{DUMPPATH}'

if(test-path $attachpath -ErrorAction SilentlyContinue)
{
remove-item $attachpath -Force	
}

#######################

#################windows hc working###############3


$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password

[string]$vmname = '$INPUT{COMPUTERNAME}'

$vmname = $vmname.Split(".")[0]

Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {
	
	try {
	    Write-host "`n== Process CPU Utilization in % ==`n"
	    $CpuCores = (Get-WMIObject Win32_ComputerSystem -ea Stop).NumberOfLogicalProcessors
	    (get-counter "\Process(*)\% Processor Time").CounterSamples | 
	    Select-Object InstanceName, @{Name = "CPU %"; Expression = { [Decimal]::Round(($_.CookedValue / $CPUCores), 2) } } | 
	    Sort-Object 'cpu %' -Descending | 
	    Select-Object -First 5 | Format-Table -auto
	}
	catch{
	    Write-host "`nUnable to read the CPU utilization`n"
	}
	
	
	try{
	    Write-host "`n== Memory Utilization in % ==`n"
	    $totmem = [math]::Round((Get-WmiObject win32_computersystem  -ErrorAction SilentlyContinue).TotalPhysicalMemory / 1GB)
	    $Memoryout = get-process | Select-Object -Property ProcessName,
	    @{Name = 'SystemMemory_GB'; Expression = { $totmem } },
	    @{Name = 'Memory'; Expression = { [math]::round($_.workingset64 / 1024kb) } } | Sort-Object 'Memory' -Descending | Select-Object -first 10
	    Write-Host "`NSystem Memory is :" $totmem GB
	    foreach ($Memoryout in $Memoryout) {
	        Write-Host $Memoryout.ProcessName "="$Memoryout.Memory"MB" "=" (($Memoryout.Memory) / 8199 * 100).tostring("#.#")"%"
	    }
	}
	catch{
	    Write-host "`nUnable to read the Memory utilization`n"
	}
	
	   
	
	     
	try{
	    Write-host "`n== Stopped Auto Service ==`n"    
	    Get-WmiObject -Class Win32_Service -EA STOP | 
	    Where-Object { $_.State -ne "Running" -and $_.StartMode -eq "Auto" } | 
	    Select-Object Name | 
	    Format-Table -HideTableHeaders 
	}
	catch{
	    Write-Host "`nUnable to read the Memory utilization`n"
	}
	
	try{ 
	    Write-host "`n== Disk Utilization in % ==`n"
	    $disks = Get-WmiObject Win32_LogicalDisk | Select-Object DeviceID, @{'Name' = 'Size'; 'Expression' = { [math]::truncate($_.size / 1GB) } },
	    @{'Name' = 'Freespace'; 'Expression' = { [math]::truncate($_.freespace / 1GB) } }
	    $disksoutdata = $disks | Select-Object DeviceId, @{'Name' = 'Free'; 'Expression' = { [math]::truncate($_.Freespace / $_.size * 100) } } 
	    foreach ($disksout in $disksoutdata) {
	        write-host $disksout.DeviceID "=" $disksout.Free % Free Space
	    }
	}
	catch{
	    Write-Host "`nUnable to read the Disk Utilization`n"
	}
	
	try{
	    Write-host "`n== Disk I/O ==`n"
	    Get-WmiObject Win32_PerfFormattedData_PerfProc_Process | 
	    Sort-Object IOReadBytesPersec -des | 
	    Select-Object  Name, IOReadBytesPersec, IOWriteBytesPersec -First 10 | 
	    Format-Table -AutoSize
	}
	catch{
	     Write-Host "`nUnable to read the Disk I/O Information`n"
	}
} -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)

$baseserver = $env:COMPUTERNAME

if ($baseserver.StartsWith("rov") -or $baseserver.StartsWith("rov") )
		{ $dbserver = '$PROPERTY{db_prod}'
    	}
else 	{ $dbserver = '$PROPERTY{db_host}'
		}

#$dbserver = '$PROPERTY{db_prod}'
$dbuser = '$PROPERTY{DB_USER}'
$dbpwd = '$PROPERTY{DB_PASSWORD}'


$selectquery = @'
SELECT HostMemoryGB,HostSockets,HostCpuThreads,HostPowerPolicy,vmCpuHotAddEnabled,VMSockets,VMCoresPerSocket,vCPUs,OptimalSockets,OptimalCoresPerSocket,vmOptimized
FROM [test].[dbo].[test_Config] where vmname like N'%{0}%'
'@
$selectCMD = $selectquery -f $vmname

	Write-host `n`n`n"== vNUMA Optimization Report for $vmname =="`n

$execquery = Invoke-Sqlcmd -Query $selectCMD -ServerInstance $dbserver -Username $dbuser -Password $dbpwd -ErrorAction Stop
if ($execquery){
	write-host `n`n"Is vNUMA optimized per VMware recommendation?"`n
	$execquery.vmOptimized
	$execquery
}
else
{
	write-host `n`n"Server might be Physical server or no entry present in vNUMA datablase"
}


##############################

####################update to snow (problem ticket)##########

$incident = '$INPUT{INCIDENT}'
$cputout = '$INPUT{CPU_OUTPUT}'
$spass = '$INPUT{SNOWPASSWORD}'
$global:work ='$INPUT{WORKSHEET}'
$global:finalres=@"
$INPUT{COMPILED}
"@


$inchash=@{}
$inchash.Add("1","New") 
$inchash.Add("2","Assigned (Ticket has someone assigned to it and it is being worked)")
$inchash.Add("12","Referred (Ticket has been assigned to a group, but not to an individual yet")
$inchash.Add("4","Awaiting User Info")
$inchash.Add("5","Awaiting Evidence")           
$inchash.Add("10","Awaiting Change")
$inchash.Add("8","Awaiting Vendor")  
$inchash.Add("11","Awaiting Vendor Change")
$inchash.Add("6","companyd")
$inchash.Add("7","Closed")
$inchash.Add("3","ON Hold")


[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

$global:user = 'company'
$global:password = ConvertTo-SecureString $spass -AsPlainText -Force
$global:credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $user,$password
$global:GetIncidentURI = "$PROPERTY{SERVICENOW_LINK}/api/now/table/incident?number=$incident"
$global:GetIncidentURIdisplay = "$PROPERTY{SERVICENOW_LINK}/api/now/table/incident?number=$incident&sysparm_display_value=true"


function getIncidentdetails()
{
    $Requests = Invoke-RestMethod -Uri $global:GetIncidentURI -Credential $global:credential -Method GET -ContentType "application/json"
    $disrequests = Invoke-RestMethod -Uri $global:GetIncidentURIdisplay -Credential $global:credential -Method GET -ContentType "application/json"
    if($Requests.result.Count -ne 0)
    {
            
        $global:innumber=$Requests.result.number
        $global:insysid=$Requests.result.sys_id
        $global:inshortd=$Requests.result.short_description

       
            if($Requests.result.cmdb_ci.value)
            {
                $global:incmdb=$Requests.result.cmdb_ci.value
            }
            else
            {
                $global:incmdb="No Value found"
            }

        $global:createdon=$Requests.result.sys_created_on
        $global:assignmentgroup=$Requests.result.assignment_group.value
        $global:category=$Requests.result.category
        $global:subcategory=$Requests.result.subcategory
        $global:contact_type=$Requests.result.contact_type
        $global:desc=$Requests.result.description
        $global:cidisplay=$disrequests.result.cmdb_ci.display_value
        $global:state=$Requests.result.state
        
    }
    else
    {
     	write-output 'Failed'	
    }
    
}



function createProblemTicket()
{
	
	if($global:inshortd | select-string "The server is utilizing a high amount of CPU")
	{
		$comments='The server is utilizing a high amount of CPU'}
            
	if(($global:inshortd | select-string "The Percentage of Available System Memory is low") -or ($inshortd | select-string "The Available System Memory is low"))
	{
		$comments='The Percentage of Available System Memory is low'}
            
            
  	if("$global:inshortd" -like "Windows OS: The *Automatic* Service*")	
  	{
     	$clientservice="$inshortd".split("[")[2].split("]")[0]
    	$comments="Service Failed: $clientservice"
	}
	
	
	
    $category=$global:category
    $subcategory=$global:subcategory
    $agroup="$global:assignmentgroup"
    $desc="Historic and Current usage details are below
    $global:dbout 
    $global:finlres"
    $sedesc="Repeat offender : [$global:cidisplay] [$comments]"
    $configitem=$global:incmdb
    $chstarttime='15'
    $chstartdate='15'
    
    if($chstarttime -like "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]")
    {
      $currentdate=(get-date).AddDays($chstartdate).ToString("yyyy-MM-dd "+$chstarttime)
    }
    else
    {
      $currentdate=(get-date).AddDays($chstartdate).ToString("yyyy-MM-dd hh:mm:ss")
    }
    
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    
    $rIncidentPOSTResponse=$Null
    
    if($configitem -notlike "*,*")
    {
    $cmdbci="$PROPERTY{SERVICENOW_LINK}/api/now/table/cmdb_ci?sys_id=$configitem"
    $configvals=(Invoke-RestMethod -Uri $cmdbci -Credential $global:credential -Method GET -ContentType "application/json").result.sys_id
    if($configvals)
    {
        if($configvals.Count -ne 1)
        {
            $configval=$configvals[0]
        } 
        else
        {
            $configval=$configvals
        }

        $rbody = @{
                 'u_category' = $category
                 'u_subcategory' = $subcategory
                 'assignment_group' = $agroup
                 'short_description' = $sedesc
                 'u_unlisted_ci' = $unlisted
                 'u_new_configuration_item' = $unlistval
                 'cmdb_ci' = $configval
                 'description' = $desc
                 'due_date'=$currentdate}
    }
    else
    {

        $unlisted=$true
        $unlistval=$configitem
        $rbody = @{
                 'u_category' = $category
                 'u_subcategory' = $subcategory
                 'assignment_group' = $agroup
                 'short_description' = $sedesc
                 'u_unlisted_ci' = $unlisted
                 'u_new_configuration_item' = $unlistval
                 'description' = $desc
                 'due_date'=$currentdate}
    }

    }	
    else
    {

    $unlisted=$true
    $unlistval=$configitem
    $rbody = @{
             'u_category' = $category
             'u_subcategory' = $subcategory
             'assignment_group' = $agroup
             'short_description' = $sedesc
             'u_unlisted_ci' = $unlisted
             'u_new_configuration_item' = $unlistval
             'description' = $desc
             'due_date'=$currentdate}
    }	
    
    $checkproblem="$PROPERTY{SERVICENOW_LINK}/api/now/table/problem?sysparm_query=state!=2^state!=4^short_description=$sedesc"
    
        Try 
        {
            $checkproblemResponse = Invoke-RestMethod -Method GET -Uri "$checkproblem" -TimeoutSec 100 -Credential $global:credential -ContentType $Type
        }
        Catch 
        {
            Write-Host $_.Exception.ToString()
            $error[0] | Format-List -Force
        }

    if($checkproblemResponse.result.count -eq 0)
    {
    
	    try
	    {
	    	
	    						
	        #UAT #$rIncidentURL = "$PROPERTY{SERVICENOW_UAT_LINK}/api/now/table/incident"
	        #Prod : #
	        $rIncidentURL = "$PROPERTY{SERVICENOW_LINK}/api/now/table/problem"
	        $Type = "application/json"
	        # Specify request body
	        $rbodyJson = $rbody | ConvertTo-Json
	        # POST to API
	        Try 
	        {
	            $rIncidentPOSTResponse = Invoke-RestMethod -Method POST -Uri $rIncidentURL -Body $rbodyJson -TimeoutSec 100 -Credential $global:credential  -ContentType $Type
	        }
	        Catch 
	        {
	            Write-Host $_.Exception.ToString()
	            $error[0] | Format-List -Force
	        }
	        # Pulling ticket ID from response
	        $IncidentID = $rIncidentPOSTResponse.result.number
	        $Incidentdesc = $rIncidentPOSTResponse.result.description
	        $assys =$rIncidentPOSTResponse.result.sys_id
	        ###############################################
	        # Verifying Incident created and show ID
	        ###############################################
	        IF ($IncidentID -ne $null)
	        {
	            "Created Problemrequest With ID:$IncidentID" 
	            $global:problemout=$IncidentID
	        }
	        ELSE
	        {
	            "Problemrequest Not Created for $initems"
	        }
	    
	    }
	    catch [Exception]
	    {   
	        $result += "<==FAIL==>: " + $_.Exception.GetType().FullName + $_.Exception.Message + "`n";
	        $result += ($_.Exception|format-list -force).toString();
	    }
	    finally
	    {
	    	if($result -like "*System.NotSupportedException*")
	    	{
	    	    echo "______________________________________________________________________________________"	
	    	}
	    	else
	    	{
	            echo $result
	    	}
	    }
    }
    else
    {
    	$problemsysid=$checkproblemResponse.result.sys_id
    	$problemnumber=$checkproblemResponse.result.number
    	if($problemsysid.Count -gt 1)
        {
    	$problemsysid=$problemsysid[0]
    	$problemnumber=$problemnumber[0]
        }
        $worknotes="Below is the historic output for this configitem
    	$global:dbout
    	$finalres"
            
    	$bodyn = @{
    	'work_notes' = "$worknotes"
     	}
    	$bodyJsonn = $bodyn | ConvertTo-Json
    	$URIn = "$PROPERTY{SERVICENOW_LINK}/api/now/table/problem/$problemsysid"
    	$Requestsn = Invoke-WebRequest -Uri $URIn  -Method PUT -Credential $global:credential -Body $bodyJsonn -TimeoutSec 100 -ContentType "application/json"
    	if($Requestsn.StatusDescription -eq "OK"){$global:problemout="$problemnumber has been Updated"
    	}else{$global:problemout="Problem not Updated due to API error, Please check Problem ticket = $problemnumber"}
    }
    
}



function updatedb()
{
$clientname=$global:cidisplay
$clientcpu='$INPUT{CPUSORTED}'
$clientmem='$INPUT{MEMSORTED}'

if($global:finalstate -ne 'companyd')
{
$dbstate=$global:finalstate
}
else
{
$dbstate=$global:finalstate	
}

try{
$CurrentDate = '{0:yyyy-MM-dd hh:mm:ss}' -f (get-date $global:createdon)
}
catch
{
$CurrentDate = '{0:yyyy-MM-dd hh:mm:ss}' -f (get-date)	
	}
$setwindows=$Null

if($global:inshortd | select-string "The server is utilizing a high amount of CPU")
{
	$clientcpu=$clientcpu.split(',') -join('')
	$comments=$clientcpu
	}
            
if(($global:inshortd | select-string "The Percentage of Available System Memory is low") -or ($inshortd | select-string "The Available System Memory is low"))
{
	$clientmem=$clientmem.split(',') -join('')
	$clientmem=$clientmem.replace('[','').replace(']','')
	$comments=$clientmem}
            
if("$global:inshortd" -like "Windows OS: The *Automatic* Service*")
{
    $clientservice="$inshortd".split("[")[2].split("]")[0]
    $comments=$clientservice
}
          

$user='$PROPERTY{STARDB_USER}'
$pwd='$PROPERTY{STARDB_PWD}'

function GetConnectionString ($user, $passwd)
{
  return "Server=server1;Database=Automation;Integrated Security=False;User ID= $user ;Password= $pwd"
}


$query = @"
INSERT INTO [dbo].[WindowsHealthCheck] ( [INCIDENT], [CONFIGITEM], [SHORTDESCRIPTION], [COMMENTS], [CREATEDON], [STATE], [WORKSHEET]) VALUES ( '$global:innumber', '$clientname', '$global:inshortd', '$comments', '$CurrentDate', '$dbstate', '$global:work')
"@



[string]$connectionString = GetConnectionString -user $user -pwd $pwd
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
$SqlConnection.ConnectionString = $connectionString 
$SqlConnection.Open()


#$result = $SqlCmd.ExecuteReader()

$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
$SqlCmd.CommandText = $query   
$SqlCmd.Connection = $SqlConnection

try
{
  $result = $SqlCmd.ExecuteNonQuery()
}
catch
{
	write-host "Error: No Rows are affected"
}


if($result -eq 0)
{
 	write-host "Error: No Rows are affected"	
}
else
{
    write-host "Info: $result rows are affected"	
}

$SqlConnection.Close()
}

function createincident()
{
	if($global:inshortd | select-string "The server is utilizing a high amount of CPU")
	{
		$comments='High amount of CPU Utilization observed'
	}
	            
	if(($global:inshortd | select-string "The Percentage of Available System Memory is low") -or ($inshortd | select-string "The Available System Memory is low"))
	{
		$comments='The Available System Memory is identified as low'
	}
	            
	            
	if("$global:inshortd" -like "Windows OS: The *Automatic* Service*")	
	{
	    $clientservice="$inshortd".split("[")[2].split("]")[0]
		$comments="Service Failed: $clientservice"
	}
		
	$category=$global:category
	$subcategory=$global:subcategory
	$agroup=$global:assignmentgroup
	$sedesc="[Repeat Offender]: $comments"
	$cttype=$global:contact_type
	$desc="Incident is identifed as repeat offender and below is the historic details for this config item and problem ticket has been created for the same $global:problemout
	$global:dbout"
	$configitem=$global:incmdb
	$impact='3'
	$bimpact='4'
	
	[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
	
	$rIncidentPOSTResponse=$Null
	
	if($configitem -notlike "*,*")
	{
	    #UAT# $cmdbci="$PROPERTY{SERVICENOW_UAT_LINK}/api/now/table/cmdb_ci?name=$configitem"
	    #Prod : #
	    $cmdbci="$PROPERTY{SERVICENOW_LINK}/api/now/table/cmdb_ci/$configitem"
	    $configvals=$configitem
	    if($configvals)
	    {
	        if($configvals.Count -ne 1)
	        {
	            $configval=$configvals[0]
	        }
		    else
		    {
		        $configval=$configvals
		    }
	    
			$rbody = @{
			    'impact' = $impact
			    'urgency' = '2'
			    'caller_id' = 'company Systems'
			    'opened_by' = 'company Systems'
			    'u_request_system' = 'company'
			    'category' = $category
			    'subcategory' = $subcategory
			    'notify' = '1'
			    'assignment_group' = $agroup
			    'short_description' = $sedesc
			    'contact_type' = $cttype
			    'u_unlisted_ci' = $unlisted
			    'u_new_configuration_item' = $unlistval
			    'cmdb_ci' = $configval
			    'u_business_impact' = $bimpact
			    'description' = $desc}
		}
		else
		{
		
		    $unlisted=$true
		    $unlistval=$configitem
		    $rbody = @{
		    'impact' = $impact
		    'urgency' = '2'
		    'caller_id' = 'company Systems'
		    'opened_by' = 'company Systems'
		    'u_request_system' = 'company'
		    'category' = $category
		    'subcategory' = $subcategory
		    'notify' = '1'
		    'assignment_group' = $agroup
		    'short_description' = $sedesc
		    'contact_type' = $cttype
		    'u_unlisted_ci' = $unlisted
		    'u_new_configuration_item' = $unlistval
		    'u_business_impact' = $bimpact
		    'description' = $desc}
		}
	
	}	
	else
	{
	    $unlisted=$true
	    $unlistval=$configitem
	    $rbody = @{
		    'impact' = $impact
		    'urgency' = '2'
		    'caller_id' = 'company Systems'
		    'opened_by' = 'company Systems'
		    'u_request_system' = 'company'
		    'category' = $category
		    'subcategory' = $subcategory
		    'notify' = '1'
		    'assignment_group' = $agroup
		    'short_description' = $sedesc
		    'contact_type' = $cttype
		    'u_unlisted_ci' = $unlisted
		    'u_new_configuration_item' = $unlistval
		    'u_business_impact' = $bimpact
		    'description' = $desc}
	}	
		
	try
	{
		
			
	    #UAT #$rIncidentURL = "$PROPERTY{SERVICENOW_UAT_LINK}/api/now/table/incident"
	    #Prod : #
	    $rIncidentURL = "$PROPERTY{SERVICENOW_LINK}/api/now/table/incident"
	    $Type = "application/json"
	    # Specify request body
	    $rbodyJson = $rbody | ConvertTo-Json
	    # POST to API
	    Try 
	    {
	        $rIncidentPOSTResponse = Invoke-RestMethod -Method POST -Uri $rIncidentURL -Body $rbodyJson -TimeoutSec 100 -Credential $credential -ContentType $Type
	    }
	    Catch 
	    {
	        Write-Host $_.Exception.ToString()
	        $error[0] | Format-List -Force
	    }
	    
	    # Pulling ticket ID from response
	    $IncidentID = $rIncidentPOSTResponse.result.number
	    $Incidentdesc = $rIncidentPOSTResponse.result.description
	    $assys =$rIncidentPOSTResponse.result.sys_id
	    ###############################################
	    # Verifying Incident created and show ID
	    ###############################################
	    IF ($IncidentID -ne $null)
	    {
	       write-host "Created Incident With ID:$IncidentID"
	        $global:incout=$IncidentID
	        $bodyn = @{
	        'assignment_group' = $agroup
	        }
	        $bodyJsonn = $bodyn | ConvertTo-Json
	        #UAT #$URIn = "$PROPERTY{SERVICENOW_UAT_LINK}/api/now/table/incident/$assys"
	        # Prod : #
	        $URIn = "$PROPERTY{SERVICENOW_LINK}/api/now/table/incident/$assys"
	        $Requestsn = Invoke-WebRequest -Uri $URIn  -Method PUT -Credential $credential -Body $bodyJsonn -TimeoutSec 100 -ContentType "application/json"
	    }
	    ELSE
	    {
	        "Incident Not Created "
	    }
	
	}
	catch [Exception]
	{   
	    $result += "<==FAIL==>: " + $_.Exception.GetType().FullName + $_.Exception.Message + "`n";
	    $result += ($_.Exception|format-list -force).toString();
	}
	finally
	{
		if($result -like "*System.NotSupportedException*")
		{
		echo "______________________________________________________________________________________"	
		}
		else
		{
	    echo $result
		}
	}
}


function fetchdb()
{
	$global:dbout=@()
	$clientname=$global:cidisplay
	if($clientname -like '*.*')
	{
	    $clientname=$clientname.split('.')[0]
	}
	
	
	$setwindows=$Null
	
	if($global:inshortd | select-string "The server is utilizing a high amount of CPU")
	{
	
	    $dbquery='%The server is utilizing a high amount of CPU%'
	}
	            
	if(($global:inshortd | select-string "The Percentage of Available System Memory is low") -or ($inshortd | select-string "The Available System Memory is low"))
	{
	
	    $dbquery='%Available System Memory is low%'
	
	}
	            
	if("$global:inshortd" -like "Windows OS: The *Automatic* Service*")
	{
	    $clientservice="$inshortd".split("[")[2].split("]")[0]
	    $comments=$clientservice
	    $dbquery=$inshortd.split(' ')[0..5] -join(' ')
	    $dbquery=$dbquery.replace('[','%').replace(']','%')
	}
	            
	
	$user='$PROPERTY{STARDB_USER}'
	$pwd='$PROPERTY{STARDB_PWD}'
	
	function GetConnectionString ($user, $passwd)
	{
		return "Server=lrk1wfiscpdb01;Database=Automation;Integrated Security=False;User ID= $user ;Password= $pwd"
	}
	
	
	$query = @"
	SELECT TOP 5 FORMAT(CREATEDON, 'MMM dd, yyyy hh:mm:ss') as CREATED_ON,INCIDENT,COMMENTS FROM [Automation].[dbo].[WindowsHealthCheckAudit] where SHORTDESCRIPTION LIKE '$dbquery' and CONFIGITEM LIKE '$clientname%' order by CREATEDON Desc
"@
	
	
	
	[string]$connectionString = GetConnectionString -user $user -pwd $pwd
	$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
	$SqlConnection.ConnectionString = $connectionString 
	$SqlConnection.Open()
	
	
	#$result = $SqlCmd.ExecuteReader()
	
	$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
	$SqlCmd.CommandText = $query   
	$SqlCmd.Connection = $SqlConnection
	
	try
	{
		$result = $SqlCmd.ExecuteReader()
	}
	catch
	{
		$ErrorMessage = $_.Exception.Message
		$FailedItem = $_.Exception.ItemName
		write-host "Entry Error,$ErrorMessage"
	}
	
	if($result)
	{
		$table = new-object "System.Data.DataTable"
		$table.Load($result)
		
		$global:dbout=($table | fl | Out-String) 
	}
	
	
	$SqlConnection.Close()
}



function updateincident()
{
    $worknotes="Below is the healthcheck output Done by company
    $global:dbout
    $global:finalres"
            
    $bodyn = @{
    'work_notes' = "$global:finalres"
     }
    $bodyJsonn = $bodyn | ConvertTo-Json
    $URIn = "$PROPERTY{SERVICENOW_LINK}/api/now/table/incident/$global:insysid"
    
    $Requestsn = Invoke-WebRequest -Uri $URIn  -Method PUT -Credential $global:credential -Body $bodyJsonn -TimeoutSec 100 -ContentType "application/json"
  
    $global:finalstate=$global:state
    
    if($Requestsn.StatusDescription -eq "OK"){write-host "$innumber has been Updated"
    }else{write-host "Incident not Updated due to API error, Please check Incident = $global:innumber"}

}

function closeincident()
{
    $companystate="yes"
    $rootcausereason="Spike in Resource utilization"
    $rootcausecode="No Action Required"
    $closenotes="$global:closenotes"
    $worknotes="$global:worknotes"
          
    $body = @{
    'u_root_cause_reason' = "$rootcausereason"
    'u_incident_cause_code' = "$rootcausecode"
    'u_root_cause_owner' = "FIS"
    'close_code' = "Solved (Known error)"
    'close_notes' = "$closenotes"
    'state' = "6"
    'Assigned to' = "013a80884fbe474042b5b47f0210c7d0"
    'work_notes' = "$worknotes"
     }

     $bodyJsonm = $body | ConvertTo-Json
     $URIm = "$PROPERTY{SERVICENOW_LINK}/api/now/table/incident/$global:insysid"
     try
     {
     $Requestsm = Invoke-WebRequest -Uri $URIm  -Method PUT -Credential $global:credential -Body $bodyJsonm -TimeoutSec 100 -ContentType "application/json"
     }
     catch
     {
      write-host 'Unable to close the incident'	
     }
     $Requestsm.Content.result
     $global:finalstate=$Requestsm.result.state
     $global:finalstate
     if($Requestsm.StatusDescription -eq "OK"){write-host "$global:innumber has been companyd"
     $global:finalstate='companyd'
     }else{write-host "Incident not companyd due to API error, Please check Incident = "$global:innumber
     $global:finalstate=$global:state}
}



#main

if($incident)
{

	getIncidentdetails
    
	if(($global:inshortd)  -and ($global:incmdb -ne 'No Value found') -and ($global:assignmentgroup -eq 'b210d542db6dfa000eaaf3b31d96190e'))
	{
		if(($global:inshortd | select-string "The server is utilizing a high amount of CPU") -or ($global:inshortd | select-string "The Percentage of Available System Memory is low") -or ($global:inshortd | select-string "The Available System Memory is low"))
		{
			if($global:inshortd | select-string "The server is utilizing a high amount of CPU")
			{
				$searchdescritpion='Windows%20OS:%20The%20server%20is%20utilizing%20a%20high%20amount%20of%20CPU'
			}
		        
			if($global:inshortd | select-string "The Percentage of Available System Memory is low")
			{
				$searchdescritpion='Windows%20OS:%20The%20Percentage%20of%20Available%20System%20Memory%20is%20low'
			}
		
		
			#$counturi="$PROPERTY{SERVICENOW_LINK}/api/now/table/incident?sysparm_query=sys_created_onONToday@javascript:gs.daysAgoStart(5)@javascript:gs.daysAgoEnd(0)^cmdb_ci=$global:incmdb^short_descriptionLIKE$searchdescritpion"	
			$counturi="$PROPERTY{SERVICENOW_LINK}/api/now/table/incident?sysparm_query=cmdb_ci=$global:incmdb^short_descriptionLIKE$searchdescritpion^sys_created_onONToday@javascript:gs.daysAgoStart(30)@javascript:gs.daysAgoEnd(0)"  
		 
			$countresponse=$NUll
			Try 
			{
				$countresponse = Invoke-RestMethod -Credential $credential -Method GET -Uri $counturi -Body $bodyJson -ContentType "application/json"
			}
			Catch 
			{
			    Write-Host $_.Exception.ToString()
			  	$error[0] | Format-List -Force
			}
		
			$countresponse.result.count
			if($countresponse.result.count -gt 5)
			{
				
				fetchdb
				createProblemTicket
				$global:closenotes="The ticket is being closed as we have problem ticket to investigate it further $global:problemout"
				$global:worknotes="The ticket is being closed as we have problem ticket to investigate it further $global:problemout"
				#closeincident
				updatedb
			}
			elseif($countresponse.result.count -eq 5)
			{
				
				fetchdb
				createProblemTicket
				$global:closenotes="The ticket is being closed as we have problem ticket to investigate it further $global:problemout"
				$global:worknotes="The ticket is being closed as we have problem ticket to investigate it further $global:problemout"
				#closeincident
				updatedb
				createincident
				$global:incout
				
			}
			else
			{	
				$global:worknotes="Spike in Resource utilization
				$global:finalres"
				updatedb
				updateincident
			}
		}
		else
		{
			$global:finalstate=$global:state
			updatedb
			updateincident
		}
	}
}
else
{
 	#updatedb
 	updateincident
}

###################

#########JUMP server profile cleanup########

$username = '$INPUT{USERNAME}'

$rt = '$INPUT{RunType}'
[int]$days= '$INPUT{LastLogonDays}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password


Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {
Param($rt, [int]$days)

write-host "`n"  #new line


# Select Profiles that the fit the request  for LastLogonDays and ect, for deletion or Review
$ProfileInfo = Get-WmiObject -Class Win32_UserProfile | where {$_.LastUseTime} |
	Where{$_.ConvertToDateTime($_.LastUseTime) -le (Get-Date).AddDays(-$days) -and $_.LocalPath -and $_.LastUseTime -and $_.LocalPath -notlike "*Administrator*" -and $_.LocalPath -notlike "*.NET*" -and $_.LocalPath -notlike "*MSSQL*" -and $_.LocalPath -notlike "*ServiceProfiles*" -and $_.LocalPath -notlike "*system32*"}

#If no Profiles fir the request Warning is written out.	
	If($ProfileInfo -eq $null)
	{
		Write-Warning -Message "The item not found."
	}
	else
	{
		# Display pre deletion local free diskspace
	    $DiskArray = get-WmiObject win32_logicaldisk 
		$PreDeletionDiskSpace=foreach ($disk in $DiskArray)
    	{
    	$disk |fl DeviceID,  @{n="FreeSpace GB";e={[math]::Round($_.FreeSpace / 1gb,2)}}
    	}
		write-output "`n---------------Pre Deletion Local Disk Space-----------"
		$PreDeletionDiskSpace
		Write-Host "`n--------------Profiles Below will be Delete-------------"
	}

If($rt -eq "Delete")
	{
			 
		Foreach($RemoveProfile in $ProfileInfo)
			{
			Try
	            {
	            	Write-Host "Deleting " $RemoveProfile.localpath "....."
	            	$RemoveProfile.Delete();  
	            }
	            
			Catch
	            {
	                Write-Warning "Delete profile failed for " + $RemoveProfile.localpath
	            }
	            
	   		 }
			 
	#Display post deletion local free diskspace
	$DiskArray = get-WmiObject win32_logicaldisk 
	$PostDeletionDiskSpace=foreach ($disk in $DiskArray)
    						{
    						$disk |fl DeviceID,  @{n="FreeSpace GB";e={[math]::Round($_.FreeSpace / 1gb,2)}}
    						}
	write-output "`n`n---------------Post Deletion Disk Space-----------"
	$PostDeletionDiskSpace
	
	Write-output "`n `n  Rebooting ........."
	#Reboot the Server
	Restart-Computer -Force 			
	} 
	
Else
	{
		Write-Host  "Review  Profiles to Be Delete for not logging in for -$days days"
	    $ProfileInfo |ft localpath
	    
	    	$DiskArray = get-WmiObject win32_logicaldisk 
	        $PostDeletionDiskSpace=foreach ($disk in $DiskArray)
    						{
    						$disk |fl DeviceID,  @{n="FreeSpace GB";e={[math]::Round($_.FreeSpace / 1gb,2)}}
    						}
	       write-output "`n`n---------------Post Deletion Disk Space-----------"
           $PostDeletionDiskSpace
	    Write-Host  "After Profiles are delete the Server will be recycled."
	    
	}
	
} -Argumentlist($rt, [int]$days) -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)


####################

################temp profile cleanup#######

<# 
This task repairs the server's temporary profiles.  The first action is to remove exiting KEYS.temp and 
then search the profile registy list to find KEYS.BAK and verify the Original KEYS if they Exist Rename
them to KEYS.TEMP and then rename the KEYS.BAK to the Original Key Name.  The Server requires Reboot after
these actions
#>

$SubmittedBy = '$INPUT{SUBMITTED_BY}'
$rt = '$INPUT{RunType}'
$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password
Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {
Param ($rt)

$PSVersion=$PSVersiontable.PSVersion.Major
if ($PSVersion -lt "3.0")
	{write-output "The Current Powershell Version is $PSVersion, which below version 3.0 requirement"}
else
	{write-output "The Current Poweshell Version is $PSVersion, which meet Version 3.0 requirement"}

write-host "`n"  #new line
write-host "---------This Module Repairs any Temp Profiles that Exists---------" 
write-host "Submitted by $SubmittedBy"
write-host "`n"  #new line

##  Set the location of the Registry Key Profiles
$PathProfiles = "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList" 


## Identify the Temp Profiles that are in Need Of Repair
$BAKKeys = Get-ChildItem Registry::$PathProfiles | Where-Object {$_.Name -clike '*.bak'}
#Get-ChildItem Registry::$PathProfiles | Where-Object {$_.Name -clike '*.bak'} |ft PSChildName, Name


## If no Temp Profiles Found the server requires no Repairs
 If($BAKKeys -eq $null) 
    { 
        Write-Warning "This fix does not apply to this computer." 
    }Else 
    { 
    	
##  For Every Temp Profile Check for original key if It exist rename it to KEY.Temp and Rename KEY.BAK to the Original Key Name
        foreach($key in $BAKKeys) 
        { 
            $PathBAKKey = [ARRAY]$key.Name
            $NameBAKKey = [ARRAY]$key.PSChildName 
            $NameOriginalKey = [ARRAY]$NameBAKKey -replace '.bak' 
            $PathOriginalKey = [ARRAY]$PathBAKKey -replace '.bak' 
            #$PathTempKey = $PathOriginalKey.trim()+".temp" 
            #$NameTempKey = $NameOriginalKey.trim()+".temp" 
            $PathTempKey = [ARRAY]$PathBAKKey -replace '.bak','.temp'
            $NameTempKey = [ARRAY]$NameBAKKey -replace '.bak','.temp'  
            $TempKeyExists = Test-Path -Path Registry::$PathTempKey
            $OriginalKeyExists = Test-Path Registry::$PathOriginalKey
            $retry = 3 
            write-output "$NameBAKKey found path is $PathBAKKey"
            Write-output "$NameOriginalKey created in path $PathOriginalKey"
            write-output "Renamed $NameBAKKey to $NameTempKey in path $PathTempKey"
            
##  Remove Existing TEMP Keys            
            Do 
            { 
                if($TempKeyExists -eq $true) 
                { 
                    if ($rt -eq "Review")
                    	{
                    	Write-Host  "This Key, $PathTempKey ,  will be removed." -ForegroundColor Red
                    	
                    	}
                    else
                    	{
                    	write-host "Actually Remove the Existing Profile KEY.temp"
                    	Remove-Item -Path Registry::$PathTempKey -Force -Recurse -Confirm:$false 
                    	Start-Sleep -Seconds 1
                    	}
                     
                } 
                $TempKeyExists = Test-Path -Path Registry::$PathTempKey 
                $retry-- 


            }While(($TempKeyExists -eq $true) -and ($retry -gt 0)) 
 
 ##  If Original Key Exist  Rename the Key To KEY.TEMP
            if($OriginalKeyExists -eq $true) 
            { 
               if ($rt -eq "Review")
               {
               Write-Host "This is review mode and renames $PathOriginalKey  to  $NameTempKey" -ForegroundColor Green
               }
               else
               {
               	write-host "Actually Rename the actual key to KEY.temp"
               	Rename-Item -Path Registry::"$PathOriginalKey" -NewName "$NameTempKey" -Force 
                Start-Sleep -Seconds 1
               }
             } 



            if($TempKeyExists -eq $false) 
            { 
            	if ($rt -eq "Review")
               {
                Write-host "----------------------REVIEW--------------------------------"
                Write-Host "Renames $PathBAKKey  to  $NameOriginalKey" -ForegroundColor Green 
               }
               else 
               {
               	write-host "Renaming $PathBAKKey to $NameOriginalKey"
               	Rename-Item -Path Registry::"$PathBAKKey" -NewName "$NameOriginalKey" -Force 
                Start-Sleep -Seconds 1
               }
            } 

   
##  Verify the There are no more KEY.BAK(Temporary Profiles)  If no More Exist the fix Worked           
            $BAKKeyExist = Test-Path -Path Registry::$PathBAKKey 
            If($BAKKeyExist -eq $false) 
            { 
                Write-Host "This fix worked. Please, restart your computer." -ForegroundColor Green 
            } 
            Else
            { 
                Write-Warning "This fix has not worked. Do it manually." 
                Write-Warning ""
                Write-Warning "[INFO] SID : $PathBAKKey" 
            } 
            Write-Host 
        } 
    } 


} -argumentlist($rt) -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)




###################

##########get profile folder size#####################


$ErrorActionPreference = "SilentlyContinue"
$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password
$profilename = '$INPUT{PROFILENAME}'
[int]$profilesize = '$INPUT{PROFILESIZE}'
$rt = '$INPUT{RunType}'
#[int]$profilesizeview = '$INPUT{PROFILESIZEVIEW}'
#$rt

#[int]$profilesize = 2000

if($rt -eq 'Profile Size-View'){
Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {	
Param ($profilesize)
[System.String]$Path = 'C:\Users'

[PSCustomObject[]]$Output = @()


foreach ($Folder in (Get-ChildItem -Path $Path -Directory -Exclude *Public*, *Administrator*,*Svc*,*SQL*,*Repor*,*mss* ))
{
    [System.Int64]$Size = (Get-ChildItem -Path $Folder.FullName -Recurse -Force | Measure-Object -Property Length -Sum).Sum
    #[math]::Round($Size,2)
    [System.Collections.Hashtable]$Hashtable = @{
        'FolderName' = $Folder.Name
        #'Size(Bytes)' = $Size
        'Size(MB)' = [math]::Round($Size / 1MB,2)
        'Size(GB)' = [math]::Round($Size / 1GB,2)
        'FullPath' = $Folder.FullName
         'HostName'= $env:COMPUTERNAME
            }
    $Output += New-Object -TypeName 'PSCustomObject' -Property $Hashtable
}

$Output | Select-Object -Property 'FolderName','Size(MB)', 'Size(GB)', 'FullPath', 'HostName'|Sort-Object -Property 'Size(MB)' -Descending | Format-Table	

[PSCustomObject[]]$Output1 = @() 
 
 Write-host "More Than $profilesize  MB Profile Folder Size "`n  
	foreach($Out in $Output) {
	
	if($Out.'Size(MB)' -gt $profilesize){
	
	 	 
	[System.Collections.Hashtable]$Hashtable1 = @{
        'FolderName' = $Out.FolderName
        'Size(MB)' = $Out.'Size(MB)'
        'Size(GB)' = $Out.'Size(GB)'
        'FullPath' = $Out.FullPath
       
    } 
  $Output1 += New-Object -TypeName 'PSCustomObject' -Property $Hashtable1 
    } 	}

#$Output1 | Select-Object -Property 'FolderName','Size(MB)', 'Size(GB)', 'FullPath'|Sort-Object -Property 'Size(MB)', 'FolderName' | `    Format-Table
 $Output1 | Select-Object -Property 'FolderName','Size(MB)','FullPath'| Sort-Object -Property 'Size(MB)'-Descending| Format-Table  
 
 <#
 if ($Output1) {
 
 Write-host "Below Profile is Deleted More Than $profilesize " `n
  #$Output1.FullPath 	
    
  
    $profiledir1 = $Output1.FullPath

foreach ($profile in $profiledir1){

$profile
#Get-WmiObject -Class Win32_UserProfile | Where-Object {$_.LocalPath -eq $profile} |Select-Object LocalPath #| Remove-WmiObject
#Get-WmiObject -Class Win32_UserProfile | Where-Object {$_.LocalPath -eq $profile} | Remove-WmiObject
} }


else {write-host "Profile Not found more than $profilesize" }
#>

	
} -argumentlist($profilesize) 
}

elseif(($rt -eq 'Profile Size-Delete')){
Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {	
Param ($profilesize)
[System.String]$Path = 'C:\Users'

[PSCustomObject[]]$Output = @()


foreach ($Folder in (Get-ChildItem -Path $Path -Directory -Exclude *Public*, *Administrator*,*Svc*,*SQL*,*Repor*,*mss* ))
{
    [System.Int64]$Size = (Get-ChildItem -Path $Folder.FullName -Recurse -Force | Measure-Object -Property Length -Sum).Sum
    #[math]::Round($Size,2)
    [System.Collections.Hashtable]$Hashtable = @{
        'FolderName' = $Folder.Name
        #'Size(Bytes)' = $Size
        'Size(MB)' = [math]::Round($Size / 1MB,2)
        'Size(GB)' = [math]::Round($Size / 1GB,2)
        'FullPath' = $Folder.FullName
         'HostName'= $env:COMPUTERNAME
            }
    $Output += New-Object -TypeName 'PSCustomObject' -Property $Hashtable
}

$Output | Select-Object -Property 'FolderName','Size(MB)', 'Size(GB)', 'FullPath', 'HostName'|Sort-Object -Property 'Size(MB)' -Descending | Format-Table	

[PSCustomObject[]]$Output1 = @() 


 
 $profilesize
 Write-host "More Than $profilesize  MB Profile Folder Size "`n  
	foreach($Out in $Output) {
	
	if($Out.'Size(MB)' -gt $profilesize){
	
	 	 
	[System.Collections.Hashtable]$Hashtable1 = @{
        'FolderName' = $Out.FolderName
        'Size(MB)' = $Out.'Size(MB)'
        'Size(GB)' = $Out.'Size(GB)'
        'FullPath' = $Out.FullPath
       
    } 
  $Output1 += New-Object -TypeName 'PSCustomObject' -Property $Hashtable1 
    } 	}

#$Output1 | Select-Object -Property 'FolderName','Size(MB)', 'Size(GB)', 'FullPath'|Sort-Object -Property 'Size(MB)', 'FolderName' | `    Format-Table
 $Output1 | Select-Object -Property 'FolderName','Size(MB)','FullPath'| Sort-Object -Property 'Size(MB)'-Descending| Format-Table  
 
 if ($Output1) {
 
 Write-host "Below Profile is Deleted More Than $profilesize " `n
  #$Output1.FullPath 	
    
  
    $profiledir1 = $Output1.FullPath

foreach ($profile in $profiledir1){

$profile
#Get-WmiObject -Class Win32_UserProfile | Where-Object {$_.LocalPath -eq $profile} |Select-Object LocalPath #| Remove-WmiObject
#Get-WmiObject -Class Win32_UserProfile | Where-Object {$_.LocalPath -eq $profile} | Remove-WmiObject
} }


else {write-host "Profile Not found more than $profilesize" }


	
} -argumentlist($profilesize) 
}

elseif($profilename){
	
Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {
Param ($profilename)

$profilenamelist = $profilename.Trim() -split(',')
foreach ($profilename in $profilenamelist){

$LocalPath = 'C:\Users\'+$profilename.Trim() 

$Profiledel =Get-WMIObject -Class Win32_UserProfile | where{$_.LocalPath -eq $LocalPath}#| Select-Object LocalPath

if($Profiledel){
	
	
 write-host "Profile found and Deleted" $Profiledel.LocalPath
 #$Profiledel | Remove-WmiObject
}
else {
Write-host "Profile not Found" $LocalPath
}

}


} -argumentlist($profilename) 
} 



################################################

#######################VALIDATE PORT conn##############

$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$port = '$INPUT{PORT}'
$destination = '$INPUT{DESTINATION_HOSTNAME}'
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password



Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {

param($port, $destination)	
$PSVersionTable.PSVersion
	
if($PSVersionTable.PSVersion -le "6.0"){
	
	Write-Host "PSversion less than or equal to 6.0"
	
#	param($port, $destination)
	$connected = New-Object System.Net.Sockets.TcpClient -ArgumentList $destination, $port -ErrorVariable DNSError
	
	if ($DNSError)
	{
		Write-Host "Error: Unable to communicate to the Port"
	}
	
	if ($connected.Connected -eq $true)
	{
		Write-Host "Connected: Port Test Successful"
	}
}
	
	
elseif($PSVersionTable.PSVersion -gt "6.0"){
	
	Write-Host "PSversion Greater than or equal to 6.0"
	
	$PortCheck = Test-NetConnection '$INPUT{DESTINATION_HOSTNAME}' -port '$INPUT{PORT}' -InformationLevel "Detailed"
#    $PortCheck = Test-Connection '$INPUT{DESTINATION_HOSTNAME}' -port '$INPUT{PORT}' -InformationLevel "Detailed" gr
    $PortCheck
   

	if($PortCheck.tcptestsucceeded -eq "True"){

	Write-Host "TcpTestSucceeded : True"
	}
	else{
    Write-Host "Unable to connect to port"
  }
}

	
} -ArgumentList $port, $destination -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)


###########################

#############FETCH STORAGE LUN info#######

$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password

Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {
Set-PSDebug -Strict

Function Main {

    $diskdrives = get-wmiobject Win32_DiskDrive | sort Index

    $colSize = @{Name='Size';Expression={Get-HRSize $_.Size}}

    foreach ( $disk in $diskdrives ) {

        $scsi_details = 'SCSI ' + $disk.SCSIBus         + ':' +
                                  $disk.SCSILogicalUnit + ':' +
                                  $disk.SCSIPort        + ':' +
                                  $disk.SCSITargetID
        write $( 'Disk ' + $disk.Index + ' - ' + $scsi_details +
                 ' - ' + ( Get-HRSize $disk.size) )
       
        $ID        = get-disk $disk.index | select uniqueid
        

        $part_query = 'ASSOCIATORS OF {Win32_DiskDrive.DeviceID="' +
                      $disk.DeviceID.replace('\','\\') +
                      '"} WHERE AssocClass=Win32_DiskDriveToDiskPartition'

        $partitions = @( get-wmiobject -query $part_query | 
                         sort StartingOffset )
        foreach ($partition in $partitions) {

            $vol_query = 'ASSOCIATORS OF {Win32_DiskPartition.DeviceID="' +
                         $partition.DeviceID +
                         '"} WHERE AssocClass=Win32_LogicalDiskToPartition'
            $volumes   = @(get-wmiobject -query $vol_query)
            

            write $( '    Partition ' + $partition.Index + '  ' +
                     ( Get-HRSize $partition.Size) + '  ' +
                     $partition.Type
                       
                   )

            foreach ( $volume in $volumes) {
                write $( '        ' + $volume.name + 
                         ' [' + $volume.FileSystem + '] ' + 
                         ( Get-HRSize $volume.Size ) + ' ( ' +
                         ( Get-HRSize $volume.FreeSpace ) + ' free )'
                       )

            } # end foreach vol

        } # end foreach part

    write $('       ' + $ID )

        write ''
        
    } # end foreach disk

}

#--------------------------------------------------------------------
function Get-HRSize {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$True, ValueFromPipeline=$True)]
        [INT64] $bytes
    )
    process {
        if     ( $bytes -gt 1pb ) { "{0:N2} PB" -f ($bytes / 1pb) }
        elseif ( $bytes -gt 1tb ) { "{0:N2} TB" -f ($bytes / 1tb) }
        elseif ( $bytes -gt 1gb ) { "{0:N2} GB" -f ($bytes / 1gb) }
        elseif ( $bytes -gt 1mb ) { "{0:N2} MB" -f ($bytes / 1mb) }
        elseif ( $bytes -gt 1kb ) { "{0:N2} KB" -f ($bytes / 1kb) }
        else   { "{0:N} Bytes" -f $bytes }
    }
} # End Function:Get-HRSize

Main | Out-File .\diskwwn.txt


$data = Get-Content -Path  .\diskwwn.txt

$text = ($data) -join "`r`n"
($text | Select-String '(?s)(?<=\Disk )(.+?)(?=\})' -AllMatches).Matches | % {
        $text = $text.Replace($_.Value, ($_.Value -split "`r`n" | % { $_.Trim() }) -join " ")
          
        
}


        
        
        
        
$textfinder1 = "- SCSI"
$textfinder2 = " - "
$textfinder3 = "(?s)(?<=\$textfinder1)(.+?)(?=$textfinder2)"
$textfinder4 = "Partition"
$textfinder5 = "@{uniqueid="
$textfinder6 = "(?s)(?<=$textfinder4)(.+?)(?=$textfinder5)"



$text1 = ($text)  | foreach-Object {
  $_ -replace "$textfinder3", '' `
     -replace "," ,'' `
     -replace "$textfinder6", '' `
     -replace "- SCSI - ", ',' `
     -replace "Partition@{uniqueid=", ',' `
     -replace "", "" `
     -replace "}", '' `
     
     } 
     
#foreach ($line in $text1)

 
[array]$header = "Disk_Number,Size,PWWN"

$Arrrayofdisks = $header + $text1

$Servername = $env:computername

$whodidthat = $env:UserName

$thepath = (".\disk_numbers_pwwn_" + "$Servername" + "_" + "$whodidthat" + ".csv")

$Arrrayofdisks | Out-File (".\disk_numbers_pwwn_" + "$Servername" + "_" + "$whodidthat" + ".txt")

[array]$CSCcontent = gc (".\disk_numbers_pwwn_" + "$Servername" + "_" + "$whodidthat" + ".txt") | ? {$_.trim() -ne "" }

#write-host "Disk_Number,DriveLetter,Size,PWWN"
$finalmout=@()

$var4=($CSCcontent -replace "Disk","`r`nDisk").split("`r`n")
$var3=($text -replace "Disk","`r`nDisk").split("`r`n")

$diskseq=@()

foreach($v2 in $var3)
{
if($v2 -ne ""){
$disknumber=$v2.split("-")[0]
$diskletter=$v2.split(" ") -match "[A-Z]:"
$diskseq +="$disknumber,$diskletter"
}
}

foreach($v4 in $var4)
{
foreach($ds in $diskseq)
{
$temp=$ds.split(",")[0]
if($v4 -match $temp)
{
$finalmout += "$($Servername),$($V4 -replace "$temp","$ds")"
}
}
}
if($finalmout)
{
write-host "Details for" $Servername
#write-host "Disk_Number,DriveLetter,Size,PWWN"
$finalmout
}
else
{
write-host "No details found"
}






Remove-Item (".\disk_numbers_pwwn_" + "$Servername" + "_" + "$whodidthat" + ".txt") 

} -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)



################################

##############FETCH NIC INFO##############3

$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password

Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {
$info=Get-NetAdapterAdvancedProperty -DisplayName "Speed & Duplex" | Select Name, DisplayName, DisplayValue
$output=$NUll
$thishost=$env:COMPUTERNAME
foreach($ii in $info)
{
$nname=$ii.Name
$ndname=$ii.DisplayName
$ndvalue=$ii.DisplayValue
$output += "`r`n"
$output += "Fetchedinfo:$thishost,$nname,$ndname,$ndvalue"
}

Write-host "$output"

} -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)


######################

##########ESXI INVENTORY SC###############

Write-host "RS Remote:     $($env:computername)" 
if(!(Get-Module -Name VMware.VimAutomation.Core))
{
    Import-Module -Name VMware.VimAutomation.Core
    if(!$?){ throw "Could not load VMware.VimAutomation.Core" }
}
if(!(Get-Module -Name SqlServer))
{
    Import-Module -Name SqlServer
    if(!$?){ 
        Install-Module -Name SqlServer -ErrorAction SilentlyContinue -AllowClobber
        throw "Could not load SQL Module" 
     }
}
#Declaration of the variables
[ValidateNotNullOrEmpty()]
$varPassword                        =   ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$varUsername                =  '$INPUT{USERNAME}'

[ValidateNotNullOrEmpty()]
$VarVcenter                         =  '$INPUT{VCENTERSERVER}'

#Credentials
$varCredentials                     =  New-Object System.Management.Automation.PSCredential($varUsername, $varPassword )
$VarVcenter                         =  $VarVcenter.trim()
$connectedServer                    = $global:defaultviserver
$vcentercsv = "d:\" + $VarVcenter + ".csv"
$DB_TABLE         = '$INPUT{DB_TABLE}' # "[test].[test].[TEST_ESXI_INVEN_TBL]"
$DB_USERNAME      = '$INPUT{DB_USERNAME}'
$DB_USER_PASSWORD = '$INPUT{DB_PASSWORD}'
$DB_HOST          = '$INPUT{DB_HOST}'
$DB_DATABASE = '$INPUT{DB_INSTANCE}'
#Prepared statement for the insert
$insertSQL = @'
EXEC [Automation].[dbo].[sp_ESXI_Host_Insert]
             @HostName = N'{0}',
             @ConnectionState = N'{1}',
             @PowerState = N'{2}',
             @vCenter = N'{3}',
             @vCenterVersion = N'{4}',
             @DataCenter = N'{5}',
             @ClusterName = N'{6}',
             @ESXVersion = N'{7}',
             @ESXBuild = N'{8}',
             @Vendor = N'{9}',
             @Model = N'{10}',
             @UpTimeDays = N'{11}',
			 @InMaintenancemode = N'{12}',
             @Boot_Time = N'{13}',
             @Reboot_Required = N'{14}',
             @Overall_Status = N'{15}',
             @vCenterBuild = N'{16}'     
'@
#Function Definitions
#This funtion is to Disconnect the Vcenter Server
function DisconnectVcenter ([string] $vCenter){
    # Disconnect from the current vCenter    
    Try{
        DisConnect-VIServer $vCenter -Confirm:$false  -Force  -ErrorAction Stop
        Write-host   "------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
        Write-Output "Disconnected from $vCenter"
        }
    catch{
        Write-output "Host is already Disconnected"
        Write-host   "------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
    }     
}
function CollectHostDetails($vmHost){
    $vmhostresult = $vmhost |
        select Name,
        @{N='ESXiVersion';E={$_.config.Product.Version}}, 
        @{N='ESXiBuild';E={$_.config.Product.Build}},
        @{N='Cluster';E={
            $parent = Get-View -Id $_.Parent -Property Name, Parent
            while ($parent -isnot [VMware.Vim.ClusterComputeResource] -and $parent.Parent){
                $parent = Get-View -Id $parent.Parent -Property Name, Parent
            }
            if ($parent -is [VMware.Vim.ClusterComputeResource]){
                $parent.Name
            }}},
        @{N='ConnectionState';E={$_.runtime.ConnectionState}},
        @{N='PowerState';E={$_.runtime.PowerState}},
        @{N='InMaintenanceMode';E={$_.runtime.InMaintenanceMode}},
        @{N='BootTime';E={$_.runtime.BootTime}},
        @{N="UptimeDays";E={[math]::round((((Get-Date) - ($_.runtime.BootTime)).TotalDays),1)}},
        @{N='OverallStatus';E={$_.summary.OverallStatus}},
        @{N='RebootRequired';E={$_.summary.RebootRequired}},
        @{N='HardwareVendor';E={$_.hardware.SystemInfo.Vendor}},
        @{N='HardwareModel';E={$_.hardware.SystemInfo.Model}},
        @{N='DataCenter';E={    
            $parentObj = Get-View $_.Parent
            while($parentObj -isnot [VMware.Vim.Datacenter]){
                $parentObj = Get-View $parentObj.Parent -Property Parent, Name
            }
            $parentObj.Name
            }},
        @{N='vCenterName';E={($global:DefaultVIServer.Name)}},
        @{N='vCenterVersion';E={($global:DefaultVIServer.Version)}},
        @{N='vCenterBuild';E={($global:DefaultVIServer.Build)}}
        return $vmhostresult
}
function BuildUpdateStatement($vmDetails) {
    return "UPDATE $DB_TABLE SET 
            HostName = '$($vmDetails.Name)', 
            ConnectionState = '$($vmDetails.ConnectionState)', 
            PowerState = '$($vmDetails.PowerState)', 
            vCenter = '$($vmDetails.vCenterName)', 
            vCenterVersion = '$($vmDetails.vCenterVersion)', 
            DataCenter = '$($vmDetails.DataCenter)', 
            ClusterName = '$($vmDetails.Cluster)', 
            ESXVersion = '$($vmDetails.ESXiVersion)', 
            ESXBuild = '$($vmDetails.ESXiBuild)', 
            Vendor = '$($vmDetails.HardwareVendor)', 
            Model = '$($vmDetails.HardwareModel)', 
            UpTimeDays = '$($vmDetails.UptimeDays)', 
            Executed_date = '$(get-date)', 
            InMaintenancemode = '$($vmDetails.InMaintenanceMode)', 
            Boot_Time = '$($vmDetails.BootTime)', 
            Reboot_Required = '$($vmDetails.RebootRequired)', 
            Overall_Status = '$($vmDetails.OverallStatus)', 
            vCenterBuild = '$($vmDetails.vCenterBuild)' 
        where HostName = '$($vmDetails.Name)'"
}
function BuildUpdatePatchStatement($patchedHost, $patchedUser, $patchedChange) {
#[Submited_by]
#[Updated_timestamp]
#[Change_number]
    return "UPDATE $DB_TABLE SET 
            Submited_by = '$patchedUser',
            Updated_timestamp = '$(get-date)',
            Change_number = '$patchedChange' 
        where HostName = '$patchedHost'"
}

	
#This function is for establishing the Connection the Vcenter Server
function ConnectVcenter([string]$vCenter ){
	
        # Connect to the vCenter get the needed hashed credentails 
        try{
			Connect-VIServer -Server $Vcenter -credential $varCredentials -ea Stop
		}
		catch {
			[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls
			try{
				Connect-VIServer -Server $Vcenter -credential $varCredentials -ea Stop
			}
			catch {
				Write-host "Connectivity Issue with the vcenter Server $($Vcenter)"
			}
		}        
        Write-Output "Connected to $vcenter"
       
}


function Build-hostReport(){
    try{
    	
	    $vmhosts  =  Get-View -ViewType HostSystem -ea stop
	    $conn = Test-NetConnection $DB_HOST -Port 1433
	   	if ($conn.TcpTestSucceeded -eq 'True'){
	        #Interate through each host 
	        
	    ForEach ($vmhost in $vmhosts){
	    	$vmDetails = CollectHostDetails -vmHost $vmhost 
	    	$selectSQL = "SELECT count(*) as count from $DB_TABLE WITH (NOLOCK) where HostName = '$($vmDetails.Name)'"
	    	$vmExist = Invoke-Sqlcmd -Query $selectSQL -ServerInstance $DB_HOST -Username $DB_USERNAME -Password $DB_USER_PASSWORD
	        $insertSQLCMD = $insertSQL -f $vmDetails.Name, $vmDetails.ConnectionState, $vmDetails.PowerState, $vmDetails.vCenterName, $vmDetails.vCenterVersion, $vmDetails.DataCenter, $vmDetails.Cluster, $vmDetails.ESXiVersion, $vmDetails.ESXiBuild, $vmDetails.HardwareVendor, $vmDetails.HardwareModel, $vmDetails.UptimeDays, $vmDetails.InMaintenanceMode, $vmDetails.BootTime, $vmDetails.RebootRequired, $vmDetails.OverallStatus, $vmDetails.vCenterBuild
	        #Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -Username $DB_USERNAME -Password $DB_USER_PASSWORD -ErrorAction Stop
	        if ($vmExist.Count -ge 1){
	            Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -Username $DB_USERNAME -Password $DB_USER_PASSWORD -ErrorAction Stop
	            #Write-Host $insertSQLCMD
	            Write-Host "Updated existing host: $($vmDetails.Name)"
	        } else {
	            Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -Username $DB_USERNAME -Password $DB_USER_PASSWORD -ErrorAction Stop
	            #Write-Host $insertSQLCMD
	            Write-Host "Inserted new host: $($vmDetails.Name)"
	        } 
	                 
	        
	    }
    }  
		 else {    
		    #write-host "DB failed"
		    ForEach ($vmhost in $vmhosts){
		    	#WRITE-HOST "HA YOU ARE ACTUALLY HERE"
		    	$vmDetails = CollectHostDetails -vmHost $vmhost  
		    	[string]$value = "|"+$vmDetails.name+","+$vmDetails.ConnectionState+","+$vmDetails.PowerState+","+$vmDetails.vCenterName+","+$vmDetails.vCenterVersion+","+$vmDetails.DataCenter+","+$vmDetails.Cluster+","+$vmDetails.ESXiVersion+","+$vmDetails.ESXiBuild+","+$vmDetails.HardwareVendor+","+$vmDetails.HardwareModel+","+$vmDetails.UptimeDays+","+(get-date)+","+$vmDetails.InMaintenanceMode+","+$vmDetails.BootTime+","+$vmDetails.RebootRequired+","+$vmDetails.OverallStatus+","+$vmDetails.vCenterBuild+"|"#$dataout += $vmDetails
		       	$final += $value
		       	}
		    write-host "Feth=$final"
		 } 
    }
    catch{
    	Write-host "Check connectivity to the vcenter server"
    	}
    
}


function UpdatePatchedServers($patchedServers) {
    foreach($patchedServer in $patchedServers)
    {   
        $vmhost  =  Get-View -ViewType HostSystem -Filter @{"Name" = "$($patchedServer.Host)"}
        $vmDetails = CollectHostDetails -vmHost $vmhost
        $selectSQL = "SELECT count(*) as count from $DB_TABLE WITH (NOLOCK) where HostName = '$($patchedServer.Host)'"
        $vmExist = Invoke-Sqlcmd -Query $selectSQL -ServerInstance $DB_HOST -Username $DB_USERNAME -Password $DB_USER_PASSWORD
        #If Host exist we update values else INSERT
        if ($vmExist.Count -ge 1){
            $updateSQL = BuildUpdateStatement -vmDetails $vmDetails
            #Update existing host entry in database
            UpdateHost -updateSQL $updateSQL -vmName $($patchedServer.Host)
            $updateSQL2 = BuildUpdatePatchStatement -patchedHost $($patchedServer.Host) -patchedUser $($patchedServer.User) -patchedChange $($patchedServer.Change) 
            UpdateHost -updateSQL $updateSQL2 -vmName $patchedHost
        }
    }          
}
 
# Check to see if already connected and Disconnect any leftover connections before starting script.
If($null -eq $connectedServer){
    Try{
        DisConnect-VIServer -server * -Confirm:$false -Force
    }
    catch {
        Write-Host "No Acive Session Found"
        Write-host   "------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
    }
}
 
# Call connect vCenter function
if ($VarVcenter -eq 'VC1' -or $VarVcenter -eq 'VC2' -or $VarVcenter -eq 'VC3' -or $VarVcenter -eq 'VC4' -or $VarVcenter -eq 'VC5')
{
Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false | Out-Null
}
$connected = ConnectVcenter -vCenter $VarVcenter   
if($connected){
    #Call report for given vCenter function
    Build-hostReport -vCenter $VarVcenter
    if ($updatePatch -eq "YES")
    {
        $pathcsv = Import-Csv C:\AutomationReport\phase2-import.csv.txt -Header Host, User, Change
        UpdatePatchedServers -patchedServers $pathcsv
    }
    #call disconnect function to ensure only one connect to a vcenter
    DisconnectVcenter -vCenter  $VarVcenter
    }
    

#################################

#################ESXI INVENTORY RUN ON JUMP SERVER##############


Write-Host "Connected to RM Server :  $($env:computername)"
Write-Host "----------------------X-----------------------"
if(!(Get-Module -Name SqlServer))
{
    Import-Module -Name SqlServer
    if(!$?){ 
        Install-Module -Name SqlServer -ErrorAction SilentlyContinue -AllowClobber
        throw "Could not load SQL Module" 
     }
}

$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password

$source = '$INPUT{COMPUTERNAME}'

try {

	$csvpath = Invoke-Command -ComputerName $source -Credential $credential -Scriptblock {
		
		get-content "C:\Windows\Logs\PPP\Esxi_inventory_Report\InventoryReport_upload.csv" | Convertfrom-Csv	
		clear-content "C:\Windows\Logs\PPP\Esxi_inventory_Report\InventoryReport_upload.csv"
		
	} -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck -ProxyAccessType NoProxyServer) -EA Stop
}
catch{
	Write-host "Error Connecting to $($source) "
	}
if (!$csvpath)
{
	write-host "No data found"
}
else
{
write-host "DATA FETCHED"	

[Array]$HOSTSCSV = $csvpath
$DB_TABLE         = '$INPUT{DB_TABLE}' 
$DB_USERNAME      = '$INPUT{DB_USERNAME}'
$DB_USER_PASSWORD = '$INPUT{DB_PASSWORD}'
$DB_HOST          = '$INPUT{DB_HOST}'
$DB_DATABASE = '$INPUT{DB_INSTANCE}'
#Prepared statement for the insert
$insertSQL = @'
EXEC [Automation].[dbo].[sp_VMWare_Host_Insert]
             @HostName = N'{0}',
             @ConnectionState = N'{1}',
             @PowerState = N'{2}',
             @vCenter = N'{3}',
             @vCenterVersion = N'{4}',
             @DataCenter = N'{5}',
             @ClusterName = N'{6}',
             @ESXVersion = N'{7}',
             @ESXBuild = N'{8}',
             @Vendor = N'{9}',
             @Model = N'{10}',
             @UpTimeDays = N'{11}',
			 @InMaintenancemode = N'{12}',
             @Boot_Time = N'{13}',
             @Reboot_Required = N'{14}',
             @Overall_Status = N'{15}',
             @vCenterBuild = N'{16}'     
'@

	
function Build-hostReport(){
    ForEach ($vmDetails in $HOSTSCSV){
	if($vmDetails -ne ""){
	    $selectSQL = "SELECT count(*) as count from $DB_TABLE WITH (NOLOCK) where HostName = '$($vmDetails.Name)'"
    	$vmExist = Invoke-Sqlcmd -Query $selectSQL -ServerInstance $DB_HOST -Username $DB_USERNAME -Password $DB_USER_PASSWORD
        $insertSQLCMD = $insertSQL -f $vmDetails.Name, $vmDetails.ConnectionState, $vmDetails.PowerState, $vmDetails.vCenterName, $vmDetails.vCenterVersion, $vmDetails.DataCenter, $vmDetails.Cluster, $vmDetails.ESXiVersion, $vmDetails.ESXiBuild, $vmDetails.HardwareVendor, $vmDetails.HardwareModel, $vmDetails.UptimeDays, $vmDetails.InMaintenanceMode, $vmDetails.BootTime, $vmDetails.RebootRequired, $vmDetails.OverallStatus, $vmDetails.vCenterBuild
        if ($vmExist.Count -ge 1){
            Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -Username $DB_USERNAME -Password $DB_USER_PASSWORD -ErrorAction Stop
            #Write-Host $insertSQLCMD
            Write-Host "Updated existing host: $($vmDetails.Name)"
        } else {
            Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -Username $DB_USERNAME -Password $DB_USER_PASSWORD -ErrorAction Stop
            #Write-Host $insertSQLCMD
            Write-Host "Inserted new host: $($vmDetails.Name)"
        } 
          
    }
    
    }  
  
}
 
Build-hostReport

}

###################################

########################ESXI host compliance report sc##############

if(!(Get-Module -Name VMware.VimAutomation.Core))
{
    Import-Module -Name VMware.VimAutomation.Core

    if(!$?){ throw "Could not load VMware.VimAutomation.Core" }
}
#$ErrorActionPreference = "SilentlyContinue"
#$WarningPreference = 'silentlycontinue'
#Declaration of the variables

[ValidateNotNullOrEmpty()]
$varPassword                        =   ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$varUsername                =  '$INPUT{USERNAME}'

[ValidateNotNullOrEmpty()]
$VarVcenter                         =  '$INPUT{VCENTERSERVER}'

#Credentials
$VarVcenter                         =  $VarVcenter.trim()
$dateX                              =  get-date -format "yyyy-MM-dd"
$VerifyPath                         =  'c:\temp\HostComplaince' 
$ConsolidatedFile                   =  "c:\temp\HostComplaince\ESXi-Complaince-Consolidated.csv"
$connectedServer                    =  $global:defaultviserver
$allLines =@()

#Function Definitions
#This funtion is to Disconnect the Vcenter Server
function DisconnectVcenter ([string] $vCenter){
    # Disconnect from the current vCenter    
    Try{
        DisConnect-VIServer $vCenter -Confirm:$false  -Force  -ErrorAction Stop
        Write-Output "Disconnected from $vCenter"
        }
    catch{
        Write-output "Host is already Disconnected"
    }     
}
#This funtion is for retriving the NTP Status

function Get-HostNTPStatus([string] $VMhost){
   $ntpRunning = Get-View -ViewType HostSystem | Where {$_.name -eq $vmhost.name} | Select-Object @{N="ServiceRunning";E={(Get-VmHostService -VMHost $PSItem | Where-Object {$PSItem.key -eq "ntpd"}).Running}}
   return $ntpRunning
}

#This function is for establishing the Connection the Vcenter Server
function ConnectVcenter([string]$vCenter ){
	try{
        # Connect to the vCenter get the needed hashed credentails 
        Connect-VIServer  -Server $Vcenter  -ErrorAction Stop
        Write-Output "Connected to $vcenter"
	}
	catch {
		Write-host "Unable to reach the vCenter Server" $vcenter
	}
}

#This funtion is for the retriving the Power Status
#Dependencies for this function is $VMHost
function Get-PowerManagement([string] $VMhost){
    $PowerManagement =  Get-View -ViewType HostSystem | Where {$_.name -eq $vmhost} |  Sort-Object | Select-Object Name, 
    @{ N="CurrentPolicy"; E={$PSItem.config.PowerSystemInfo.CurrentPolicy.ShortName}},
    @{ N="CurrentPolicyKey"; E={$PSItem.config.PowerSystemInfo.CurrentPolicy.Key}},
    @{ N="AvailablePolicies"; E={$PSItem.config.PowerSystemCapability.AvailablePolicy.ShortName}}
    Return $PowerManagement 
}


function Test-WebServerSSL {
[CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
        [string]$URL,
        [Parameter(Position = 1)]
        [ValidateRange(1,65535)]
        [int]$Port = 443,
        [Parameter(Position = 2)]
        [Net.WebProxy]$Proxy,
        [Parameter(Position = 3)]
        [int]$Timeout = 15000,
        [switch]$UseUserContext
    )
 @"
using System;
using System.Net;
using System.Security.Cryptography.X509Certificates;
namespace PKI {
    namespace Web {
        public class WebSSL {
            public Uri OriginalURi;
            public Uri ReturnedURi;
            public X509Certificate2 Certificate;
            //public X500DistinguishedName Issuer;
            //public X500DistinguishedName Subject;
            public string Issuer;
            public string Subject;
            public string[] SubjectAlternativeNames;
            public bool CertificateIsValid;
            //public X509ChainStatus[] ErrorInformation;
            public string[] ErrorInformation;
            public HttpWebResponse Response;
        }
    }
}
"@
    $ConnectString = "https://$url`:$port"
    $WebRequest = [Net.WebRequest]::Create($ConnectString)
    $WebRequest.Proxy = $Proxy
    $WebRequest.Credentials = $null
    $WebRequest.Timeout = $Timeout
    $WebRequest.AllowAutoRedirect = $true
    [Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}
    try {$Response = $WebRequest.GetResponse()}
    catch {}
    if ($WebRequest.ServicePoint.Certificate -ne $null) {
        $Cert = [Security.Cryptography.X509Certificates.X509Certificate2]$WebRequest.ServicePoint.Certificate.Handle
        try {$SAN = ($Cert.Extensions | Where-Object {$_.Oid.Value -eq "2.5.29.17"}).Format(0) -split ", "}
        catch {$SAN = $null}
        $chain = New-Object Security.Cryptography.X509Certificates.X509Chain -ArgumentList (!$UseUserContext)
        [void]$chain.ChainPolicy.ApplicationPolicy.Add("1.3.6.1.5.5.7.3.1")
        $Status = $chain.Build($Cert)
        $ConnectionInformation = New-Object PSObject -Property ([Ordered]@{ 
             OriginalUri = $ConnectString; 
             ReturnedUri = $Response.ResponseUri; 
             Certificate = [Security.Cryptography.X509Certificates.X509Certificate2]$WebRequest.ServicePoint.Certificate; 
             Issuer      = $WebRequest.ServicePoint.Certificate.Issuer; 
             Subject     = $WebRequest.ServicePoint.Certificate.Subject; 
             SubjectAlternativeNames = $SAN; 
             CertificateIsValid = $Status; 
             Response    = $Response; 
             ErrorInformation = $chain.ChainStatus | ForEach-Object {$_.Status} 
         })
         $ConnectionInformation.PSObject.TypeNames.Add("Indented.LDAP.ConnectionInformation")
         $ConnectionInformation
        }
        $chain.Reset()
        [Net.ServicePointManager]::ServerCertificateValidationCallback = $null
    } 

#BUILD 
function Build-hostReport ([string]$vCenter){
        #  nested ForEach Loops to loop through needed objects and gather the data.
            $allLines = @()
         	$vCenter  =  $vCenter.trim()
            $vmhosts  =  Get-View -ViewType HostSystem | Where-Object {$PSitem.runtime.ConnectionState -eq 'Connected'} 
            # Get the Datacenters for the vCenter
            ForEach ($vmhost in $vmhosts){
            Write-host ${$vmhost.name}
            $startTime = Get-date

            #Create the first row and the Column Headers
                $VarVMhost = Get-View -ViewType HostSystem | Where {($_.name -eq $vmhost.name)  -and ($PSitem.runtime.ConnectionState -eq 'Connected')} | Select-Object -Unique 
                Set-PowerCLIConfiguration -WebOperationTimeoutSeconds -1 -Confirm:$false -ErrorAction SilentlyContinue | out-null
                $VCVer          = $VarVMhost | Select-Object Name,@{n= "Version";e={$_.Config.Product.Version}},@{N="vCenter";E={$PSItem.CLient.ServiceUrl.Split('/')[2]}}
                $ServiceTag     = $VarVMhost | Select-Object name, @{N="Serial" ; E= { $PSItem.Summary.Hardware.OtherIdentifyingInfo | where {$PSItem.IdentifierType.Key -eq "ServiceTag" } | % { $PSItem.IdentifierValue }  } }         
                $HostNTPRusnning = $VarVMhost | select Name -ExpandProperty Name| Select-Object @{N= "ServiceRunning";E={(Get-VmHostService -VMHost $PSItem |Where-Object {$PSItem.key -eq "ntpd"}).Running}} 
                $NTPServers     = Get-VMHostNtpServer -VMHost $vmhost.name
                $HostUptime     = $VarVMhost |Select-Object @{N="Uptime"; E={New-Timespan -Start $PSItem.Summary.Runtime.BootTime -End (Get-Date) | Select days -ExpandProperty  days}}
               
                #Get ESXi Power Management Settings
                $ESXiPowerManagement = Get-PowerManagement -VMhost $vmhost.name
                
                #Get ESXi Host DNS info
                $DNS  =  Get-VMHostNetwork -VMHost $vmhost.Name | Select-Object Hostname,DNSAddress
                
				#License Manager                
                $LicenseManager = Get-View LicenseManager
                $LicenseManagerAssign = Get-View $LicenseManager.LicenseAssignmentManager
                $VMhostID = $VMHost.Config.Host.Value
                $VMHostLicInfo = $LicenseManagerAssign.QueryAssignedLicenses($VMhostID)
                $VMHostLicInfo.assignedLicense.licensekey  | Select -Unique | out-null
                $CertHost = $vmhost.name
                # Check for Host Certificates 
                $Certificates  = Test-WebServerSSL -URL $vmhost.Name -ea SilentlyContinue | where {$psitem.OriginalUri  -ne $null}|  Select-Object OriginalURi, CertificateIsValid, Issuer, @{N="Expires";E={$PSItem.Certificate.NotAfter} }, @{N="DaysTillExpire";E={(New-TimeSpan -Start (Get-Date) -End ($PSItem.Certificate.NotAfter)).Days} }
                $CertCheck     = $Certificates | Where-Object {$PSItem.daystillexpire -lt "90" -or $PSItem.CertificateIsValid -ne "True"} |select -Unique | Sort-Object daystillexpire -Descending
                $cluster1      = (get-cluster -VMHost $vmhost.name).name  | Select-Object -Unique
                $datacenter1   = (Get-Datacenter -VMHost $vmhost.name).name | Select-Object -Unique
                $counter       = (Get-VMHost $vmhost.name | get-VM).Count
                $report        = @()
                $NTPTest       = Get-HostNTPStatus -VMhost $vmhost.name | Select-Object  @{N="NTPServer";E={Get-VMHostNtpServer $vmhost.name }} | Select-Object -Unique
                $Proc          =[ordered] @{
                                    VMHost          = $vmhost.name
                                    ConnectionState = $vmhost.Runtime.ConnectionState
                                    PowerState      = $vmhost.Runtime.PowerState
                                    vCenter         = $vCenter
                                    vCenterVersion  = ($global:DefaultVIServers).Version
                                    DataCenter      = $datacenter1
                                    ClusterName     = $cluster1
                                    Version         = $VMhost.Config.Product.version
                                    Build           = $VMhost.Config.Product.build
                                    Vendor          = $VMhost.Summary.Hardware.vendor
                                    Model           = $VMhost.Summary.Hardware.model
                                    CpuModel        = $VMhost.Summary.Hardware.CpuModel
                                    ServiceTag      = $ServiceTag.Serial[0]+ "/"+$ServiceTag.Serial[1]
                                    MemorySizeGB    = "{0:N0}" -f ($vmhost.Summary.Hardware.MemorySize/1GB)
                                    MemoryUsageGB   = "{0:N2}" -f ($vmhost.Summary.QuickStats.OverallMemoryUsage /1024)
                                    NumCpuPkgs      = $VMhost.Summary.Hardware.NumCpuPkgs
                                    CoresPerSocket  = ($VMhost.Summary.Hardware.NumCpuCores/$VMhost.Summary.Hardware.NumCpuPkgs)
                                    NumCpuCores     = $VMhost.Summary.Hardware.NumCpuCores
                                    CPUSpeedGhz     = "{0:N2}" -f ($vmhost.Summary.Hardware.CpuMhz/1000)
                                    EVCMode         = $vmhost.Summary.CurrentEVCModeKey
                                    MaxEVC          = $vmhost.Summary.MaxEVCModeKey
                                    CpuTotalMhz     = "{0:N2}" -f ($vmhost.Summary.hardware.CpuMhz /1000)
                                    CpuUsageMhz     = $vmhost.Summary.QuickStats.OverallCpuUsage
                                    LicenseKey      = $VMHostLicInfo.assignedLicense.licensekey  | Select -Unique
                                    isNTPRunning    = $HostNTPRunning.ServiceRunning
                                    NTPServers      = $NTPServers -join ','
                                    UpTimeDays      = $HostUptime.uptime
                                    NumVMs          = $counter
                                    PowerManagementPolicy = $ESXiPowerManagement.CurrentPolicy
                                    AvailablePowerManagePolicy = $ESXiPowerManagement.AvailablePolicies
                                    DNSServers      = $DNS.DNSAddress[0] + "," + $DNS.DNSAddress[1]
                                    OriginalURi     = $Certificates.OriginalURi
                                    CertIssuer      = $Certificates.Issuer
                                    CertIsValid     = $CertCheck.CertificateIsValid
                                    CertExpires     = $Certificates.Expires
                                    DaysToExpire    = $CertCheck.daystillexpire 
                            }

               $endTime   = get-date 
               Write-output "$CertHost :   Started at $startTime and ended at $endTime"
               $report    = [pscustomobject]$Proc
               $allLines += $Report
            }
            $allLines | Export-Csv $ConsolidatedFile   -NoTypeInformation -Append
}
# Check to see if already connected and Disconnect any leftover connections before starting script.
If($null -eq $connectedServer){
	Try{
        DisConnect-VIServer -server * -Confirm:$false -Force
	}
	catch {
	}
 }
# Loop through all the vCenters in the array above, log in and create report 1 at a time.
# Setting file name and the full file path so it has the vCenter name in it.
# Test to see if directory exists with date, if not create it.

If(!(test-path $VerifyPath)){
    New-Item -ItemType Directory -Force -Path $VerifyPath
}  
# Call connect vCenter function
   $connected = ConnectVcenter -vCenter $VarVcenter   
   if($connected){
	   #Call report for given vCenter function
	   Build-hostReport -vCenter $VarVcenter   

	   #call disconnect function to ensure only one connect to a vcenter
	   DisconnectVcenter -vCenter  $VarVcenter   
   }


############################

##############VM SNAPSHOT delete#############

$ErrorActionPreference = "SilentlyContinue"
try
{
	if(!(Get-Module -Name VMware.VimAutomation.Core))
	{
    	Import-Module -Name VMware.VimAutomation.Core
    	
    	if(!$?){ throw "Could not load VMware.VimAutomation.Core" }  
    }

	[ValidateNotNullOrEmpty()]
	$USER_PASSWORD = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
	
	[ValidateNotNullOrEmpty()]
	$USERNAME = '$INPUT{USERNAME}'

	[ValidateNotNullOrEmpty()]
	$HOST = '$INPUT{HOSTNAME}'

	$CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )

    $SRV = Connect-VIServer -Server $HOST -Credential $CREDENTIALS -WarningAction SilentlyContinue -ErrorAction Stop
    
     $day = '$INPUT{DAYS}'	
     $days = '-' + $day
     
     #$day = if($days) ? $days : '-2'
     if($day){
     	$numOfDays = (Get-Date).AddDays($days)
     	write-host "Days before to delete = $days"
     }
     else{
     	#$days = '-' + '5'
     	$numOfDays = (Get-Date).AddDays(-5)
     	write-host "Days before to delete = -5"
     }
    $CustomObject = @()
    $result = @()
    
	if(Get-Command ConvertTo-Json -CommandType Cmdlet -ErrorAction SilentlyContinue)
	{
		Get-VM -name * -Server $SRV | Foreach-Object { 

             $vmname = $_.Name 

             Get-Snapshot -VM $_ | where-object {$_.Name -notmatch ("GX_BACKUP") -and $_.Name -notmatch ("bypass") -and $_.name -notmatch ("NBU") -and $_.name -notmatch ("Avamar") } | Foreach-Object { 

                    if($_.Created -lt $numOfDays)  

                    {
                    $vmname = $vmname
					$snapshot = $_
					$Description = $_.Description
					$Created = $_.Created
					$PowerState = $_.PowerState
					$VM = $_.VM
					$SizeMB = [math]::Round($_.SizeMB,2)
					$props = @{
					  VMname = $vmname
					  Snapshot = $snapshot
					  Description = $Description
					  Created = $Created
					  PowerState = $PowerState
					  VM = $VM
					  SizeMB = $SizeMB
					}
					$ServiceObject = New-Object -TypeName PSObject -Property $props
					$CustomObject += $ServiceObject
					Remove-Snapshot $_ -Confirm -WhatIf
					Remove-Snapshot $_ -confirm:$false
                    }
             }
       } | ConvertTo-Json -Compress
       
       $programlist = $CustomObject | Select VMname,Snapshot,Description,Created,PowerState,VM,SizeMB
       if($programlist){
       	write-host "The below snapshots are removed"
        foreach($program in $programlist){
		$VMname = $program.VMname -replace ",",""
		$Snapshot = $program.Snapshot -replace ",",""
		$Description = $program.Description -replace ",",""
		$Description = $Description.replace("`n","-").replace("`r","-")
		$Created = $program.Created -replace ",",""
		$PowerState = $program.PowerState -replace ",",""
		$VM = $program.VM -replace ",",""
		$SizeMB = $program.SizeMB -replace ",",""

		$pgmList = $HOST +  "," + $VM + "," + $snapshot + "," + $Description + "," + $Created + "," + $PowerState + "," + $SizeMB
		write-host $pgmList
		}
		$count = $CustomObject.count
		write-host "$HOST - Snapshot count = $count"
       }
		else{
			write-host "There is no snapshot to delete for this following VCenter $HOST"
		}
	   #Write-Host $CustomObject
	}
	else
	{
		Get-VM -name * -Server $SRV | Foreach-Object { 

             $vmname = $_.Name 

             Get-Snapshot -VM $_ | where-object {$_.Name -notmatch ("GX_BACKUP") -and $_.Name -notmatch ("bypass") -and $_.name -notmatch ("NBU") -and $_.name -notmatch ("Avamar") } | Foreach-Object { 

                    if($_.Created -lt $numOfDays)  

                    {
                    $vmname = $vmname
					$snapshot = $_
					$Description = $_.Description
					$Created = $_.Created
					$PowerState = $_.PowerState
					$VM = $_.VM
					$SizeMB = [math]::Round($_.SizeMB,2)
					$props = @{
					  VMname = $vmname
					  Snapshot = $snapshot
					  Description = $Description
					  Created = $Created
					  PowerState = $PowerState
					  VM = $VM
					  SizeMB = $SizeMB
					}
					$ServiceObject = New-Object -TypeName PSObject -Property $props
					$CustomObject += $ServiceObject
					Remove-Snapshot $_ -Confirm -WhatIf
					Remove-Snapshot $_ -confirm:$false
                    }
             } 

       }
		$programlist = $CustomObject | Select VMname,Snapshot,Description,Created,PowerState,VM,SizeMB
		if($programlist){
		write-host "The below snapshots are removed"
        foreach($program in $programlist){
		$VMname = $program.VMname -replace ",",""
		$Snapshot = $program.Snapshot -replace ",",""
		$Description = $program.Description -replace ",",""
		$Description = $Description.replace("`n","-").replace("`r","-")
		$Created = $program.Created -replace ",",""
		$PowerState = $program.PowerState -replace ",",""
		$VM = $program.VM -replace ",",""
		$SizeMB = $program.SizeMB -replace ",",""

		$pgmList = $HOST +  "," + $VM + "," + $snapshot + "," + $Description + "," + $Created + "," + $PowerState + "," + $SizeMB
		write-host $pgmList
		}
		$count = $CustomObject.count
		write-host "$HOST - Snapshot count = $count"
		}
		else{
			write-host "There is no snapshot to delete for this following VCenter $HOST"
		}
	}
	#echo $result
} 
catch [VMware.VimAutomation.ViCore.Types.V1.ErrorHandling.InvalidLogin]
{
	Write-Output "RS_ERROR: Invalid Login: $Error"
}
catch
{
    Write-Output "RS_ERROR: PowerShell Script Error: $Error"
}

###################################


##################ESXI certi


$ErrorActionPreference = "SilentlyContinue"
<#Param
          (
            [parameter(Mandatory=$true)]
            [String]
            $vCenter,
            [parameter(Mandatory=$true)]
            [String]
            $EmailSender,
            [parameter(Mandatory=$true)]
            [String]
            $DatacenterAbv
          )
Import-Module VMware.VimAutomation.Core
$creds = Get-VICredentialStoreItem -host $vCenter -file "C:\Scripts\credfile.xml"
Connect-viserver $vCenter -User $creds.User -Password $creds.Password


#All required Information for SMTP Functions
$emailSmtpServer = "204.130.61.208"
$emailfrom = $EmailSender | Out-string
$emailto = "suser1@example.com"
#$emailto = "support@example.com","wiSupport@example.com"
$emailSubject = "CI Certificate Report-$DatacenterAbv"
#>

#add-pssnapin VMware.VimAutomation.Core
Import-Module VMware.VimAutomation.Core
#Login on the local VC
#$creds = Get-VICredentialStoreItem -host $vCenter -file "C:\Scripts\credfile.xml"
[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
	
[ValidateNotNullOrEmpty()]
$USERNAME = '$INPUT{USERNAME}'

[ValidateNotNullOrEmpty()]
$HOST = '$INPUT{HOSTNAME}'

$CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )

$srv = Connect-VIServer -Server $HOST -Credential $CREDENTIALS -WarningAction SilentlyContinue -ErrorAction Stop

#All required Information for SMTP Functions
$emailSmtpServer = '$INPUT{SMTPSERVER}'
$emailfrom = $EmailSender | Out-string
$emailto = '$INPUT{EMAILRECIPIENTS}'
#$emailto = "ci.support@example.com","Backup.services@example.com","Commercial.Wintel.Support@example.com"
$DatacenterAbv = '$INPUT{DATACENTERABV}'
$emailSubject = "GCS CI Certificate Report - $HOST - $DatacenterAbv"

#Body style of the reports.
$mystyle = "<style>"
$mystyle = $mystyle + "BODY{font-family:Arial;font-size:8pt;}"
$mystyle = $mystyle + "Table{border: 1px solid black; border-collapse: collapse; }"
$mystyle = $mystyle + "TH{border: 1px solid black; background: #dddddd; padding: 5px; }"
$mystyle = $mystyle + "TD{border: 1px solid black; padding: 5px; }"
$mystyle = $mystyle + "</style"


function Test-WebServerSSL {
[CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
        [string]$URL,
        [Parameter(Position = 1)]
        [ValidateRange(1,65535)]
        [int]$Port = 443,
        [Parameter(Position = 2)]
        [Net.WebProxy]$Proxy,
        [Parameter(Position = 3)]
        [int]$Timeout = 15000,
        [switch]$UseUserContext
    )
 @"
using System;
using System.Net;
using System.Security.Cryptography.X509Certificates;
namespace PKI {
    namespace Web {
        public class WebSSL {
            public Uri OriginalURi;
            public Uri ReturnedURi;
            public X509Certificate2 Certificate;
            //public X500DistinguishedName Issuer;
            //public X500DistinguishedName Subject;
            public string Issuer;
            public string Subject;
            public string[] SubjectAlternativeNames;
            public bool CertificateIsValid;
            //public X509ChainStatus[] ErrorInformation;
            public string[] ErrorInformation;
            public HttpWebResponse Response;
        }
    }
}
"@
    $ConnectString = "https://$url`:$port"
    $WebRequest = [Net.WebRequest]::Create($ConnectString)
    $WebRequest.Proxy = $Proxy
    $WebRequest.Credentials = $null
    $WebRequest.Timeout = $Timeout
    $WebRequest.AllowAutoRedirect = $true
    [Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}
    try {$Response = $WebRequest.GetResponse()}
    catch {}
    if ($WebRequest.ServicePoint.Certificate -ne $null) {
        $Cert = [Security.Cryptography.X509Certificates.X509Certificate2]$WebRequest.ServicePoint.Certificate.Handle
        try {$SAN = ($Cert.Extensions | Where-Object {$_.Oid.Value -eq "2.5.29.17"}).Format(0) -split ", "}
        catch {$SAN = $null}
        $chain = New-Object Security.Cryptography.X509Certificates.X509Chain -ArgumentList (!$UseUserContext)
        [void]$chain.ChainPolicy.ApplicationPolicy.Add("1.3.6.1.5.5.7.3.1")
        $Status = $chain.Build($Cert)
 $ConnectionInformation = New-Object PSObject -Property ([Ordered]@{ 
             OriginalUri = $ConnectString; 
             ReturnedUri = $Response.ResponseUri; 
             Certificate = [Security.Cryptography.X509Certificates.X509Certificate2]$WebRequest.ServicePoint.Certificate; 
             Issuer = $WebRequest.ServicePoint.Certificate.Issuer; 
             Subject = $WebRequest.ServicePoint.Certificate.Subject; 
             SubjectAlternativeNames = $SAN; 
             CertificateIsValid = $Status; 
             Response = $Response; 
             ErrorInformation = $chain.ChainStatus | ForEach-Object {$_.Status} 
         })
         $ConnectionInformation.PSObject.TypeNames.Add("Indented.LDAP.ConnectionInformation")
         $ConnectionInformation
        }
        $chain.Reset()
        [Net.ServicePointManager]::ServerCertificateValidationCallback = $null
    } 

# Check for Host Certificates 
$HostCert = Get-VMHost | Foreach { Test-WebServerSSL -URL $_.Name | Select OriginalURi, CertificateIsValid, Issuer, @{N="Expires";E={$_.Certificate.NotAfter} }, @{N="DaysTillExpire";E={(New-TimeSpan -Start (Get-Date) -End ($_.Certificate.NotAfter)).Days} }|where {$_.OriginalURi -like "http*" -and $_.DaysTillExpire -lt "90"}} | sort DaysTillExpire
If ($HostCert) {$HostCertRPT = $HostCert | ConvertTo-HTML -head $mystyle | Out-string -ErrorAction SilentlyContinue
    $HostCertbody = "<H2> Host Certificates Expiring in 90 days-$DatacenterAbv </H2>" + $HostCertRPT
   }
Else {
$HostCertbody = "<H2> No Host Certificates Expiring in 90 days to Report-$DatacenterAbv </H2>"
}

# Check for vCenter Certificate
$VCCert = Test-WebServerSSL -URL $Global:DefaultVIServers.name | Select OriginalURi, @{N="Expires";E={$_.Certificate.NotAfter} }, @{N="DaysTillExpire";E={(New-TimeSpan -Start (Get-Date) -End ($_.Certificate.NotAfter)).Days} }|where {$_.OriginalURi -like "http*" -and $_.DaysTillExpire -ile"90"}
If ($VCCert) {$VCCertRPT = $VCCert | ConvertTo-HTML -head $mystyle | Out-string -ErrorAction SilentlyContinue
    $VCCertbody = "<H2> vCert Certificates will expire within 90 days-$DatacenterAbv </H2>" + $VCCertRPT
   }
Else {
$VCCertbody = "<H2> vCenter Certificate Expiring in 90 days to Report-$DatacenterAbv </H2>"
}

#Gather vSphere License Info and report only Temp Licenses
$ALLvSphereLicInfo = @() 
$ServiceInstance = Get-View ServiceInstance 
Foreach ($LicenseMan in Get-View ($ServiceInstance | Select -First 1).Content.LicenseManager) { 
    Foreach ($License in ($LicenseMan | Select -ExpandProperty Licenses)) { 
        $Details = "" |Select VC, Name, Key, Total, Used, ExpirationDate , Information 
        $Details.VC = ([Uri]$LicenseMan.Client.ServiceUrl).Host 
        $Details.Name= $License.Name 
        $Details.Key= $License.LicenseKey 
        $Details.Total= $License.Total 
        $Details.Used= $License.Used 
        $Details.Information= $License.Labels | Select -expand Value 
        $Details.ExpirationDate = $License.Properties | Where { $_.key -eq "expirationDate" } | Select -ExpandProperty Value 
        $ALLvSphereLicInfo += $Details 
    } 
} 
$TempLic = $ALLvSphereLicInfo | Where {$_.ExpirationDate -ne $null}
If ($TempLic) {$TempLicRPT = $TempLic | ConvertTo-HTML -head $mystyle | Out-string -ErrorAction SilentlyContinue
$LicInfoBody = "<H2> vSphere Temporary Licenses-$DatacenterAbv </H2>" + $TempLicRPT
}
Else {
$LicInfoBody = "<H2> No vSphere Temporary Licenses to Report-$DatacenterAbv </H2>"
} 

foreach($vc in $global:DefaultVIServers){
    $licMgr = Get-View LicenseManager -Server $vc
    $licAssignmentMgr = Get-View -Id $licMgr.LicenseAssignmentManager -Server $vc
    $AssetLicenses = $licAssignmentMgr.QueryAssignedLicenses($vc.InstanceUid) | %{
        $_ | select @{N='vCenter';E={$vc.Name}},EntityDisplayName,
            @{N='LicenseKey';E={$_.AssignedLIcense.LicenseKey}},
            @{N='LicenseName';E={$_.AssignedLicense.Name}},
            @{N='ExpirationDate';E={$_.AssignedLicense.Properties.where{$_.Key -eq 'expirationDate'}.Value }}
    }
}
$AssetLicenses = $AssetLicenses | Where {$_.ExpirationDate -ne $null}

If ($AssetLicenses) {$AssetLicensesRPT = $AssetLicenses | ConvertTo-HTML -head $mystyle | Out-string -ErrorAction SilentlyContinue
$AssetLicensesRPT = "<H2> vSphere Licenses with Expiration Date </H2>" + $AssetLicensesRPT
}
Else {
$AssetLicensesRPT = "<H2> No vSphere Licenses with Expiration Date to Report </H2>"
} 


#Email Body - add to as needed
$emailbody = "$VCCertbody"+"$HostCertbody"+"$LicInfoBody"+"$AssetLicensesRPT"


<#Wait until 8AM EST before sending
$dt=(get-date).ToUniversalTIme()
While ($dt.hour -ne 12) {start-sleep -seconds 1
$dt=(get-date).ToUniversalTIme()
#$DT.hour
}
#>


$emailfrom = '$INPUT{EMAILSENDER}'
return $emailbody

#Sending message parameter
#Send-MailMessage -To $emailto -From $emailfrom -Subject $emailSubject -Body $emailbody -BodyAsHtml -SmtpServer $emailSmtpServer 
Disconnect-VIServer -Confirm:$false


#############################


###################WINDOWS RDP HC#########

$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password

if(Test-Connection -ComputerName $INPUT{COMPUTERNAME})
{
$mping="OK"
write-host "ping=OK"
}
else
{
$mping="NOTOK"
write-host "ping=NOTOK"
}

write-host " "
Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {
write-host " "
$servername=$env:COMPUTERNAME
$servername
write-host " "
$var=gwmi win32_operatingsystem
if($var)
{
$lastbootup='{0:MM/dd/yyyy hh:mm}' -f ($var.ConvertToDateTime($var.LastBootUpTime))
$lastbootup
}
write-host " "
$datestr=((get-date)-($var.ConvertToDateTime($var.LastBootUpTime))) | select Days,Hours,Minutes
$totdays=[math]::round($datestr.Days)
$tothours=[math]::round($datestr.Hours)
$totmts=[math]::round($datestr.Minutes)

$uptime=$totdays,$tothours,$totmts -join ":"
write-host " "
$uptime

write-host " "
$rdpcount=0
$rpport=netstat -ano | select-string "0.0.0.0:3389"
foreach($rpr in $rpport)
{
$rpr
if($rpr -match "LISTENING")
{
$rdpcount=$rdpcount+1
}
}
if($rdpcount -ge 1){write-host "RDP=OK"
$RDP="OK"}else{write-host "RDP=NOTOK"
$RDP="NOTOK"}

$sOS =Get-WmiObject -class Win32_OperatingSystem
write-host " "
write-host $sOS.Caption
$mos=$sOS.Caption
write-host " "
$hfxs=@()
$hfcount=0


write-host "Checking the patch for day"
$inpatch=gwmi win32_QuickFixEngineering | where {$_.InstalledOn -ge (get-date).AddHours(-24)} |select HotFixID
if($inpatch)
{
foreach($in in $inpatch)
{
$hfxs += $in.HotFixID
}
$hfcount=$hfxs.count
$fhfxs=$hfxs -join (",")
}
write-host " "


$prime=(Get-WmiObject Win32_OperatingSystem).SystemDrive
[array]$mdisk=gwmi win32_logicaldisk
$diskcount='0'
foreach($MID in $mdisk)
{
$col=$col+1
$dtype=$NUll
$fper=$Null
$dfree=$NUll
$dtype=$MID.DriveType
if(($dtype -ne '0') -and ($dtype -ne '2')-and ($dtype -ne '6') -and ($dtype -ne '5')){
$diskcount=$diskcount+1
$tid=$MID.DeviceID
[float]$msize = $MID.Size;
[float]$mfreespace = $MID.FreeSpace;
$dtype=$MID.DriveType
if($dtype -eq '3'){ $dtype = 'Local Disk'}
if($dtype -eq '4'){ $dtype = 'Network Drive'}
if($tid -eq $prime)
{
$ffreeprime=[Math]::Round(($mfreespace / $msize) * 100);
write-host $ffreeprime
}
}
}
write-host " "


$stopser=@()
$stopser=gwmi win32_service | where {($_.StartMode -eq 'AUTO') -and ($_.State -ne 'Running')}


$fserlist=@()
$failedser=gwmi win32_service | where{ ($_.StartMode -eq 'AUTO') -and ($_.State -ne 'Running')} | select Name

$pserlist=@()
if($failedser)
{
foreach($inser in $failedser)
{
$pserlist += $inser.Name
}
}

$pserlist
$pserlist.count
if($pserlist.count -ne 0)
{
$fserlist=$pserlist -join ","
$finser=$fserlist
$Service="NOTOK"
}
else
{
$Service="OK"
}
$fserlist
$finser


$mem=gwmi -Class win32_operatingsystem |
Select-Object @{Name = "MemoryUsage"; Expression = { '{0:N2}' -f ((($_.TotalVisibleMemorySize - $_.FreePhysicalMemory)*100)/ $_.TotalVisibleMemorySize) }}

$memavg=[math]::round($mem.MemoryUsage)


$cpu=Get-WmiObject win32_processor | Measure-Object -property LoadPercentage -Average | Select Average
$cpuavg=[math]::round($cpu.Average)

if($fhfxs -eq $Null){$fhfxs="Not applicable"}

write-host "----------------------------------------------------"

$mstamp='{0:MM/dd/yyyy hh:mm}' -f (get-date)
$presult=$args[0]


$voolume=cscript C:\Windows\System32\slmgr.vbs /dli
$licensekey=$voolume | select-string 'License Status'
$licensekey.trim()
if(!$licensekey)
{
$licensekey='Not Activated'	
}

write-host "Feth=|$servername|$finser|$Service|$ffreeprime|$fhfxs|$hfcount|$mos|$RDP|$uptime|$lastbootup|$presult|$mstamp|$memavg|$cpuavg|$licensekey >"

$finout="Feth=|$servername|$finser|$Service|$ffreeprime|$fhfxs|$hfcount|$mos|$RDP|$uptime|$lastbootup|$presult|$mstamp|$memavg|$cpuavg|$licensekey >"

} -ArgumentList $mping -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)


###############

############set pagefile to standard#############

$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password
#$SelectedOption = '$INPUT{SELECTACTION}'
#$SelectedOption
$chnno = '$INPUT{CHANGENUMBER}'

if(Test-Connection -ComputerName $INPUT{COMPUTERNAME})
{
$mping="OK"
write-host "ping=OK"
}
else
{
$mping="NOTOK"
write-host "ping=NOTOK"
}

write-host " "
Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {
write-host " "
$servername=$env:COMPUTERNAME
$servername

#$SelectedOption=$args[0].trim()

	
$IsAutomaticManagedPagefile = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $servername |Foreach-Object{$_.AutomaticManagedPagefile}

If($IsAutomaticManagedPagefile)
	{
		#We must enable all the privileges of the current user before the command makes the WMI call.
		$computersys = Get-WmiObject Win32_ComputerSystem -ComputerName $servername -EnableAllPrivileges;
        $computersys.AutomaticManagedPagefile = $False;
        $computersys.Put();
        $computersys = gwmi -ComputerName $servername -query "select * from Win32_PageFileSetting where name='c:\\pagefile.sys'"
        $computersys.InitialSize = [int]4096
        $computersys.MaximumSize = [int]4096
        $computersys.Put()
        Write-Output "Disabled Automatic Managed Pagefie and set to MS standards"
       
        
	}
else
{
$computersys = gwmi -ComputerName $servername -query "select * from Win32_PageFileSetting where name='c:\\pagefile.sys'"
#$computersys
$computersys.InitialSize = [int]4096
$computersys.MaximumSize = [int]4096
$computersys.Put()
Write-Output "C drive pagefile set to MS standards"
}
start-sleep -second 5
Restart-Computer -ComputerName $INPUT{COMPUTERNAME} -Force


} -ArgumentList ($mping) -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)




#Restart-Computer -ComputerName $INPUT{COMPUTERNAME} -Wait -For PowerShell -Timeout 300 -Delay 2 -Force
Start-Sleep -Seconds 360

DO
{
$Ping = Test-Connection $INPUT{COMPUTERNAME} -Count 60 -Quiet}
Until ($Ping -contains "True")
Write-Host "Server is online"
start-sleep -second 10




Invoke-Command -ComputerName $INPUT{COMPUTERNAME} -Credential $credential -Scriptblock {
	
$servername=$env:COMPUTERNAME
$servername


$Pagefilesize=get-wmiobject -computer $servername Win32_pagefileusage | % {$_.AllocatedBaseSize}
  $drives=Get-WmiObject Win32_LogicalDisk -ComputerName $servername -Filter "DeviceID='C:'"
  $vol= [Math]::Round(($drives.FreeSpace / 1GB))

 if ($Vol -lt 24)
 {
 $Pagefileaction = "Not enough space in C drive"
 $Comments = "Setting Pagefile can't be performed"
 }
 else
 {
 $Pagefileaction = "Space Available"
 }
 
 
 if ($Pagefilesize -match "4096")
 
 {
 $standard = "Yes"
 }
 else {
 $standard = "Non Standard Pagefilesize"
 
 }

if(Test-Connection -ComputerName $servername)
{
$mping="Ping OK"
#write-host "ping=OK"
}
else
{
$mping="Ping Failed"
#write-host "ping=NOTOK"
}


$rdpcount=0
$rpport=netstat -ano | select-string "0.0.0.0:3389"
foreach($rpr in $rpport)
{
#$rpr
if($rpr -match "LISTENING")
{
$rdpcount=$rdpcount+1
}
}
if($rdpcount -ge 1){
#write-host "RDP=OK"
$RDP="RDP Working"
}
else
{
#write-host "RDP=NOTOK"
$RDP="RDP not listening"
}

if ($Pagefileaction -match "Space Available" -and $mping -match "Ping OK" -and $RDP -match "RDP Working" -and $standard -match "Yes")
{
$Comments = "COMPLETED. Pagefile Set to MS standards.Run Pre-check if required"
}
else
{
$Comments = "FAILED to execute pagefile change.Check Worksheet logs for more details"
}
$vtype ="POSTCHECK"
write-host "Feth=|$vtype|$servername|$Pagefilesize|$standard|$Vol|$Pagefileaction|$mping|$RDP|$Comments| >"
$finout= "Feth=|$vtype|$servername|$Pagefilesize|$standard|$Vol|$Pagefileaction|$mping|$RDP|$Comments| >"
}-ArgumentList ($mping) -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)



###############################3

##########CITRIX session########

$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password

$Session = New-PSSession -ComputerName '$INPUT{COMPUTERNAME}' -Credential $credential

#prevalidations: Verifying the winrm process that are used by resolve automation
$getpreviouswinrmprocess = Invoke-Command -Session $Session -ScriptBlock {
    try {
        Get-WmiObject win32_process | Where-Object { $_.ProcessName -like '*wsmprovhost*' } | ForEach-Object { $_.GetOwner().User -like '*psadm*' }
    }
    catch {
        getpreviouswinrmprocess=$NUll	
    }
}

#execute the script only if there are no multiple sessions
if (($getpreviouswinrmprocess.count -le 1) -and ($getpreviouswinrmprocess)) {


    #check if there is any previous job exist in server for disk cleanup
    $getpreviousjobofcleanup = Invoke-Command -Session $Session -ScriptBlock {
        try {
            $getjob = get-job -command '*restart-service*' 
            
            if ($getjob) {
                $msg = 'Another instance of Service Restart is available'
                return $msg
            }
            else {
                $msg = 'No job exist'
                return $msg
            }
        }
        catch {
            $msg = 'Unable to Kill the Job'
            return $msg
        }
    } 	
 
    if ($getpreviousjobofcleanup -like '*No job exist*') {

        #invoke the cleanup script
        $JOB = Invoke-Command -Session $Session -Scriptblock {
    
            Start-Job -ScriptBlock {
            	
                $localname = $env:COMPUTERNAME

                if (($localname -eq 'server1') -or ($localname -eq 'server2')) {
                    $timestring = '060*'
                }
                elseif (($localname -eq 'scserver1') -or ($localname -eq 'scserver2')) {
                    $timestring = '120*'	
                }
                else {
                    $timestring = '070*'
                }


                #======  To rename old file=========
                $global:hour = get-date -UFormat %H%M
                $global:day = Get-Date -UFormat %d
                $global:date = (Get-Date).AddMonths(-1).ToString('MMMM')
                $global:week = (get-date).DayOfWeek

                if ( $global:week -eq 'Tuesday' -and $global:hour -like $timestring) {


	
                    Rename-Item -Path "C:\ajij\License\Reports\myreportweek.csv" -NewName "myReport_weekly_$global:date.csv" -ErrorAction Ignore -Force

                    $dg = "C:\ajij\License\Reports\myReport_weekly_$global:date.csv"
                    $global:dccReport = $NUll
                    function doCheck {
                        $hostname = $env:COMPUTERNAME
                        $dg = "C:\ajij\License\Reports\myReport_weekly_$global:date.csv"
                        $finalvalues = $Null



                        $finalvalues = Import-Csv $dg | Group Name | Sort-Object -Property Name | ForEach {

                            $_.Group | Sort { $_.Group -as [int] } | Select-Object -Last 1
                
                        } 

                        $finalvalues = $finalvalues | Sort-Object -Property Name | ConvertTo-Csv -NoTypeInformation

                        if ($finalvalues) {
                            $total = @()
                            foreach ($values in $finalvalues) {
                                $splitvalues = $values.split(',')
                                if ($splitvalues[0] -notlike "*Count*") {
                                    $result = New-Object System.Object
                                    $result | Add-Member -MemberType NoteProperty -Name "Count" -Value $splitvalues[0].replace('"', '').trim()
                                    $result | Add-Member -MemberType NoteProperty -Name "Name" -Value $splitvalues[1].replace('"', '').trim()
                                    $result | Add-Member -MemberType NoteProperty -Name "Date" -Value $splitvalues[2].replace('"', '').trim()
                                    $total += $result
                                }

                            }
                        }

                        # Remove the report if it has already been run today so it does not append to the existing report
 
                        #Set colors for table cell backgrounds
                        $whiteColor = "#00FF00"
                        $redColor = "#FF0000"
                        $orangeColor = "#FBB917"
                        $yellowColor = "#FCDC3B"
                        $global:healthReport = $NUll
                        # Create and write HTML Header of report
                        $titleDate = Get-Date -Format "dddd MM/dd/yyyy HH:mm K"
                        $header = "
		<html>
		<head>
		<meta http-equiv='Content-Type' content='text/html; charset=iso-8859-1'>
		<title>Server Daily Report</title>
		<STYLE TYPE='text/css'>
		<!--
		td {
			font-family: Tahoma;
			font-size: 11px;
			border-top: 1px solid #999999;
			border-right: 1px solid #999999;
			border-bottom: 1px solid #999999;
			border-left: 1px solid #999999;
			padding-top: 0px;
			padding-right: 0px;
			padding-bottom: 0px;
			padding-left: 0px;
		}
		body {
			margin-left: 5px;
			margin-top: 5px;
			margin-right: 0px;
			margin-bottom: 10px;
			table {
			border: thin solid #000000;
		}
		-->
		</style>
		</head>
		<body>
		<table width='100%'>
		<tr bgcolor='#CCCCCC'>
		<td colspan='7' height='25' align='center'>
		<font face='tahoma' color='#003399' size='4'><strong> $hostname </strong></font>
		</td>
		</tr>
		</table>
    "
                        $global:healthReport += $header


                        $global:dccReports = $Null

                        ##########################################
                        # TOP 5 CPU Processes
                        # Create and write Table header for report
                        ###########################################
    
                        $tableCPUHeader = "
        <table width='100%'><tbody>
	    <tr bgcolor=#CCCCCC>
        <td width='20%' align='center'>DesktopGroupName</td>
	    <td width='5%' align='center'>COUNT</td>
        <td width='5%' align='center'>Date</td>
	    </tr>"
                        $global:dccReports += $tableCPUHeader

                        foreach ($keyitem in $total) {
    
                            # Create table data rows
                            $dataRow = "
		    <tr>
            <td width='20%' align='center'>" + $keyitem.Name + "</td>
		    <td width='5%' align='center'>" + $keyitem.Count + "</td>
            <td width='20%' align='center'>" + $keyitem.Date + "</td>
		    </tr>"
                            $global:dccReports += $dataRow
                        }
                        $tableDescription = "
    </table><br>
    "
                        $global:dccReports += $tableDescription;
   
                    }


                    ###################
                    # Main Run Section
                    ###################
                    if (Test-Path C:\ajij\License\Reports\myReport_weekly_$global:date.csv) {
                        doCheck
                        $global:healthReport += $global:dccReports
                    }
                    else {
                        $global:healthReport = $Null
                    }



                    if (($global:healthReport -like "*html*")) {  
                        $global:healthReport                       
                    }
                    else {
                        write-host "Report is Not available for $env:COMPUTERNAME"
                    }
                }
                else {
                    #write-host "Count"
                }

                if ( $global:day -eq '01' -and $global:hour -like $timestring) {


	
                    Rename-Item -Path "C:\ajij\License\Reports\myreport.csv" -NewName "myReport_$global:date.csv" -ErrorAction Ignore -Force

                    $dg = "C:\ajij\License\Reports\myReport_$global:date.csv"
                    $global:dccReport = $NUll
                    function doCheck {
                        $hostname = $env:COMPUTERNAME
                        $dg = "C:\ajij\License\Reports\myReport_$global:date.csv"
                        $finalvalues = $Null



                        $finalvalues = Import-Csv $dg | Group Name | ForEach {

                            $_.Group | Sort { $_.Count -as [int] } | Select-Object -Last 1
                
                        } 

                        $finalvalues = $finalvalues | ConvertTo-Csv -NoTypeInformation

                        if ($finalvalues) {
                            $total = @()
                            foreach ($values in $finalvalues) {
                                $splitvalues = $values.split(',')
                                if ($splitvalues[0] -notlike "*Count*") {
                                    $result = New-Object System.Object
                                    $result | Add-Member -MemberType NoteProperty -Name "Count" -Value $splitvalues[0].replace('"', '').trim()
                                    $result | Add-Member -MemberType NoteProperty -Name "Name" -Value $splitvalues[1].replace('"', '').trim()
                                    $result | Add-Member -MemberType NoteProperty -Name "Date" -Value $splitvalues[2].replace('"', '').trim()
                                    $total += $result
                                }

                            }
                        }

                        # Remove the report if it has already been run today so it does not append to the existing report
 
                        #Set colors for table cell backgrounds
                        $whiteColor = "#00FF00"
                        $redColor = "#FF0000"
                        $orangeColor = "#FBB917"
                        $yellowColor = "#FCDC3B"
                        $global:healthReport = $NUll
                        # Create and write HTML Header of report
                        $titleDate = Get-Date -Format "dddd MM/dd/yyyy HH:mm K"
                        $header = "
		<html>
		<head>
		<meta http-equiv='Content-Type' content='text/html; charset=iso-8859-1'>
		<title>Server Daily Report</title>
		<STYLE TYPE='text/css'>
		<!--
		td {
			font-family: Tahoma;
			font-size: 11px;
			border-top: 1px solid #999999;
			border-right: 1px solid #999999;
			border-bottom: 1px solid #999999;
			border-left: 1px solid #999999;
			padding-top: 0px;
			padding-right: 0px;
			padding-bottom: 0px;
			padding-left: 0px;
		}
		body {
			margin-left: 5px;
			margin-top: 5px;
			margin-right: 0px;
			margin-bottom: 10px;
			table {
			border: thin solid #000000;
		}
		-->
		</style>
		</head>
		<body>
		<table width='100%'>
		<tr bgcolor='#CCCCCC'>
		<td colspan='7' height='25' align='center'>
		<font face='tahoma' color='#003399' size='4'><strong> $hostname </strong></font>
		</td>
		</tr>
		</table>
    "
                        $global:healthReport += $header


                        $global:dccReports = $Null

                        ##########################################
                        # TOP 5 CPU Processes
                        # Create and write Table header for report
                        ###########################################
    
                        $tableCPUHeader = "
        <table width='100%'><tbody>
	    <tr bgcolor=#CCCCCC>
        <td width='20%' align='center'>DesktopGroupName</td>
	    <td width='5%' align='center'>COUNT</td>
        <td width='5%' align='center'>Date</td>
	    </tr>"
                        $global:dccReports += $tableCPUHeader

                        foreach ($keyitem in $total) {
    
                            # Create table data rows
                            $dataRow = "
		    <tr>
            <td width='20%' align='center'>" + $keyitem.Name + "</td>
		    <td width='5%' align='center'>" + $keyitem.Count + "</td>
            <td width='20%' align='center'>" + $keyitem.Date + "</td>
		    </tr>"
                            $global:dccReports += $dataRow
                        }
                        $tableDescription = "
    </table><br>
    "
                        $global:dccReports += $tableDescription;
   
                    }


                    ###################
                    # Main Run Section
                    ###################
                    if (Test-Path C:\ajij\License\Reports\myReport_$global:date.csv) {
                        doCheck
                        $global:healthReport += $global:dccReports
                    }
                    else {
                        $global:healthReport = $Null
                    }



                    if (($global:healthReport -like "*html*")) {  
                        $global:healthReport                       
                    }
                    else {
                        write-host "Report is Not available for $env:COMPUTERNAME"
                    }
                }
                else {
                    #write-host "Count"
                    
                }
               

                $dateformat = get-date -UFormat "%d-%m-%Y %H-%M"
                $file2 = "C:\ajij\License\Reports\myreportweek.csv" 
                $file1 = "C:\ajij\License\Reports\myreportweektest.csv"
                $file4 = "C:\ajij\License\Reports\myreport.csv" 
                $file3 = "C:\ajij\License\Reports\myreporttest.csv"

                try {
                
                    $d = Get-BrokerSession -MaxRecordCount 10000 | Where-Object { $_.protocol -like "*hdx*" } |
                    select DesktopGroupName | Group-Object -Property desktopgroupname | select count, name | export-csv -NoTypeInformation $file1

                }
                catch {
                    try {
                        Add-PSSnapin Citrix.*
                       
                        $d = Get-BrokerSession -MaxRecordCount 10000 | Where-Object { $_.protocol -like "*hdx*" } | select DesktopGroupName | Group-Object -Property desktopgroupname | select count, name | export-csv -NoTypeInformation $file1
                    }
                    catch {
                        write-host "Module not available in $env:COMPUTERNAME"
                    }

    

                } 
                import-csv $file1 | ForEach-Object {

                    $_ |
                    Add-Member -MemberType NoteProperty  -Name time -Value $dateformat -PassThru -Force
                } | Export-Csv -NoTypeInformation $file2 -Append -Force



                try {
                    $d = Get-BrokerSession -MaxRecordCount 10000 | Where-Object { $_.protocol -like "*hdx*" } |
                    select DesktopGroupName | Group-Object -Property desktopgroupname | select count, name | export-csv -NoTypeInformation $file3


                }
                catch {
                    try {
                        Add-PSSnapin Citrix.*

                        $d = Get-BrokerSession -MaxRecordCount 10000 | Where-Object { $_.protocol -like "*hdx*" } | select DesktopGroupName | Group-Object -Property desktopgroupname | select count, name | export-csv -NoTypeInformation $file3
        
                    }
                    catch {
                        write-host "Module not available in $env:COMPUTERNAME"
                    }

    

                } 
                import-csv $file3 | ForEach-Object {

                    $_ |
                    Add-Member -MemberType NoteProperty  -Name time -Value $dateformat -PassThru -Force
                } | Export-Csv -NoTypeInformation $file4 -Append -Force




            	 
            }      
        }
    
        #send a wait command to wait for minutes less than action task timeout
        $wait = Invoke-Command -Session $Session -ScriptBlock {
            Wait-Job -id $args[0] -Timeout 650
        } -ArgumentList $JOB.Id
     
        #receive the execution output from the server
        $receive = Invoke-Command -Session $Session -ScriptBlock {
            Receive-Job -id $args[0] -keep
        } -ArgumentList $JOB.Id
    
        $receive

        #check for stale sessions after script execution
        $get = Invoke-Command -Session $Session -ScriptBlock { Get-Job -Id $args[0]
        } -ArgumentList $JOB.Id
    
        if ($get.State -ne 'Completed') {
            #kill the job if it is available in server
            Invoke-Command -Session $Session -ScriptBlock {
                Stop-Job -Id $args[0] -Confirm:$false
                Remove-Job -Id $args[0]
                write-host 'Attention : Automation timeout has been exceeded, The end result may not have complete information and hence check the server manually if required'
            } -ArgumentList $JOB.Id
        }
        else {
            #Write-host ' Automation execution completed and it has clean exit from server'
        }     
    
        #disconnect the session
        $Session | Remove-PSSession

    }
    else {
        write-host "Pre validation Failed : Another Automation instance is active in server and unfortunately automation failed to kill the job,retry automation manually after cleaning the stale sessions"
    }
}
else {
    write-host "Pre validation failed : Multiple Winrm Sessions are already available in this server and so try after some time by manually executing the cleanup script"	
}


########################

#############decom age report############

$ErrorActionPreference="Silentlycontinue"

[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

$ruser = 'resolve'
$rpassword = ConvertTo-SecureString $PROPERTY{SERVICENOW_PASSWORD} -AsPlainText -Force
$rcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $ruser, $rpassword
$rcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $ruser, $rpassword
$tasktotal=@()
$primeIncidentURL = "https://company.service-now.com/api/now/table/sc_req_item?sysparm_query=assignment_group=4fa8a8650fbe7e44f5b63e7ce1050eff^stateIN1,2&sysparm_display_value=true"

$primeIncidentPOSTResponse=$Null
Try 
{
  $primeIncidentPOSTResponse = Invoke-RestMethod -Method GET -Uri $primeIncidentURL -Body $rbodyJson -TimeoutSec 100 -Credential $rcredential -ContentType $Type
}
Catch 
{
  Write-Host $_.Exception.ToString()
  $error[0] | Format-List -Force
}

$start=get-date
$cprimeIncidentURL = "https://company.service-now.com/api/now/table/sc_task?sysparm_query=request_item.assignment_group=4fa8a8650fbe7e44f5b63e7ce1050eff^request_item.stateIN1,2&sysparm_display_value=true"

$cprimeIncidentPOSTResponse=$Null
Try 
{
  $cprimeIncidentPOSTResponse = Invoke-RestMethod -Method GET -Uri $cprimeIncidentURL -Body $rbodyJson -TimeoutSec 100 -Credential $rcredential -ContentType $Type
}
Catch 
{
  Write-Host $_.Exception.ToString()
  $error[0] | Format-List -Force
}

$end=get-date
$executiontime=[math]::round((New-TimeSpan -Start $start -end $end).TotalMinutes,2)
(New-TimeSpan -Start $start -end $end)
$executiontime

$ctable=$NUll
$ctable=$cprimeIncidentPOSTResponse.result
foreach($citem in $ctable)
{
$taskobj = New-Object -TypeName PSObject
   if($citem.number -notin $tasktotal.'SCT Number')
   {
    $taskobj | Add-Member -MemberType NoteProperty -Name "RITM Number" -Value $citem.parent.display_value -Force
    $taskobj | Add-Member -MemberType NoteProperty -Name "SCT Number" -Value $citem.number -Force
    $taskobj | Add-Member -MemberType NoteProperty -Name "SCT State" -Value $citem.state -Force
    $taskobj | Add-Member -MemberType NoteProperty -Name "SCT Short Description" -Value $citem.short_description -Force
    $taskobj | Add-Member -MemberType NoteProperty -Name "SCT Assignment Group" -Value $citem.assignment_group.display_value -Force
    $taskobj | Add-Member -MemberType NoteProperty -Name "SCT Assigned to" -Value $citem.assigned_to.display_value -Force
    $taskobj | Add-Member -MemberType NoteProperty -Name "SCT Opened" -Value (get-date ($citem.opened_at)).ToUniversalTime().ToString("MM/dd/yy HH:mm:ss") -Force
    $taskobj | Add-Member -MemberType NoteProperty -Name "SCT Actual Start" -Value (get-date ($citem.sys_created_on)).ToUniversalTime().ToString("MM/dd/yy HH:mm:ss") -Force
    $taskobj | Add-Member -MemberType NoteProperty -Name "SCT Actual End" -Value (get-date ($citem.work_end)).ToUniversalTime().ToString("MM/dd/yy HH:mm:ss") -Force
    $taskobj | Add-Member -MemberType NoteProperty -Name "SCT Sequence" -Value $citem.u_sequence -Force
    $tasktotal += $taskobj
    }
}



$reqtotal=@()
$reqtable=$primeIncidentPOSTResponse.result
foreach($rcitem in $reqtable)
{
$reqobj = New-Object -TypeName PSObject
$rcitem.number
    $reqobj | Add-Member -MemberType NoteProperty -Name "RITM Number" -Value $rcitem.number -Force
    $reqobj | Add-Member -MemberType NoteProperty -Name "RITM Short Description" -Value $rcitem.short_description -Force
    $reqobj | Add-Member -MemberType NoteProperty -Name "RITM State" -Value $rcitem.state -Force
    $reqobj | Add-Member -MemberType NoteProperty -Name "RITM Assignment Group" -Value $rcitem.assignment_group.display_value -Force
    $reqobj | Add-Member -MemberType NoteProperty -Name "RITM Assigned To" -Value $rcitem.assigned_to.display_value -Force
    $reqobj | Add-Member -MemberType NoteProperty -Name "RITM Opened By" -Value $rcitem.opened_by.display_value -Force
    $reqobj | Add-Member -MemberType NoteProperty -Name "RITM Created" -Value (get-date ($rcitem.sys_created_on)).ToUniversalTime().ToString("MM/dd/yy HH:mm:ss") -Force
    $reqobj | Add-Member -MemberType NoteProperty -Name "RITM Closed" -Value (get-date ($rcitem.closed_at)).ToUniversalTime().ToString("MM/dd/yy HH:mm:ss") -Force
    $reqobj | Add-Member -MemberType NoteProperty -Name "RITM Due" -Value (get-date ($rcitem.due_date)).ToUniversalTime().ToString("MM/dd/yy HH:mm:ss") -Force
    $reqtotal += $reqobj
}

$total=@()
$notaks=@()
foreach($ritm in $reqtotal)
{

$tasks=$Null
$tasks=$tasktotal | where{$_.'RITM Number' -eq $ritm.'RITM Number'}


if($tasks.count -eq 0)
{
$notaks+=$ritm.'RITM Number'
}

if($tasks.'SCT Sequence' -ge 1)
{
$seq2valid=(($tasks | where {($_.'SCT Sequence' -eq 1) -and ($_.'SCT State' -ne 'Closed Skipped')}).count -eq ((($tasks | where {($_.'SCT Sequence' -eq 1) -and ($_.'SCT State' -ne 'Closed Skipped')}).'SCT Actual End') -like '*/*/* *:*:*').count)
$seq2start=(($tasks | where {($_.'SCT Sequence' -eq 1) -and ($_.'SCT State' -ne 'Closed Skipped')} | Sort-Object -Property 'SCT Actual End' -Descending).'SCT Actual End'[0])
if((!$seq2start) -or ($seq2valid -ne 'True'))
{$seq2start=(get-date).ToUniversalTime().ToString("MM/dd/yy HH:mm:ss")}
$seq3valid=(($tasks | where {($_.'SCT Sequence' -eq 2) -and ($_.'SCT State' -ne 'Closed Skipped')}).count -eq ((($tasks | where {($_.'SCT Sequence' -eq 2) -and ($_.'SCT State' -ne 'Closed Skipped')}).'SCT Actual End') -like '*/*/* *:*:*').count)
$seq3start=(($tasks | where {($_.'SCT Sequence' -eq 2) -and ($_.'SCT State' -ne 'Closed Skipped')} |select 'SCT Actual End'| Sort-Object -Property 'SCT Actual End' -Descending).'SCT Actual End'[0])
if((!$seq3start) -or ($seq3valid -ne 'True'))
{$seq3start=(get-date).ToUniversalTime().ToString("MM/dd/yy HH:mm:ss")}
$seq4valid=(($tasks | where {($_.'SCT Sequence' -eq 3) -and ($_.'SCT State' -ne 'Closed Skipped')}).count -eq ((($tasks | where {($_.'SCT Sequence' -eq 3) -and ($_.'SCT State' -ne 'Closed Skipped')}).'SCT Actual End') -like '*/*/* *:*:*').count)
$seq4start=(($tasks | where {($_.'SCT Sequence' -eq 3) -and ($_.'SCT State' -ne 'Closed Skipped')} | Sort-Object -Property 'SCT Actual End' -Descending).'SCT Actual End'[0])
if((!$seq4start) -or ($seq4valid -ne 'True'))
{$seq4start=(get-date).ToUniversalTime().ToString("MM/dd/yy HH:mm:ss")}
}


foreach($tt in $tasks)
{

  if($tt.'SCT Sequence' -eq 1){$setstart=$ritm.'RITM Created'}
  if($tt.'SCT Sequence'  -eq 2){$setstart=$seq2start}
  if($tt.'SCT Sequence'  -eq 3){$setstart=$seq3start}
  if($tt.'SCT Sequence'  -eq 4){$setstart=$seq4start}
  if(!$tt.'SCT Sequence' ){$setstart=$ritm.'RITM Created'}


  if(!$ritm.'RITM Closed')
  {
   $pworkend=(get-date).ToUniversalTime().ToString("MM/dd/yy HH:mm:ss")
  }
  else
  {
   $pworkend=$ritm.'RITM Closed'
  }


  
  if(!$tt.'SCT Actual End')
  {
   $workend=((get-date).ToUniversalTime().ToString("MM/dd/yy HH:mm:ss"))
  }
  else
  {
   $workend=$tt.'SCT Actual End'
  }

   $aging=[math]::round((NEW-TIMESPAN -Start $setstart -End $workend).TotalDays,2)
 
  if($aging -le 02.00)
  {
    $agingparam = '0 to 2'
  }elseif(($aging -ge 02.01) -and ($aging -le 05.00))
  {
    $agingparam = '3 to 5'
  }elseif(($aging -ge 05.01) -and ($aging -le 10.00))
  {
    $agingparam = '6 to 10'
  }elseif(($aging -ge 10.01) -and ($aging -le 15.00))
  {
    $agingparam = '11 to 15'
  }else
  {
    $agingparam = 'Over 15'
  }

  $obj = New-Object -TypeName PSObject

    $obj | Add-Member -MemberType NoteProperty -Name "RITM Number" -Value $ritm.'RITM Number' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "RITM Short Description" -Value $ritm.'RITM Short Description' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "RITM State" -Value $ritm.'RITM State' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "RITM Assignment Group" -Value $ritm.'RITM Assignment Group' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "RITM Assignment To" -Value $ritm.'RITM Assigned To' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "RITM Created" -Value $ritm.'RITM Created' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "RITM Opened By" -Value $ritm.'RITM Opened By' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "RITM Closed" -Value $pworkend -Force
    $obj | Add-Member -MemberType NoteProperty -Name "RITM Due" -Value $ritm.'RITM Due' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "SCT Number" -Value $tt.'SCT Number' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "SCT State" -Value $tt.'SCT State' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "SCT Short Description" -Value $tt.'SCT Short Description' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "SCT Assignment Group" -Value $tt.'SCT Assignment Group' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "SCT Assigned to" -Value $tt.'SCT Assigned to' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "SCT Opened" -Value $tt.'SCT Opened' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "SCT Actual Start" -Value $setstart -Force
    $obj | Add-Member -MemberType NoteProperty -Name "SCT Actual End" -Value $workend -Force
    $obj | Add-Member -MemberType NoteProperty -Name "SCT Sequence" -Value $tt.'SCT Sequence' -Force
    $obj | Add-Member -MemberType NoteProperty -Name "SCT Ageing in days" -Value $aging -Force
    $obj | Add-Member -MemberType NoteProperty -Name "SCT Ageing Category" -Value $agingparam -Force
    $total += $obj

}


}

$end=get-date
$executiontime=[math]::round((New-TimeSpan -Start $start -end $end).TotalMinutes,2)
$datetime = get-date -format "ddMMyyyyhhmmss"
$total | Export-Csv C:\temp\$datetime.csv -NoTypeInformation

$executiontime
$ritmcount=$reqtotal.Count
$taskcount=$tasktotal.count

$sorted=($reqtotal | Sort-Object {$_."RITM Created" -as [datetime]} -Descending).'RITM Created'

$from=$sorted[0]
$to=$sorted[-1]



$grouptotal=@()

$agroups=($total | group-object -Property 'SCT Assignment Group').Name

if($agroups)
{
foreach($groups in $agroups)
{

    $pregroupvalues=($total | where {($_.'SCT Assignment Group' -eq "$groups")})
    $groupvalues=$pregroupvalues | where{($_.'SCT State' -eq 'Open') -or ($_.'SCT State' -eq 'Work in Progress')}
    if($groupvalues)
    {
    $gobj = New-Object -TypeName PSObject
    $gobj | Add-Member -MemberType NoteProperty -Name 'Assignment Group' -Value $groups.trim() -Force
    $gobj | Add-Member -MemberType NoteProperty -Name '0 to 2' -Value (( $groupvalues | where{$_.'SCT Ageing Category' -eq '0 to 2'}).'SCT Ageing Category').Count  -Force
    $gobj | Add-Member -MemberType NoteProperty -Name '3 to 5' -Value (( $groupvalues | where{$_.'SCT Ageing Category' -eq '3 to 5'}).'SCT Ageing Category').Count -Force
    $gobj | Add-Member -MemberType NoteProperty -Name '6 to 10' -Value (( $groupvalues | where{$_.'SCT Ageing Category' -eq '6 to 10'}).'SCT Ageing Category').Count -Force
    $gobj | Add-Member -MemberType NoteProperty -Name '11 to 15' -Value (( $groupvalues | where{$_.'SCT Ageing Category' -eq '11 to 15'}).'SCT Ageing Category').Count -Force
    $gobj | Add-Member -MemberType NoteProperty -Name 'Over 15' -Value (( $groupvalues | where{$_.'SCT Ageing Category' -eq 'Over 15'}).'SCT Ageing Category').Count -Force
    $gobj | Add-Member -MemberType NoteProperty -Name "Total" -Value (( $groupvalues | where{$_.'SCT Ageing Category' -ne $Null}).'SCT Ageing Category').Count -Force
    $grouptotal += $gobj
    }
}

$fintotal=$grouptotal | sort-object {$_.Total} -Descending 
}



        $whiteColor="#00FF00"
        $redColor = "#FF0000"
        $orangeColor = "#FBB917"
        $yellowColor = "#FCDC3B"
    $global:healthReport=$NUll
    # Create and write HTML Header of report
    $titleDate = Get-Date -Format "dddd MM/dd/yyyy HH:mm"
    $header = "
		<html>
		<head>
		<meta http-equiv='Content-Type' content='text/html; charset=iso-8859-1'>
		<title>Server Daily Report</title>
		<STYLE TYPE='text/css'>
		<!--
		td {
			font-family: Tahoma;
			font-size: 11px;
			border-top: 1px solid #999999;
			border-right: 1px solid #999999;
			border-bottom: 1px solid #999999;
			border-left: 1px solid #999999;
			padding-top: 0px;
			padding-right: 0px;
			padding-bottom: 0px;
			padding-left: 0px;
		}
		body {
			margin-left: 5px;
			margin-top: 5px;
			margin-right: 0px;
			margin-bottom: 10px;
			table {
			border: thin solid #000000;
		}
		-->
        </style>
		</head>
		<body>
		
    "
 $global:healthReport += $header


$global:dccReports=$Null

    ##########################################
    # TOP 5 CPU Processes
    # Create and write Table header for report
    ###########################################
    $tableCpuTitle= "
 		<table width='100%'>
		<tr bgcolor='#CCCCCC'>
		<td colspan='7' height='10' align='center'>
		<font face='tahoma' color='#003399' size='4'><strong>Aging Summary for Server Deployment Enterprise OPEN RITM - RITM:$ritmcount   TASKS:$taskcount</strong></font>
		</td>
		</tr>
		</table>"
    $global:dccReports += $tableCPUTitle
    
    $tableCPUHeader = "
        <table width='100%'><tbody>
	    <tr bgcolor=#CCCCCC>
        <td width='20%' align='center'>Assignment Group</td>
        <td width='10%' align='center'>0 to 2 days</td>
	    <td width='10%' align='center'>3 to 5 days</td>
        <td width='10%' align='center'>6 to 10 days</td>
        <td width='10%' align='center'>11 to 15 days</td>
        <td width='10%' align='center'>Over 15 days</td>
        <td width='10%' align='center'>Total</td>
	    </tr>"
   $global:dccReports += $tableCPUHeader

   
    foreach($gt in $fintotal)
    {
        # Create table data rows
        $dataRow = "
		    <tr>
            <td width='20%' align='left'>"+$gt.'Assignment Group'+"</td>
            <td width='10%' align='center'>"+$gt.'0 to 2'+"</td>
		    <td width='10%' align='center'>"+$gt.'3 to 5'+"</td>
            <td width='10%' align='center'>"+$gt.'6 to 10'+"</td>
            <td width='10%' align='center'>"+$gt.'11 to 15'+"</td>
            <td width='10%' align='center'>"+$gt.'Over 15'+"</td>
            <td width='10%' align='center'>"+$gt.Total+"</td>
		    </tr>"
         $global:dccReports += $dataRow
    }
 
    $tableDescription = "
    </table><br>
    "
   $global:dccReports += $tableDescription;
   
   


$global:healthReport += $global:dccReports





start-sleep -Seconds 20

Remove-Item c:\temp\$datetime.csv -Force


#########################

##############NETBACKUP TICKETING########

$spass = '$INPUT{SNOWPASSWORD}'
$gcsuser = '$PROPERTY{GCS_SERVICENOW_USERNAME}'
$gcspass = '$PROPERTY{GCS_SERVICENOW_PASSWORD}'
$stopwatch = [system.diagnostics.stopwatch]::startNew()

[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

#v3
function updateci() {
    [CmdletBinding()]
    param(
        $configitem,
        $snowlink,
        $sys_id,
        $spass,
        $suser
        
    )
    if ($configitem -like "*,*") {
        $splitconfig = $configitem.split(",") | Select-Object -Unique
        foreach ($mycitem in $splitconfig) {
            $SNuser = $suser #enter your ServiceNow Username
            $SNpass = $spass #enter your ServiceNow Password
            # Build auth header
            $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(("{0}:{1}" -f $SNuser, $SNpass)))
            # Set proper headers
            $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
            $headers.Add('Authorization', ('Basic {0}' -f $base64AuthInfo))
            $headers.Add('Accept', 'application/json')
            $headers.Add('Content-Type', 'application/json')
            # Specify endpoint uri
            $UpdateCHGuri = "$snowlink/api/now/table/task_ci?task=$sys_id"
            # Specify HTTP method
            $Patchmethod = "patch"
            # Specify request body
            if ($mycitem -like "*.*") {
                $mycitem = $mycitem.split('.')[0].trim()
            }
            $UpdateCHGbody = @{ #Create Body of the Post Request
                ci_item = $mycitem
                task    = $sys_id
            }
            $UpdateCHGbodyjson = $UpdateCHGbody | ConvertTo-Json  
            # Send HTTP request
            #$response = Invoke-WebRequest -Headers $headers -Method $method -Uri $uri -Body $body
            # Send API request
            Try {
                # Send API request
                $UpdateChangePOSTResponse = $Null
                $UpdateChangePOSTResponse = Invoke-RestMethod -Method POST -Uri $UpdateCHGuri -Body $UpdateCHGbodyjson -TimeoutSec 100 -Headers $headers -ContentType "application/json" -EA stop
                if($UpdateChangePOSTResponse.result.ci_item.value -ne $mycitem -and $ciflag -ne 'Good')
                {
                	$ciflag='Good'
                	$myconfigitem=$UpdateChangePOSTResponse.result.ci_item.value
                }
            }   
            Catch {   
                Write-Host $_.Exception.ToString() 
                $error[0] | Format-List -Force
            }
        }
        if ($myconfigitem -like "*.*") {
            $myconfigitem = $myconfigitem.split('.')[0].trim()
        }
        if ($myconfigitem) {
            $SNuser = $suser #enter your ServiceNow Username
            $SNpass = $spass #enter your ServiceNow Password
            # Build auth header
            $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(("{0}:{1}" -f $SNuser, $SNpass)))
            # Set proper headers
            $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
            $headers.Add('Authorization', ('Basic {0}' -f $base64AuthInfo))
            $headers.Add('Accept', 'application/json')
            $headers.Add('Content-Type', 'application/json')
            # Specify endpoint uri
            $UpdateCHGuri = "$snowlink/api/now/table/incident/$sys_id"
            # Specify HTTP method
            $Patchmethod = "patch"
            # Specify request body
            $UpdateCHGbody = @{ #Create Body of the Post Request
                u_unlisted_ci = $false
                cmdb_ci       = $myconfigitem
            }
            $UpdateCHGbodyjson = $UpdateCHGbody | ConvertTo-Json
            $UpdateChangePOSTResponse = $Null
            try {
                $UpdateChangePOSTResponse = Invoke-RestMethod -Method PUT -Uri $UpdateCHGuri -Body $UpdateCHGbodyjson -TimeoutSec 100 -Headers $headers -ContentType "application/json" -EA stop
            }
            catch {
                $UpdateCHGbody = @{ #Create Body of the Post Request
                    'u_unlisted_ci'            = $true
                    'u_new_configuration_item' = $myconfigitem
                }
                $UpdateCHGbodyjson = $UpdateCHGbody | ConvertTo-Json
                $UpdateChangePOSTResponse = $Null
                $UpdateChangePOSTResponse = Invoke-RestMethod -Method PUT -Uri $UpdateCHGuri -Body $UpdateCHGbodyjson -TimeoutSec 100 -Headers $headers -ContentType "application/json"
            }
        }
        else {
            write-host "No Config item defined"	
        }

    }
    elseif ($configitem) {
        if ($configitem -like "*.*") {
            $configitem = $configitem.split('.')[0].trim()
        }
        $SNuser = $suser #enter your ServiceNow Username
        $SNpass = $spass #enter your ServiceNow Password
        # Build auth header
        $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(("{0}:{1}" -f $SNuser, $SNpass)))
        # Set proper headers
        $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
        $headers.Add('Authorization', ('Basic {0}' -f $base64AuthInfo))
        $headers.Add('Accept', 'application/json')
        $headers.Add('Content-Type', 'application/json')
        # Specify endpoint uri
        $UpdateCHGuri = "$snowlink/api/now/table/incident/$sys_id"
        # Specify HTTP method
        $Patchmethod = "patch"
        # Spcify request body
        $UpdateCHGbody = @{ #Create Body of the Post Request
            'u_unlisted_ci' = $false
            'cmdb_ci'       = $configitem
        }
        $UpdateCHGbodyjson = $UpdateCHGbody | ConvertTo-Json
        # Send HTTP request
        #$response = Invoke-WebRequest -Headers $headers -Method $method -Uri $uri -Body $body
        # Send API request
        $UpdateChangePOSTResponse = $Null
        #$UpdateChangePOSTResponse = Invoke-RestMethod -Method PUT -Uri $UpdateCHGuri -Body $UpdateCHGbodyjson -TimeoutSec 100 -Headers $headers -ContentType "application/json"	
        try {
            $UpdateChangePOSTResponse = Invoke-RestMethod -Method PUT -Uri $UpdateCHGuri -Body $UpdateCHGbodyjson -TimeoutSec 100 -Headers $headers -ContentType "application/json"
        }
        catch {
            $UpdateCHGbody = @{ #Create Body of the Post Request
                'u_unlisted_ci'            = $true
                'u_new_configuration_item' = $configitem
            }
            $UpdateCHGbodyjson = $UpdateCHGbody | ConvertTo-Json
            $UpdateChangePOSTResponse = $Null
            $UpdateChangePOSTResponse = Invoke-RestMethod -Method PUT -Uri $UpdateCHGuri -Body $UpdateCHGbodyjson -TimeoutSec 100 -Headers $headers -ContentType "application/json"
        }
    }
    else {
        write-host "No Config item defined"	
    }

}


if (test-path C:\NBTicketinge5562937DNDELETE\attachments\weeklystatus.txt) {
    Remove-Item C:\NBTicketinge5562937DNDELETE\attachments\weeklystatus.txt -Force	
}

$items = get-childitem C:\NBTicketinge5562937DNDELETE\attachments\ | select FullName
foreach ($itemone in $items) {
    clear-content $itemone.FullName
}

$url = 'http://company.com/backup/Reports/dashboard.html'

$req = Invoke-WebRequest $url

$table = $req.ParsedHtml.getElementsByTagName('table')[1]

$objPropertyNames = ($table.Rows[0].Cells | Select -ExpandProperty innerText -Skip 1).trim()
$total = @()

foreach ($tablerow in ($table.Rows | Select -Skip 1)) {

    $cells = ($tablerow.Cells | Select -ExpandProperty innerText -Skip 1 -ea SilentlyContinue).trim()
    $obj = New-Object -TypeName PSObject
    $count = 0;
    foreach ($cell in $cells) {
        if ($count -lt $objPropertyNames.length) {
            $obj | Add-Member -MemberType NoteProperty -Name $objPropertyNames[$count++] -Value $cell
        }
    }
    $total += $obj
}

$total | select 'Job Summary Failed', 'Status Page'


$locations = ($total | where { $_.'Job Summary Failed' -ne "0 [ 0.00% ]" })."Status Page"

$ftotal = @()




foreach ($location in $locations) {
    $tune = $location.split(" ")[0].trim()

    $url = "http://company.com/backup/Reports/$tune/$tune-job_summary.html"

    write-host "Checking http://company.com/backup/Reports/$tune/$tune-job_summary.html"

    $req = $Null
    write-host " "
    try {
        $req = Invoke-WebRequest $url
    }
    catch {
        write-host "Ignoring http://company.com/backup/Reports/$tune/$tune-job_summary.html"
    }

    if ($req.ParsedHtml.count -ne 0) {
        $table = $req.ParsedHtml.getElementsByTagName('table')[1]

        $objPropertyNames = ($table.Rows[0].Cells | Select -ExpandProperty innerText -Skip 1 -ea SilentlyContinue).trim()

        foreach ($tablerow in ($table.Rows | Select -Skip 1)) {

            if ($tablerow.Cells.length -ne 1) {
                $cells = ($tablerow.Cells | Select -ExpandProperty innerText -Skip 1).trim()
                $obj = New-Object -TypeName PSObject
                $obj | Add-Member -MemberType NoteProperty -Name "Location" -Value $tune -Force
                $obj | Add-Member -MemberType NoteProperty -Name "Location" -Value $tune -Force
                $count = 0;
                foreach ($cell in $cells) {
                    if ($cell -ne "Jobs listed below are failures but not counted in Failed Jobs %") {
                        if ($count -lt $objPropertyNames.length) {
                            $obj | Add-Member -MemberType NoteProperty -Name $objPropertyNames[$count++] -Value $cell
            
                        }
                    }
                }

                try {
                    $chexit = $obj.'ExitCode(s)'.split("`r`n")[0]
                }
                catch {
                    $chexit = $obj.'ExitCode(s)'
                }
   
        
                $curvalue = $obj.Location + " " + $chexit + " " + $obj.Client + " " + $obj.Policy + " " + $obj.Schedule
                $obj | Add-Member -MemberType NoteProperty -Name "singlesubject" -Value $curvalue
                $curvalue = $obj.Location + " " + $chexit + " " + $obj.Policy + " " + $obj.Schedule
                $obj | Add-Member -MemberType NoteProperty -Name "mulsubject" -Value $curvalue

                if (($obj.Policy -like "*SED*") -or ($obj.Location -eq "LTC-L2") -or ($obj.Location -eq "LTC-L3")) {
                    $senow = "KINGSTON"
                }
                else {
                    $senow = "JAKARTA"
                }
                $obj | Add-Member -MemberType NoteProperty -Name "snversion" -Value $senow
                $mastervar = $obj.Location.Trim() + "-" + $chexit
                $obj | Add-Member -MemberType NoteProperty -Name "Mastervar" -Value $mastervar

                $ftotal += $obj
            }
        }



        write-host " "
    }

}



$ftotal.count
$finaltable = @()
$ignoreditem = @()

foreach ($valit in $ftotal) {

    if ($valit.'Additional Comments') {
        $ignoreditem += $valit
    }
    else {
        try {

            write-host "##########"

            $valit.'ExitCode(s)'

            write-host "##########"

            write-host " "

            $mulvalueexit = $valit.'ExitCode(s)'.split("`n")
            $mulvaluets = $valit.'Last Known Time(s)'.split("`n")
            $mulvalueji = $valit.'JobID(s)'.split("`n")
            $count = 0
            foreach ($mvexit in $mulvalueexit) {
                if ($mvexit -ne "") {

                    $finobj = New-Object -TypeName PSObject

                    $finobj | Add-Member -MemberType NoteProperty -Name "Location" -Value $valit.Location.trim()
                    $finobj | Add-Member -MemberType NoteProperty -Name "Exitcode" -Value $mulvalueexit[$count].trim()
                    $finobj | Add-Member -MemberType NoteProperty -Name "JobID" -Value $mulvalueji[$count].trim()
                    $finobj | Add-Member -MemberType NoteProperty -Name "Timestamp" -Value $mulvaluets[$count].trim()
                    $finobj | Add-Member -MemberType NoteProperty -Name "Policy" -Value $valit.Policy.trim()
                    $finobj | Add-Member -MemberType NoteProperty -Name "Schedule" -Value $valit.Schedule.trim()
                    $finobj | Add-Member -MemberType NoteProperty -Name "Client" -Value $valit.Client.trim()
                    $finobj | Add-Member -MemberType NoteProperty -Name "mulsubject" -Value $valit.mulsubject.trim()
                    $finobj | Add-Member -MemberType NoteProperty -Name "singlesubject" -Value $valit.singlesubject.trim()
                    $finobj | Add-Member -MemberType NoteProperty -Name "Mastervar" -Value $valit.Mastervar.trim()
                    $finobj | Add-Member -MemberType NoteProperty -Name "snversion" -Value $valit.snversion.trim()
                    $finobj | Add-Member -MemberType NoteProperty -Name "Path" -Value $valit.Path.trim()

                    #Version 1.1 : Adding the incident Property
                    $finobj | Add-Member -MemberType NoteProperty -Name "Incident" -Value ""

                    $finaltable += $finobj

                    $count = $count + 1
                    write-host "----------------"
                    write-host " "
                }
            }

        }
        catch {

            $finobj | Add-Member -MemberType NoteProperty -Name "Location" -Value $valit.Location.trim()
            $finobj | Add-Member -MemberType NoteProperty -Name "Exitcode" -Value $valit.'ExitCode(s)'.trim()
            $finobj | Add-Member -MemberType NoteProperty -Name "JobID" -Value $valit.'JobID(s)'.trim()
            $finobj | Add-Member -MemberType NoteProperty -Name "Timestamp" -Value $valit.'Last Known Time(s)'.trim()
            $finobj | Add-Member -MemberType NoteProperty -Name "Policy" -Value $valit.Policy.trim()
            $finobj | Add-Member -MemberType NoteProperty -Name "Schedule" -Value $valit.Schedule.trim()
            $finobj | Add-Member -MemberType NoteProperty -Name "Client" -Value $valit.Client.trim()
            $finobj | Add-Member -MemberType NoteProperty -Name "mulsubject" -Value $valit.mulsubject.trim()
            $finobj | Add-Member -MemberType NoteProperty -Name "singlesubject" -Value $valit.singlesubject.trim()
            $finobj | Add-Member -MemberType NoteProperty -Name "Mastervar" -Value $valit.Mastervar.trim()
            $finobj | Add-Member -MemberType NoteProperty -Name "snversion" -Value $valit.snversion.trim()
            $finobj | Add-Member -MemberType NoteProperty -Name "Path" -Value $valit.Path.trim()

            #Version 1.1 : Adding the incident Property
            $finobj | Add-Member -MemberType NoteProperty -Name "Incident" -Value ""


            $finaltable += $finobj
            write-host "----------------"
            write-host " "
        }
    }
}


$ignoreditem.Count
$finaltable.count


$decommtable = @()
$nondecommtable = @()




$vartextr = get-content "C:\NBTicketinge5562937DNDELETE\decomm.txt" 



foreach ($objecty in $finaltable) {

    if (!($vartextr | Select-String $objecty.Client)) {
        $nondecommtable += $objecty

    }
    else {
        $decommtable += $objecty
    }

}


$noactionitems = @("150", "157", "190", "288")
$ignoretable = @()
$ignorefilter = @()

$locationlist = @()
$uniqueticket = @("230", "239", "247")
$uniquetable = @()
$twelevehours = @()


$ignorefiltter = @()
$uniquetables = @()
$twelevehourss = @()


foreach ($t in $nondecommtable) {
    if (($t.Client -eq "*NULL*") -or ($t.Client -eq "NONE")) {
        $ignoreditem += $t
    }
    elseif ($noactionitems -eq $t.Exitcode) {
        $ignoretable += $t
    }
    elseif ($uniqueticket -eq $t.Exitcode) {
        $uniquetables += $t
    }
    elseif ($t.Exitcode -eq 1) {
        if (($t.Policy -like "*sql*") -or ($t.Schedule -like "*sql*") -or ($t.Policy -like "*Exch_DAG*")) {
            $ignorefiltter += $t
        }
        else {
            $ignoreditem += $t
        }
    }
    elseif ($t.Exitcode -eq 2024) {

        $twelevehourss += $t
    }
    else {
        $ignorefiltter += $t
    }
}

if ($ignoreditem.count -ne 0) {
    $ignoreditem | Export-Csv C:\NBTicketinge5562937DNDELETE\attachments\ignored.csv
}
if ($twelevehourss.count -ne 0) {
    $twelevehourss | Export-Csv C:\NBTicketinge5562937DNDELETE\attachments\2024.csv
}
if ($ignorefiltter.count -ne 0) {
    $ignorefiltter | Export-Csv C:\NBTicketinge5562937DNDELETE\attachments\valids.csv
}
if ($uniquetables.count -ne 0) {
    $uniquetables | export-csv C:\NBTicketinge5562937DNDELETE\attachments\failures230239247.csv
}
if ($ignoretable.count -ne 0) {
    $ignoretable | export-csv C:\NBTicketinge5562937DNDELETE\attachments\failures150157190.csv
}
if ($decommtable.count -ne 0) {
    $decommtable | export-csv C:\NBTicketinge5562937DNDELETE\attachments\decomissioned.csv
}


$incidentlist = @()

#speratingmaster
$masterticketnames = $ignorefiltter | where { $_.Exitcode -ne "196" } | Group-Object -Property Mastervar | where { $_.Count -ge 100 }
$finalfilter = @()
$finalfilter = $ignorefiltter | where { $_.mastervar -inotin $masterticketnames.name }
$masterfilters = $ignorefiltter | where { $_.mastervar -iin $masterticketnames.name }

$unigroupversions = $uniquetables | group-object -Property snversion
foreach ($universions in $unigroupversions) {
    $uniquetable = @()
    $uniquetable = $uniquetables | where { $_.snversion -eq $universions.Name }
           
    if ($universions.Name -eq "KINGSTON") {
        $snowparent = "$PROPERTY{GCS_SERVICENOW_LINK}"
        $snowparentuser = $gcsuser
        $snowparentpass = $gcspass
        $snowid = 'Tool Automation'
        $snowby = 'Tool Automation'
        $snowcategory = 'Server'
        $snowsubc = 'SBackup Issue'
        $snowassign = 'Backup Support - Leveraged'
        $snowcompany = 'Sedgwick'
    }
    else {
        $snowparent = "$PROPERTY{SERVICENOW_LINK}"
        $snowparentuser = "$PROPERTY{SERVICENOW_USER}"
        $snowparentpass = "$PROPERTY{SERVICENOW_PASSWORD}"
        $snowid = 'Tool Systems'
        $snowby = 'Tool Systems'
        $snowcategory = 'Backup'
        $snowsubc = 'Job Failure'
        $snowassign = 'Backup NetBackup'
        $snowcompany = 'company'
    }






    if ($uniquetable.count -ne 0) {
        Write-host "working on uniquetable"
        $valser = @{}
        $uniqueitemclients = $uniquetable | group-object -Property Client
        foreach ($utcc in $uniqueitemclients) {
            $mulvalue = $uniquetable | where { $_.Client -eq $utcc.Name }
            foreach ($mval in $mulvalue) {
                $valkey = $mval.Exitcode + "-" + $utcc.Name
                if (!$valser.ContainsKey($valkey)) {
                    [string]$assign = "
                            Timestamp:"+ $mval.Timestamp + "
                            JobID:"+ $mval.JobID + "
                            Policy:"+ $mval.Policy + "
                            Schedule:"+ $mval.Schedule + "
                            Client:"+ $mval.Client + "
                            Exitcode:"+ $mval.Exitcode + "
                            Path:"+ $mval.path + "
                            ____________________________________"
                    $valser.Add($valkey, $assign)
                }
                else {
                    [string]$assign = "
                            Timestamp:"+ $mval.Timestamp + "
                            JobID:"+ $mval.JobID + "
                            Policy:"+ $mval.Policy + "
                            Schedule:"+ $mval.Schedule + "
                            Client:"+ $mval.Client + "
                            Exitcode:"+ $mval.Exitcode + "
                            Path:"+ $mval.path + "
                            ____________________________________"
                    $valser.$valkey += $assign
                }
            }
        }

        foreach ($valkey in $valser.keys) {
            $Requests = $Null
            $user = $snowparentuser
            $password = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
            $credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $user, $password
            #// Get all incidents Assigned To 
            $URI = "$snowparent/api/now/table/incident?sysparm_query=short_description=Single-incident-" + $valkey + "^state=1^NQshort_description=Single-incident-" + $valkey + "^state=2^NQshort_description=Single-incident-" + $valkey + "^state=3" 
            $Requests = Invoke-RestMethod -Uri $URI -Credential $credential -Method GET -ContentType "application/json"   
            if ($Requests.result.count -eq "0") { 
                $nuser = $snowparentuser
                $npassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                $ncredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $nuser, $npassword
                $IncidentURL = "$snowparent/api/now/table/incident"
                $Type = "application/json"
                # Specify request body
                if ($snowparent -like "*ffit*") {
                    $body = @{
                        'impact'            = '4'
                        'urgency'           = '4'
                        'caller_id'         = $snowid
                        'opened_by'         = $snowid
                        'u_request_system'  = 'Tool'
                        'category'          = $snowcategory
                        'subcategory'       = $snowsubc
                        'notify'            = '1'
                        'assignment_group'  = $snowassign
                        'short_description' = 'Single-incident-' + $valkey
                        'contact_type'      = 'Event monitor'
                        #'u_unlisted_ci'     = $true
                        #'u_new_configuration_item' = '' + ($valkey.split("-")[1..50] -join ("-"))
                        'u_business_impact' = 'NA'
                        'company'           = $snowcompany
                        'description'       = '' + $valser.$valkey
                    }
                }
                else {
                    $body = @{
                        'impact'                   = '4'
                        'urgency'                  = '4'
                        'caller_id'                = $snowid
                        'opened_by'                = $snowid
                        'u_request_system'         = 'Tool'
                        'category'                 = $snowcategory
                        'subcategory'              = $snowsubc
                        'notify'                   = '1'
                        'assignment_group'         = $snowassign
                        'short_description'        = 'Single-incident-' + $valkey
                        'contact_type'             = 'Event monitor'
                        'u_unlisted_ci'            = $true
                        'u_new_configuration_item' = '' + ($valkey.split("-")[1..50] -join ("-"))
                        'u_business_impact'        = 'NA'
                        'company'                  = $snowcompany
                        'description'              = '' + $valser.$valkey
                    }
                }
                
                $bodyJson = $body | ConvertTo-Json
                # POST to API
                Try {
                    $IncidentPOSTResponse = Invoke-RestMethod -Method POST -Uri $IncidentURL -Body $bodyJson -TimeoutSec 100 -Credential $ncredential -ContentType $Type
                }
                Catch {
                    Write-Host $_.Exception.ToString()
                    $error[0] | Format-List -Force
                }
                # Pulling ticket ID from response
                $IncidentID = $IncidentPOSTResponse.result.number
            
                ###############################################
                # Verifying Incident created and show ID
                ###############################################
                IF ($IncidentID -ne $null) {
                    "Created Incident With ID:$IncidentID"
                    $incidentlist += $IncidentID + "---" + $IncidentPOSTResponse.result.description
                    #Version 1.1 : Adding the incident Property
                    $universions.group | ? { $_.Exitcode -eq $valkey.split("-", 2)[0] -and $_.Client -eq $valkey.split("-", 2)[1] }  | % { $_.incident = $IncidentID }
                    if ($snowparent -like "*ffit*") {
                        $incsysids = $IncidentPOSTResponse.result.sys_id
                        $incsysids
                        $cliitemlists = $valkey.split("-")[1..50] -join (",")  
                        $cliitemlists
                        updateci -configitem $cliitemlists -snowlink $snowparent -sys_id $incsysids  -spass $snowparentpass -suser $snowparentuser 
                    }
                }
                ELSE {
                    "Incident Not Created"

                    #Version 1.1 : Adding the incident Property
                    $universions.group | ? { $_.Exitcode -eq $valkey.split("-", 2)[0] -and $_.Client -eq $valkey.split("-", 2)[1] }  | % { $_.incident = "NA" }
                }
            }
            else {
                foreach ($Incident in $Requests.result) { 
                    $fnewdesc = @()
                    $newclients = @()
                    foreach ($tval in $uniquetable) {
                        $ignoredesc = @()
                        if (!($Incident.description.trim() | select-string $tval.JobID) -and ($Incident.short_description.trim() | select-string $tval.Client)) {
                            $fnewdesc += "
                           Timestamp:"+ $tval.Timestamp + "
                           JobID:"+ $tval.JobID + "
                           Policy:"+ $tval.Policy + "
                           Schedule:"+ $tval.Schedule + "
                           Client:"+ $tval.Client + "
                           Exitcode:"+ $tval.Exitcode + "
                           Path:"+ $tval.Path + "
                           ____________________________________"
                            if (!($Incident.description.trim() | select-string $tval.Client)) {
                                $newclients += $tval.Client
                            }
                        }
                        else {
                            $ignoredesc = "Timestamp:" + $tval.Timestamp + "JobID:" + $tval.JobID + "Policy:" + $tval.Policy + "Schedule:" + $tval.Schedule + "Client:" + $tval.Client + "
                                  "  
                            write-host 'ignoring'$ignoredesc
                        }
                    }
                    if ($fnewdesc) {
                        $itemsys = $Incident.sys_id
                        $mRequests = $Null
                        $muser = 'Tool'
                        $mpassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                        $mcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $muser, $mpassword
                        $mbody = @{
                            'description' = $Incident.description + "
                                        "+ $fnewdesc + "
                                        "
                        }
                        $mbodyJson = $mbody | ConvertTo-Json
                        $mURI = "$snowparent/api/now/table/incident/$itemsys"
                        $mRequests = Invoke-WebRequest -Uri $mURI  -Method PUT -Credential $mcredential -Body $mbodyJson -TimeoutSec 100 -ContentType "application/json"
                        if (($snowparent -like "*ffit*") -and ($newclients -ne $Null) -and ($Incident.sys_id -ne $Null)) {
                            $incsysids = $Incident.sys_id
                            $incsysids
                            $cliitemlists = $newclients -join (",")  
                            $cliitemlists
                            updateci -configitem $cliitemlists -snowlink $snowparent -sys_id $incsysids  -spass $snowparentpass -suser $snowparentuser 
                        }
                        if ($mRequests.StatusDescription -eq "OK") {
                            $incidentlist += $Incident.number + "---" + $Incident.short_description
                            
                            #Version 1.1 : Adding the incident Property
                            $universions.group | ? { $_.Exitcode -eq $valkey.split("-", 2)[0] -and $_.Client -eq $valkey.split("-", 2)[1] }  | % { $_.incident = $Incident.number }

                        }
                    }
                    else {
                        write-host "No modification required for"$Incident.number
                        
                        #Version 1.1 : Adding the incident Property
                        $universions.group | ? { $_.Exitcode -eq $valkey.split("-", 2)[0] -and $_.Client -eq $valkey.split("-", 2)[1] }  | % { $_.incident = $Incident.number }
                    }
                }
            }
    
        }
    }
}


$masgroupversions = $masterfilters | group-object -Property snversion
foreach ($masversions in $masgroupversions) {
    $masterfilter = @()
    $masterfilter = $masterfilters | where { $_.snversion -eq $masversions.Name }
           
    if ($masversions.Name -eq "KINGSTON") {
        $snowparent = "$PROPERTY{GCS_SERVICENOW_LINK}"
        $snowparentuser = $gcsuser
        $snowparentpass = $gcspass
        $snowid = 'Tool Automation'
        $snowby = 'Tool Automation'
        $snowcategory = 'Server'
        $snowsubc = 'SBackup Issue'
        $snowassign = 'Backup Support - Leveraged'
        $snowcompany = 'Sedgwick'
    }
    else {
        $snowparent = "$PROPERTY{SERVICENOW_LINK}"
        $snowparentuser = "$PROPERTY{SERVICENOW_USER}"
        $snowparentpass = "$PROPERTY{SERVICENOW_PASSWORD}"
        $snowid = 'Tool Systems'
        $snowby = 'Tool Systems'
        $snowcategory = 'Backup'
        $snowsubc = 'Job Failure'
        $snowassign = 'Backup NetBackup'
        $snowcompany = 'company'
    }


    if ($masterfilter.count -ne 0) {  

        Write-host "working on Master ticket"
        $masser = @{}
        foreach ($masval in $masterfilter) {

            $msalkey = $masval.Mastervar
            if (!$masser.ContainsKey($msalkey)) {
                [string]$massign = "
                            Timestamp:"+ $masval.Timestamp + "
                            JobID:"+ $masval.JobID + "
                            Policy:"+ $masval.Policy + "
                            Schedule:"+ $masval.Schedule + "
                            Client:"+ $masval.Client + "
                            Exitcode:"+ $masval.Exitcode + "
                            Path:"+ $masval.path + "
                            ____________________________________"
                $masser.Add($msalkey, $massign)
            }
            else {
                [string]$massign = "
                            Timestamp:"+ $masval.Timestamp + "
                            JobID:"+ $masval.JobID + "
                            Policy:"+ $masval.Policy + "
                            Schedule:"+ $masval.Schedule + "
                            Client:"+ $masval.Client + "
                            Exitcode:"+ $masval.Exitcode + "
                            Path:"+ $masval.path + "
                            ____________________________________"
                $masser.$msalkey += $massign
            }
        }  

        foreach ($msalkey in $masser.keys) {
            $mmRequests = $Null
            $mmuser = $snowparentuser
            $mmpassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
            $mmcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $mmuser, $mmpassword
            #// Get all incidents Assigned To 
            $mmURI = "$snowparent/api/now/table/incident?sysparm_query=short_description=Master-incident-" + $msalkey + "^state=1^NQshort_description=Master-incident-" + $msalkey + "^state=2^NQshort_description=Master-incident-" + $msalkey + "^state=3" 
            $mmRequests = Invoke-RestMethod -Uri $mmURI -Credential $mmcredential -Method GET -ContentType "application/json"   
            if ($mmRequests.result.count -eq "0") { 
                $mnuser = $snowparentuser
                $mnpassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                $mncredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $mnuser, $mnpassword
                $mnIncidentURL = "$snowparent/api/now/table/incident"
                $Type = "application/json"
                # Specify request body
                $mnbody = @{
                    'impact'                   = '4'
                    'urgency'                  = '4'
                    'caller_id'                = $snowid
                    'opened_by'                = $snowid
                    'u_request_system'         = 'Tool'
                    'category'                 = $snowcategory
                    'subcategory'              = $snowsubc
                    'notify'                   = '1'
                    'assignment_group'         = $snowassign
                    'short_description'        = 'Master-incident-' + $msalkey
                    'contact_type'             = 'Event monitor'
                    'u_unlisted_ci'            = $true
                    'u_new_configuration_item' = 'Multiple Failures'
                    'u_business_impact'        = 'NA'
                    'company'                  = $snowcompany
                    'description'              = '' + $masser.$msalkey
                }
                $mnbodyJson = $mnbody | ConvertTo-Json
                # POST to API
                Try {
                    $mnIncidentPOSTResponse = Invoke-RestMethod -Method POST -Uri $mnIncidentURL -Body $mnbodyJson -TimeoutSec 100 -Credential $mncredential -ContentType $Type
                }
                Catch {
                    Write-Host $_.Exception.ToString()
                    $error[0] | Format-List -Force
                }
                # Pulling ticket ID from response
                $IncidentID = $mnIncidentPOSTResponse.result.number
            
                ###############################################
                # Verifying Incident created and show ID
                ###############################################
            
                IF ($IncidentID -ne $null) {
                    "Created Incident With ID:$IncidentID"
                    $incidentlist += $IncidentID + "---" + $mnIncidentPOSTResponse.result.description

                    #Version 1.1 : Adding the incident Property
                    $masversions.group | ? { $_.Mastervar -eq $msalkey }  | % { $_.incident = $IncidentID }
                }
                ELSE {
                    "Incident Not Created"

                    #Version 1.1 : Adding the incident Property
                    $masversions.group | ? { $_.Mastervar -eq $msalkey }  | % { $_.incident = "NA" }
                }
            }
            else {
                foreach ($Incident in $mmRequests.result) { 
                    $fnewdesc = @()
                    foreach ($mtval in $masterfilter) {
                        $ignoredesc = @()
                        if (!($Incident.description.trim() | select-string $mtval.JobID)) {
                            $fnewdesc += "
                           Timestamp:"+ $mtval.Timestamp + "
                           JobID:"+ $mtval.JobID + "
                           Policy:"+ $mtval.Policy + "
                           Schedule:"+ $mtval.Schedule + "
                           Client:"+ $mtval.Client + "
                           Exitcode:"+ $mtval.Exitcode + "
                           Path:"+ $mtval.path + "
                           ____________________________________"
                           
                        }
                        else {
                            $ignoredesc = "Timestamp:" + $mtval.Timestamp + "JobID:" + $mtval.JobID + "Policy:" + $mtval.Policy + "Schedule:" + $mtval.Schedule + "Client:" + $mtval.Client + "
                                  "  
                            write-host 'ignoring'$ignoredesc
                        }
                    }
                    if ($fnewdesc) {
                        $itemsys = $Incident.sys_id
                        $mmmRequests = $Null
                        $mmmuser = $snowparentuser
                        $mmmpassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                        $mmmcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $mmmuser, $mmmpassword
                        $mmmbody = @{
                            'description' = $Incident.description + "
                                        "+ $fnewdesc + "
                                        "
                        }
                        $mmmbodyJson = $mmmbody | ConvertTo-Json
                        $mmmURI = "$snowparent/api/now/table/incident/$itemsys"
                        $mmmRequests = Invoke-WebRequest -Uri $mmmURI  -Method PUT -Credential $mmmcredential -Body $mbodyJson -TimeoutSec 100 -ContentType "application/json"

                        if ($mmmRequests.StatusDescription -eq "OK") {
                            $incidentlist += $Incident.number + "---" + $Incident.short_description

                            #Version 1.1 : Adding the incident Property
                            $masversions.group | ? { $_.Mastervar -eq $msalkey }  | % { $_.incident = $Incident.number }

                        }
                    }
                    else {
                        write-host "No modification required for"$Incident.number

                        #Version 1.1 : Adding the incident Property
                        $masversions.group | ? { $_.Mastervar -eq $msalkey }  | % { $_.incident = $Incident.number }
                    }
                }
            }
    
        }

    }
}

 
$groupversions = $finalfilter | group-object -Property snversion

foreach ($mversions in $groupversions) {

    $ignorefilter = @()
    $ignorefilter = $finalfilter | where { $_.snversion -eq $mversions.Name }





    if ($mversions.Name -eq "KINGSTON") {
        $snowparent = "$PROPERTY{GCS_SERVICENOW_LINK}"
        $snowparentuser = $gcsuser
        $snowparentpass = $gcspass
        $snowid = 'Tool Automation'
        $snowby = 'Tool Automation'
        $snowcategory = 'Server'
        $snowsubc = 'SBackup Issue'
        $snowassign = 'Backup Support - Leveraged'
        $snowcompany = 'Sedgwick'
    }
    else {
        $snowparent = "$PROPERTY{SERVICENOW_LINK}"
        $snowparentuser = "$PROPERTY{SERVICENOW_USER}"
        $snowparentpass = "$PROPERTY{SERVICENOW_PASSWORD}"
        $snowid = 'Tool Systems'
        $snowby = 'Tool Systems'
        $snowcategory = 'Backup'
        $snowsubc = 'Job Failure'
        $snowassign = 'Backup NetBackup'
        $snowcompany = 'company'
    }
                        


    if ($ignorefilter.count -ne 0) { 
        Write-host "Working on other filters"
    
        $exitcodes = ($ignorefilter | group-object Exitcode).Name
        foreach ($exitcode in $exitcodes) {
        
            write-host "Checking $exitcode"
            $arrname = $ignorefilter | where { $_.Exitcode -eq $exitcode }
            $subitems = $arrname | group-object singlesubject
            $sinavailvalues = @()
            $mulunivalues = @()
            $finavailvalues = @()
            foreach ($sitems in $subitems) {
            
                write-host "checking Single"+($sitems.Name)
                $kRequests = $Null
                $searchsub = $sitems.Name
                $kuser = $snowparentuser
                $kpassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                $kcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $kuser, $kpassword
                #// Get all incidents Assigned To
                $kURI = "$snowparent/api/now/table/incident?sysparm_query=short_description=Single-incident-" + $searchsub + "^state=1^NQshort_description=Single-incident-" + $searchsub + "^state=2^NQshort_description=Single-incident-" + $searchsub + "^state=3" 
                $kRequests = Invoke-RestMethod -Uri $kURI -Credential $kcredential -Method GET -ContentType "application/json"
                if ($kRequests.result.count -ne "0") {   
                    $invalues = @()
                    $invalues = $arrname | Where-Object { $_.singlesubject -eq $sitems.Name }
                    $sinavailvalues += $arrname | Where-Object { $_.singlesubject -eq $sitems.Name }
                    write-host " "
                    write-host "Matching incident found"+($sitems.Name)
                    foreach ($Incident in $kRequests.result) { 
                        $fnewdesc = @()
                        $newclients = @()
                        foreach ($tval in $invalues) {
                            $ignoredesc = @()
                            if (!($Incident.description.trim() | select-string $tval.JobID)) {
                                $fnewdesc += "
                               Timestamp:"+ $tval.Timestamp + " 
                               JobID:"+ $tval.JobID + " 
                               Policy:"+ $tval.Policy + " 
                               Schedule:"+ $tval.Schedule + " 
                               Client:"+ $tval.Client + "
                               Exitcode:"+ $tval.Exitcode + "
                               Path:"+ $tval.path + "
                               ____________________________________"
                                if (!($Incident.description.trim() | select-string $tval.Client)) {
                                    $newclients += $tval.Client
                                }
                                write-host "Adding in Single $fnewdesc"
                            }
                            else {
                                $ignoredesc = "Timestamp:" + $tval.Timestamp + "JobID:" + $tval.JobID + "Policy:" + $tval.Policy + "Schedule:" + $tval.Schedule + "Client:" + $tval.Client + "
                       "  
                                write-host 'ignoring'$ignoredesc
                            }
                
                            if ($fnewdesc) {
                                $itemsys = $Incident.sys_id
                                $lRequests = $Null
                                $luser = $snowparentuser
                                $lpassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                                $lcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $luser, $lpassword
                                $lbody = @{
                                    'description' = $Incident.description + "
                                    "+ $fnewdesc + "
                                    "
                                }
                                $lbodyJson = $lbody | ConvertTo-Json
                                $lURI = "$snowparent/api/now/table/incident/$itemsys"
                                $lRequests = Invoke-WebRequest -Uri $lURI  -Method PUT -Credential $lcredential -Body $lbodyJson -TimeoutSec 100 -ContentType "application/json"
                                if ($lRequests.StatusDescription -eq "OK") {
                                    $incidentlist += "Updated:-" + $Incident.number + "______" + $Incident.short_description
                                    if (($snowparent -like "*ffit*") -and ($newclients -ne $Null) -and ($Incident.sys_id -ne $Null)) {
                                        $incsysids = $Incident.sys_id
                                        $incsysids
                                        $cliitemlists = $newclients -join (",")  
                                        $cliitemlists
                                        updateci -configitem $cliitemlists -snowlink $snowparent -sys_id $incsysids  -spass $snowparentpass -suser $snowparentuser 
                                    }
                                    #Version 1.1 : Adding the incident Property
                                    $mversions.group | ? { $_.singlesubject -eq $sitems.Name }  | % { $_.incident = $Incident.number }
                                }
                            }
                            else {
                                write-host "No modification required for"$Incident.number
                    
                                #Version 1.1 : Adding the incident Property
                                $mversions.group | ? { $_.singlesubject -eq $sitems.Name }  | % { $_.incident = $Incident.number }
                            }
                        } #addlogic
                        write-host " "
                    }
                }
                else {
                    write-host " "
                    write-host "Matching incident not found in Single"+($sitems.Name)
                    $mulunivalues += $arrname | Where-Object { $_.singlesubject -eq ($sitems.Name) }
                    write-host " "

                    #Version 1.1 : Adding the incident Property
                    $mversions.group | ? { $_.singlesubject -eq $sitems.Name }  | % { $_.incident = "NA" }

                }
    
            }

        

            if ($mulunivalues) {
            
                $subuitems = $mulunivalues | group-object -Property mulsubject 
                foreach ($suitems in $subuitems) {
                    write-host " "
                    write-host "Checking multivalues"
                    $Requestsone = $Null
                    $userone = $snowparentuser
                    $passwordone = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                    $credentialone = new-object -typename System.Management.Automation.PSCredential -argumentlist $userone, $passwordone
                    $searchsub = "Multiple-incident-" + $suitems.Name
                    $URIone = "$snowparent/api/now/table/incident?sysparm_query=short_description=" + $searchsub + "^state=1^NQshort_description=" + $searchsub + "^state=2^NQshort_description=" + $searchsub + "^state=3"
                    $Requestsone = Invoke-RestMethod -Uri $URIone -Credential $credentialone -Method GET -ContentType "application/json"
                    if ($Requestsone.result.count -ne "0") {
                        $minvalues = @()
                        $minvalues = $mulunivalues | where { $_.mulsubject -eq $suitems.Name }
                        foreach ($Incident in $Requestsone.result) { 
                            $fnewdesc = @()
                            $fnewsers = @()
                            foreach ($tval in $minvalues) {
                                $ignoredesc = @()
                                if (!($Incident.description.trim() | select-string $tval.JobID)) {
                                    $fnewdesc += "
                               Timestamp:"+ $tval.Timestamp + " 
                               JobID:"+ $tval.JobID + " 
                               Policy:"+ $tval.Policy + " 
                               Schedule:"+ $tval.Schedule + " 
                               Client:"+ $tval.Client + "
                               Exitcode:"+ $tval.Exitcode + "
                               Path:"+ $tval.path + "
                               ____________________________________"
                                    if (!($Incident.description.trim() | select-string $tval.Client)) {
                                        $fnewsers += $tval.Client
                                    }
                                    write-host "Adding in multiple $fnewdesc"
                                }
                                else {
                                    $ignoredesc = "Timestamp:" + $tval.Timestamp + "JobID:" + $tval.JobID + "Policy:" + $tval.Policy + "Schedule:" + $tval.Schedule + "Client:" + $tval.Client + "
                            "  
                                    write-host 'ignoring'$ignoredesc
                                }
                            }
                            $fnewsers = $fnewsers | Get-Unique
                            $fnewsers = $fnewsers -join (",")
                            if ($fnewdesc) {
                                $itemsys = $Incident.sys_id
                                $quser = $snowparentuser
                                $qpassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                                $qcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $quser, $qpassword
                                $qbody = @{
                                    'description'              = $Incident.description + "
                                         "+ $fnewdesc + "
                                         "               
                                    'u_new_configuration_item' = $Incident.u_new_configuration_item + ',' + $fnewsers
                                }
                                $qbodyJson = $qbody | ConvertTo-Json
                                $qURI = "$snowparent/api/now/table/incident/$itemsys"
                                $qRequests = Invoke-WebRequest -Uri $qURI  -Method PUT -Credential $qcredential -Body $qbodyJson -TimeoutSec 100 -ContentType "application/json"
                                if ($qRequests.StatusDescription -eq "OK") {
                                    $incidentlist += "Updated:-" + $Incident.number + "______" + $Incident.short_description
                                    if (($snowparent -like "*ffit*") -and ($fnewsers -ne $Null) -and ($Incident.sys_id -ne $Null)) {
                                        $incsysids = $Incident.sys_id
                                        $incsysids
                                        $cliitemlists = $fnewsers
                                        $cliitemlists
                                        updateci -configitem $cliitemlists -snowlink $snowparent -sys_id $incsysids  -spass $snowparentpass -suser $snowparentuser 
                                    }
                                    #Version 1.1 : Adding the incident Property
                                    $mversions.group | ? { $_.mulsubject -eq $suitems.Name }  | % { $_.incident = $Incident.number }
                                }
                            }
                            else {
                                write-host "No modification required for"$Incident.number
                         
                                #Version 1.1 : Adding the incident Property
                                $mversions.group | ? { $_.mulsubject -eq $suitems.Name }  | % { $_.incident = $Incident.number }
                            }
                        }
                    }
                    else {
                        write-host " "
                        write-host "Matching incident not found in multivalue"+($suitems.Name)
                        $finavailvalues += $mulunivalues | Where-Object { $_.mulsubject -eq ($suitems.Name) }
                        write-host " "

                        #Version 1.1 : Adding the incident Property
                        $mversions.group | ? { $_.mulsubject -eq $suitems.Name }  | % { $_.incident = "NA" }
                    }
                }

            }
            if ($finavailvalues) {

                write-host " "
                write-host "going to create incident "
                $finavailvalues | ft Client, Exitcode
                $intervalues = @()
                $intvalues = @()
                $singlevalues = @()
                $singlevaluesi = @()
                $intervaluesi = @()
                $checkclient = @()
                $intervaluesi = $finavailvalues | Group-Object -Property mulsubject | Where { $_.Count -ne 1 } | select Count, Name 
                $singlevaluesi = $finavailvalues | Group-Object -Property mulsubject | Where { $_.Count -eq 1 } | select Count, Name
                $singlevalues += $singlevaluesi.Name
                foreach ($ivalues in $intervaluesi) {
                    $checkclient = $finavailvalues | where { $_.mulsubject -eq $ivalues.Name }
                    if ((($checkclient.Client | get-unique).count) -ne 1) {
                    
                        $intvalues += $ivalues.Name
                    }
                    else {
                    
                        $singlevalues += $ivalues.Name
                    
               
                    }
                }

                $singlevalues = $singlevalues | Where-Object { $_ }
                $intvalues = $intvalues | Where-Object { $_ }

                if ($intvalues) {
                    foreach ($muinvalues in $intvalues) {
             
                        $crinvalues = $finavailvalues | where { $_.mulsubject -eq $muinvalues }
                        $fnewdesc = @()
                        $fnewsers = @()
                        $searchsub = $Null
                        $initems = $crinvalues | group-object -Property mulsubject
                        $searchsub = "Multiple-incident-" + $initems.Name
                        foreach ($tval in $crinvalues) {
                            $fnewdesc += "
                               Timestamp:"+ $tval.Timestamp + " 
                               JobID:"+ $tval.JobID + " 
                               Policy:"+ $tval.Policy + " 
                               Schedule:"+ $tval.Schedule + " 
                               Client:"+ $tval.Client + "
                               Exitcode:"+ $tval.Exitcode + "
                               Path:"+ $tval.path + "
                               ____________________________________"

                            $fnewsers += $tval.Client
                        }
                        $fnewsers = $fnewsers | Get-Unique
                        $fnewsers -join (",")
                        $rIncidentPOSTResponse = $Null
                        $ruser = $snowparentuser
                        $rpassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                        $rcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $ruser, $rpassword
                        $rIncidentURL = "$snowparent/api/now/table/incident"
                        $Type = "application/json"
                        # Specify request body
                        if ($snowparent -like "*ffit*") {
                            $rbody = @{
                                'impact'            = '4'
                                'urgency'           = '4'
                                'caller_id'         = $snowid
                                'opened_by'         = $snowid
                                'u_request_system'  = 'Tool'
                                'category'          = $snowcategory
                                'subcategory'       = $snowsubc
                                'notify'            = '1'
                                'assignment_group'  = $snowassign
                                'short_description' = $searchsub
                                'contact_type'      = 'Event monitor'
                                #'u_unlisted_ci'     = $true
                                #'u_new_configuration_item' = '' + ($valkey.split("-")[1..50] -join ("-"))
                                'u_business_impact' = 'NA'
                                'company'           = $snowcompany
                                'description'       = '' + $fnewdesc
                            }
                        }
                        else {
                            $rbody = @{
                                'impact'                   = '4'
                                'urgency'                  = '4'
                                'caller_id'                = $snowid
                                'opened_by'                = $snowid
                                'u_request_system'         = 'Tool'
                                'category'                 = $snowcategory
                                'subcategory'              = $snowsubc
                                'notify'                   = '1'
                                'assignment_group'         = $snowassign
                                'short_description'        = $searchsub
                                'contact_type'             = 'Event monitor'
                                'u_unlisted_ci'            = $true
                                'u_new_configuration_item' = '' + $fnewsers
                                'u_business_impact'        = 'NA'
                                'company'                  = $snowcompany
                                'description'              = '' + $fnewdesc
                            }
                        }
                        $rbodyJson = $rbody | ConvertTo-Json
                        # POST to API
                        Try {
                            $rIncidentPOSTResponse = Invoke-RestMethod -Method POST -Uri $rIncidentURL -Body $rbodyJson -TimeoutSec 100 -Credential $rcredential -ContentType $Type
                        }
                        Catch {
                            Write-Host $_.Exception.ToString()
                            $error[0] | Format-List -Force
                        }
                        # Pulling ticket ID from response
                        $IncidentID = $rIncidentPOSTResponse.result.number
                        ###############################################
                        # Verifying Incident created and show ID
                        ###############################################
                        IF ($IncidentID -ne $null) {
                            "Created Incident With ID:$IncidentID"
                            $incidentlist += "Created multiple:-" + $IncidentID + "____" + $rIncidentPOSTResponse.result.short_description

                            #Version 1.1 : Adding the incident Property
                            $mversions.group | ? { $_.mulsubject -eq $muinvalues }  | % { $_.incident = $IncidentID }

                            if ($snowparent -like "*ffit*") {
                                $incsysids = $rIncidentPOSTResponse.result.sys_id
                                $incsysids
                                $cliitemlists = $fnewsers -join (',')
                                $cliitemlists
                                updateci -configitem $cliitemlists -snowlink $snowparent -sys_id $incsysids  -spass $snowparentpass -suser $snowparentuser 
                            }
                        }
                        ELSE {
                            "Incident Not Created for $initems"

                            #Version 1.1 : Adding the incident Property
                            $mversions.group | ? { $_.mulsubject -eq $muinvalues }  | % { $_.incident = "NA" }
                        }

                    }
            
            
                }
            
            
                if ($singlevalues) {
                    foreach ($suinvalues in $singlevalues) {
                    
                        $crinvalues = $finavailvalues | where { $_.mulsubject -eq $suinvalues }
                        $fnewdesc = @()
                        $fnewsers = @()
                        $searchsub = $Null
                        $initems = $crinvalues | group-object -Property singlesubject
                        $searchsub = "Single-incident-" + $initems.Name
                        foreach ($tval in $crinvalues) {
                            $fnewdesc += "
                               Timestamp:"+ $tval.Timestamp + " 
                               JobID:"+ $tval.JobID + " 
                               Policy:"+ $tval.Policy + " 
                               Schedule:"+ $tval.Schedule + " 
                               Client:"+ $tval.Client + "
                               Exitcode:"+ $tval.Exitcode + "
                               Path:"+ $tval.path + "
                               ____________________________________"

                            $fnewsers += $tval.Client
                        }
                        $fnewsers = $fnewsers | Get-Unique
                        $fnewsers -join (",")
                        $sIncidentPOSTResponse = $Null
                        $suser = $snowparentuser
                        $spassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                        $scredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $suser, $spassword
                        $sIncidentURL = "$snowparent/api/now/table/incident"
                        $Type = "application/json"
                        # Specify request body
                        if ($snowparent -like "*ffit*") {
                            $sbody = @{
                                'impact'            = '4'
                                'urgency'           = '4'
                                'caller_id'         = $snowid
                                'opened_by'         = $snowid
                                'u_request_system'  = 'Tool'
                                'category'          = $snowcategory
                                'subcategory'       = $snowsubc
                                'notify'            = '1'
                                'assignment_group'  = $snowassign
                                'short_description' = $searchsub
                                'contact_type'      = 'Event monitor'
                                #'u_unlisted_ci'            = $true
                                #'u_new_configuration_item' = '' + $fnewsers
                                'u_business_impact' = 'NA'
                                'company'           = $snowcompany
                                'description'       = '' + $fnewdesc
                            }
                        }
                        else {
                            $sbody = @{
                                'impact'                   = '4'
                                'urgency'                  = '4'
                                'caller_id'                = $snowid
                                'opened_by'                = $snowid
                                'u_request_system'         = 'Tool'
                                'category'                 = $snowcategory
                                'subcategory'              = $snowsubc
                                'notify'                   = '1'
                                'assignment_group'         = $snowassign
                                'short_description'        = $searchsub
                                'contact_type'             = 'Event monitor'
                                'u_unlisted_ci'            = $true
                                'u_new_configuration_item' = '' + $fnewsers
                                'u_business_impact'        = 'NA'
                                'company'                  = $snowcompany
                                'description'              = '' + $fnewdesc
                            }
                        }
                        $sbodyJson = $sbody | ConvertTo-Json
                        # POST to API
                        Try {
                            $sIncidentPOSTResponse = Invoke-RestMethod -Method POST -Uri $sIncidentURL -Body $sbodyJson -TimeoutSec 100 -Credential $scredential -ContentType $Type
                        }
                        Catch {
                            Write-Host $_.Exception.ToString()
                            $error[0] | Format-List -Force
                        }
                        # Pulling ticket ID from response
                        $IncidentID = $sIncidentPOSTResponse.result.number
                        ###############################################
                        # Verifying Incident created and show ID
                        ###############################################
                        IF ($IncidentID -ne $null) {
                            "Created Incident With ID:$IncidentID"
                            $incidentlist += "Created single:-" + $IncidentID + "____" + $sIncidentPOSTResponse.result.short_description
                            if ($snowparent -like "*ffit*") {
                                $incsysids = $sIncidentPOSTResponse.result.sys_id
                                $incsysids
                                $cliitemlists = $fnewsers -join (',')
                                $cliitemlists
                                updateci -configitem $cliitemlists -snowlink $snowparent -sys_id $incsysids  -spass $snowparentpass -suser $snowparentuser 
                            }
                            #Version 1.1 : Adding the incident Property
                            $mversions.group | ? { $_.mulsubject -eq $suinvalues }  | % { $_.incident = $IncidentID }
                        }
                        ELSE {
                            "Incident Not Created for $initems"

                            #Version 1.1 : Adding the incident Property
                            $mversions.group | ? { $_.mulsubject -eq $suinvalues }  | % { $_.incident = "NA" }
                        }

                    }
            
            
                }
                  
                


            }


        }
        
    }


}



$twgroupversions = $twelevehourss | group-object -Property snversion

foreach ($tversions in $twgroupversions) {

    $twelevehours = @()
    $twelevehours = $twelevehourss | where { $_.snversion -eq $tversions.Name }
           
    if ($mversions.Name -eq "KINGSTON") {
        $snowparent = "$PROPERTY{GCS_SERVICENOW_LINK}"
        $snowparentuser = $gcsuser
        $snowparentpass = $gcspass
        $snowid = 'Tool Automation'
        $snowby = 'Tool Automation'
        $snowcategory = 'Server'
        $snowsubc = 'SBackup Issue'
        $snowassign = 'Backup Support - Leveraged'
        $snowcompany = 'Sedgwick'
    }
    else {
        $snowparent = "$PROPERTY{SERVICENOW_LINK}"
        $snowparentuser = "$PROPERTY{SERVICENOW_USER}"
        $snowparentpass = "$PROPERTY{SERVICENOW_PASSWORD}"
        $snowid = 'Tool Systems'
        $snowby = 'Tool Systems'
        $snowcategory = 'Backup'
        $snowsubc = 'Job Failure'
        $snowassign = 'Backup NetBackup'
        $snowcompany = 'company'
    }




    if ($twelevehours.count -ne 0) {

        $exitcode = "2024"
        $newtable = @()
        $fortable = $twelevehours | Select-Object -Property * -ExcludeProperty singlkey
        $lists = $fortable | where { $_.Exitcode -eq $exitcode }
        $uplists = $lists | group-object -Property Client
        foreach ($utccv in $uplists) {
            $mulvaluev = $lists | where { $_.Client -eq $utccv.Name }
            foreach ($mvalv in $mulvaluev) {
                $valkeyv = $mvalv.Exitcode + "-" + $utccv.Name
                $mvalv | Add-Member -MemberType NoteProperty -Name "singlkey" -Value $valkeyv
                $newtable += $mvalv
            }
        }

        $nuplists = $newtable | group-object -Property singlkey

        foreach ($itemlist in $nuplists) {
            $xRequests = $Null
            $searchsub = $itemlist.Name
            $xuser = $snowparentuser
            $xpassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
            $xcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $xuser, $xpassword
            #// Get all incidents Assigned To
            $xURI = "$snowparent/api/now/table/incident?sysparm_query=short_description=Single-incident-" + $searchsub + "^state=1^NQshort_description=Single-incident-" + $searchsub + "^state=2^NQshort_description=Single-incident-" + $searchsub + "^state=3" 
            $xRequests = Invoke-RestMethod -Uri $xURI -Credential $xcredential -Method GET -ContentType "application/json"
            if ($xRequests.result.count -eq 0) {
                $crinvalues = $newtable | where { $_.singlkey -eq $searchsub }
                $fnewdesc = @()
                $fnewsers = @()
                $searchsub = $Null
                $initems = $crinvalues | group-object -Property singlkey
                $searchsub = "Single-incident-" + ($itemlist.Name)
                foreach ($tval in $crinvalues) {
                    $fnewdesc += "
                               Timestamp:"+ $tval.Timestamp + " 
                               JobID:"+ $tval.JobID + " 
                               Policy:"+ $tval.Policy + " 
                               Schedule:"+ $tval.Schedule + " 
                               Client:"+ $tval.Client + "
                               Exitcode:"+ $tval.Exitcode + "
                               Path:"+ $tval.path + "
                               ____________________________________"

                    $fnewsers += $tval.Client
                }
                $fnewsers = $fnewsers | Get-Unique
                $fnewsers -join (",")
                $yuser = $snowparentuser
                $ypassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                $ycredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $yuser, $ypassword
                $yIncidentURL = "$snowparent/api/now/table/incident"
                $Type = "application/json"
                # Specify request body
                if ($snowparent -like "*ffit*") {
                    $ybody = @{
                        'impact'            = '4'
                        'urgency'           = '4'
                        'caller_id'         = $snowid
                        'opened_by'         = $snowid
                        'u_request_system'  = 'Tool'
                        'category'          = $snowcategory
                        'subcategory'       = $snowsubc
                        'notify'            = '1'
                        'assignment_group'  = $snowassign
                        'short_description' = $searchsub
                        'contact_type'      = 'Event monitor'
                        #'u_unlisted_ci'     = $true
                        #'u_new_configuration_item' = '' + ($valkey.split("-")[1..50] -join ("-"))
                        'u_business_impact' = 'NA'
                        'company'           = $snowcompany
                        'description'       = '' + $fnewdesc
                    }
                }
                else {
                    $ybody = @{
                        'impact'                   = '4'
                        'urgency'                  = '4'
                        'caller_id'                = $snowid
                        'opened_by'                = $snowid
                        'u_request_system'         = 'Tool'
                        'category'                 = $snowcategory
                        'subcategory'              = $snowsubc
                        'notify'                   = '1'
                        'assignment_group'         = $snowassign
                        'short_description'        = $searchsub
                        'contact_type'             = 'Event monitor'
                        'u_unlisted_ci'            = $true
                        'u_new_configuration_item' = '' + $fnewsers
                        'u_business_impact'        = 'NA'
                        'company'                  = $snowcompany
                        'description'              = '' + $fnewdesc
                    }
                }
                $ybodyJson = $ybody | ConvertTo-Json
                # POST to API
                Try {
                    $yIncidentPOSTResponse = Invoke-RestMethod -Method POST -Uri $yIncidentURL -Body $ybodyJson -TimeoutSec 100 -Credential $ycredential -ContentType $Type
                }
                Catch {
                    Write-Host $_.Exception.ToString()
                    $error[0] | Format-List -Force
                }
                # Pulling ticket ID from response
                $IncidentID = $yIncidentPOSTResponse.result.number
                ###############################################
                # Verifying Incident created and show ID
                ###############################################
                IF ($IncidentID -ne $null) {
                    "Created Incident With ID:$IncidentID"
                    $incidentlist += "Created:-" + $IncidentID + "____" + $yIncidentPOSTResponse.result.short_description

                    #Version 1.1 : Adding the incident Property
                    $tversions.group | ? { $_.singlkey -eq $msalkey }  | % { $_.incident = $IncidentID }
                    if ($snowparent -like "*ffit*") {
                        $incsysids = $yIncidentPOSTResponse.result.sys_id
                        $incsysids
                        $cliitemlists = $fnewsers -join (',')
                        $cliitemlists
                        updateci -configitem $cliitemlists -snowlink $snowparent -sys_id $incsysids  -spass $snowparentpass -suser $snowparentuser 
                    }
                }
                ELSE {
                    "Incident Not Created for $initems"

                    #Version 1.1 : Adding the incident Property
                    $tversions.group | ? { $_.singlkey -eq $tval }  | % { $_.incident = "NA" }
                }
     
            }
            else {
                foreach ($Incident in $xRequests.result) { 
                    $fnewdesc = @()
                    $newclients = @()
                    $crinvalues = $newtable | where { $_.singlkey -eq $searchsub }
                    foreach ($tval in $crinvalues) {
                        $Incident.sys_created_on
                        $ignoredesc = @()
                        if (!($Incident.description.trim() | select-string $tval.JobID) -and (([datetime]$Incident.sys_created_on - [datetime]$tval.Timestamp).Hours -gt "12")) {
                            $fnewdesc += "
                           Timestamp:"+ $tval.Timestamp + "
                           JobID:"+ $tval.JobID + "
                           Policy:"+ $tval.Policy + "
                           Schedule:"+ $tval.Schedule + "
                           Client:"+ $tval.Client + "
                           Exitcode:"+ $tval.Exitcode + "
                           Path:"+ $tval.path + "
                           ____________________________________"
                           
                            if (!($Incident.description.trim() | select-string $tval.Client)) {
                                $newclients += $tval.Client
                            }
                        }
                        else {
                            $ignoredesc = "Timestamp:" + $tval.Timestamp + "JobID:" + $tval.JobID + "Policy:" + $tval.Policy + "Schedule:" + $tval.Schedule + "Client:" + $tval.Client + "
                                  "  
                            write-host 'ignoring'$ignoredesc
                        }
                    }
                    if ($fnewdesc) {
                        $itemsys = $Incident.sys_id
                        $zRequests = $Null
                        $zuser = $snowparentuser
                        $zpassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                        $zcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $zuser, $zpassword
                        $zbody = @{
                            'description' = $Incident.description + "
                                        "+ $fnewdesc + "
                                        "
                        }
                        $zbodyJson = $zbody | ConvertTo-Json
                        $zURI = "$snowparent/api/now/table/incident/$itemsys"
                        $zRequests = Invoke-WebRequest -Uri $zURI  -Method PUT -Credential $zcredential -Body $zbodyJson -TimeoutSec 100 -ContentType "application/json"

                        if ($zRequests.StatusDescription -eq "OK") {
                            $incidentlist += $Incident.number + "---" + $Incident.short_description
                            if (($snowparent -like "*ffit*") -and ($newclients -ne $Null) -and ($Incident.sys_id -ne $Null)) {
                                $incsysids = $Incident.sys_id
                                $incsysids
                                $cliitemlists = $newclients -join (",")  
                                $cliitemlists
                                updateci -configitem $cliitemlists -snowlink $snowparent -sys_id $incsysids  -spass $snowparentpass -suser $snowparentuser 
                            }

                            #Version 1.1 : Adding the incident Property
                            $tversions.group | ? { $_.singlkey -eq $msalkey }  | % { $_.incident = $Incident.number }

                        }
                    }
                    else {
                        write-host "No modification required for"$Incident.number
                        
                        #Version 1.1 : Adding the incident Property
                        $tversions.group | ? { $_.singlkey -eq $msalkey }  | % { $_.incident = $Incident.number }
                    }
                }
     
     
            }
        }
    }

}


$url = 'http://company.com/cgi-bin/system_state.cgi'
try {
    $req = Invoke-WebRequest $url
}
catch {
    write-host "Error accessing system state failures"
}

try {
    $stable = $req.ParsedHtml.getElementsByTagName('table')[0]
}
catch {
    $stable = $Null
}

if ($stable) {
    $objPropertyNames = ($stable.Rows[0].Cells | Select -ExpandProperty innerText).trim()
    $systemstate = @()

    foreach ($stablerow in ($stable.Rows | Select -Skip 1)) {

        $cells = ($stablerow.Cells | Select -ExpandProperty innerText -ea SilentlyContinue).trim()
        $obj = New-Object -TypeName PSObject
        $count = 0;
        foreach ($cell in $cells) {
            if ($count -lt $objPropertyNames.length) {
                $propertynamecurrent = $objPropertyNames[$count++]
                if ($propertynamecurrent -eq 'Client_Name') { $propertynamecurrent = 'Client' }
                elseif ($propertynamecurrent -eq 'Policy_Name') { $propertynamecurrent = 'Policy' }
                elseif ($propertynamecurrent -eq 'Schedule') { $propertynamecurrent = 'Schedule' }
                elseif ($propertynamecurrent -eq 'Error_Code') { $propertynamecurrent = 'Exitcode' }
                $obj | Add-Member -MemberType NoteProperty -Name $propertynamecurrent -Value $cell
            }
        }

        $curvalue = "[" + $obj.Location + "] : System state failure" + " [" + $obj.Client + "] [" + $obj.Policy + "] [" + $obj.Schedule + "]"
        $obj | Add-Member -MemberType NoteProperty -Name "singlesubject" -Value $curvalue
        $obj | Add-Member -MemberType NoteProperty -Name "mulsubject" -Value 'NA'
        $obj | Add-Member -MemberType NoteProperty -Name "snversion" -Value "JAKARTA"
        $obj | Add-Member -MemberType NoteProperty -Name "Mastervar" -Value 'NA'
        $obj | Add-Member -MemberType NoteProperty -Name "Timestamp" -Value 'NA'
        $obj | Add-Member -MemberType NoteProperty -Name "Path" -Value 'NA'
        $obj | Add-Member -MemberType NoteProperty -Name "JobID" -Value 'NA'

        #Version 1.1 : Adding the incident Property
        $obj | Add-Member -MemberType NoteProperty -Name "Incident" -Value ""


        $systemstate += $obj
    }


    $systemversions = $systemstate | group-object -Property snversion
    foreach ($sysversions in $systemversions) {
        $systemtable = @()
        $systemtable = $systemstate | where { $_.snversion -eq $systemversions.Name }
           
        if ($systemversions.Name -eq "KINGSTON") {
            $snowparent = "$PROPERTY{GCS_SERVICENOW_LINK}"
            $snowparentuser = $gcsuser
            $snowparentpass = $gcspass
            $snowid = 'Tool Automation'
            $snowby = 'Tool Automation'
            $snowcategory = 'Server'
            $snowsubc = 'SBackup Issue'
            $snowassign = 'Backup Support - Leveraged'
            $snowcompany = 'Sedgwick'
        }
        else {
            $snowparent = "$PROPERTY{SERVICENOW_LINK}"
            $snowparentuser = "$PROPERTY{SERVICENOW_USER}"
            $snowparentpass = "$PROPERTY{SERVICENOW_PASSWORD}"
            $snowid = 'Tool Systems'
            $snowby = 'Tool Systems'
            $snowcategory = 'Backup'
            $snowsubc = 'Job Failure'
            $snowassign = 'Backup NetBackup'
            $snowcompany = 'company'
        }






        if ($systemtable.count -ne 0) {
            Write-host "working on systemtable"
            $valser = @{}
            $systemitemclients = $systemtable | group-object -Property Client
            foreach ($utcc in $systemitemclients) {
                $mulvalue = $systemtable | where { $_.Client -eq $utcc.Name }
                foreach ($mval in $mulvalue) {
                    $valkey = $mval.singlesubject
                    if (!$valser.ContainsKey($valkey)) {
                        [string]$assign = "
                            Timestamp:"+ $mval.Timestamp + "
                            JobID:"+ $mval.JobID + "
                            Policy:"+ $mval.Policy + "
                            Schedule:"+ $mval.Schedule + "
                            Client:"+ $mval.Client + "
                            Exitcode:"+ $mval.Exitcode + "
                            Path:"+ $mval.path + "
                            ____________________________________"
                        $valser.Add($valkey, $assign)
                    }
                    else {
                        [string]$assign = "
                            Timestamp:"+ $mval.Timestamp + "
                            JobID:"+ $mval.JobID + "
                            Policy:"+ $mval.Policy + "
                            Schedule:"+ $mval.Schedule + "
                            Client:"+ $mval.Client + "
                            Exitcode:"+ $mval.Exitcode + "
                            Path:"+ $mval.path + "
                            ____________________________________"
                        $valser.$valkey += $assign
                    }
                }
            }

            foreach ($valkey in $valser.keys) {
                $Requests = $Null
                $user = $snowparentuser
                $password = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                $credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $user, $password
                #// Get all incidents Assigned To 
                $URI = "$snowparent/api/now/table/incident?sysparm_query=short_description=" + $valkey + "^state=1^NQshort_description=" + $valkey + "^state=2^NQshort_description=" + $valkey + "^state=3" 
                $Requests = Invoke-RestMethod -Uri $URI -Credential $credential -Method GET -ContentType "application/json"   
                if ($Requests.result.count -eq "0") { 
                    $nuser = $snowparentuser
                    $npassword = ConvertTo-SecureString $snowparentpass -AsPlainText -Force
                    $ncredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $nuser, $npassword
                    $IncidentURL = "$snowparent/api/now/table/incident"
                    $Type = "application/json"
                    # Specify request body
                    
                    if ($snowparent -like "*ffit*") {
                        $body = @{
                            'impact'            = '4'
                            'caller_id'         = $snowid
                            'opened_by'         = $snowid
                            'u_request_system'  = 'Tool'
                            'category'          = $snowcategory
                            'subcategory'       = $snowsubc
                            'notify'            = '1'
                            'assignment_group'  = $snowassign
                            'short_description' = $valkey
                            'contact_type'      = 'Event monitor'
                            #'u_unlisted_ci'     = $true
                            #'u_new_configuration_item' = '' + ($valkey.split("-")[1..50] -join ("-"))
                            'u_business_impact' = 'NA'
                            'company'           = $snowcompany
                            'description'       = '' + $valser.$valkey
                        }
                    }
                    else {
                        $body = @{
                            'impact'                   = '4'
                            'caller_id'                = $snowid
                            'opened_by'                = $snowid
                            'u_request_system'         = 'Tool'
                            'category'                 = $snowcategory
                            'subcategory'              = $snowsubc
                            'notify'                   = '1'
                            'assignment_group'         = $snowassign
                            'assigned_to'              = 'b4a41a79dbe5fa00c547fb971d96193c'
                            'short_description'        = $valkey
                            'contact_type'             = 'Event monitor'
                            'u_unlisted_ci'            = $true
                            'u_new_configuration_item' = '' + $valkey.split(" ")[5].replace(']', '').replace('[', '')
                            'u_business_impact'        = 'NA'
                            'company'                  = $snowcompany
                            'description'              = '' + $valser.$valkey
                        }
                    }

                    $bodyJson = $body | ConvertTo-Json
                    # POST to API
                    Try { 
                        #$bodyJson
                        $IncidentPOSTResponse = Invoke-RestMethod -Method POST -Uri $IncidentURL -Body $bodyJson -TimeoutSec 100 -Credential $ncredential -ContentType $Type
                    }
                    Catch {
                        Write-Host $_.Exception.ToString()
                        $error[0] | Format-List -Force
                    }
                    # Pulling ticket ID from response
                    $IncidentID = $IncidentPOSTResponse.result.number
            
                    ###############################################
                    # Verifying Incident created and show ID
                    ###############################################
                    IF ($IncidentID -ne $null) {
                        "Created Incident With ID:$IncidentID"
                        $incidentlist += $IncidentID + "---" + $IncidentPOSTResponse.result.description

                        #Version 1.1 : Adding the incident Property
                        $sysversions.group | ? { $_.singlesubject -eq $valkey }  | % { $_.incident = $IncidentID }
                        if ($snowparent -like "*ffit*") {
                            $incsysids = $IncidentPOSTResponse.result.sys_id
                            $incsysids
                            $cliitemlists = $valkey.split(" ")[5].replace(']', '').replace('[', '') -join (',') 
                            $cliitemlists
                            updateci -configitem $cliitemlists -snowlink $snowparent -sys_id $incsysids  -spass $snowparentpass -suser $snowparentuser 
                        }
                    }
                    ELSE {
                        "Incident Not Created"

                        #Version 1.1 : Adding the incident Property
                        $sysversions.group | ? { $_.singlesubject -eq $valkey }  | % { $_.incident = "NA" }
                    }
                }
                else {
                    "Incidents Found : $($Requests.result.number)"

                    #Version 1.1 : Adding the incident Property
                    $sysversions.group | ? { $_.singlesubject -eq $valkey }  | % { $_.incident = $Requests.result.number }
                }
    
            }
        }
    }
}



$stopwatch.Stop()

$valuer = [string]$stopwatch.Elapsed.Days + ":" + [string]$stopwatch.Elapsed.Hours + ":" + [string]$stopwatch.Elapsed.Minutes + ":" + [string]$stopwatch.Elapsed.Seconds

Write-host "Time taken for execution $valuer"






   
  

write-host "
Failures for Decomissioned : "($decommtable.count)"
Failures Ignored           : "($ignoreditem.count)"
Exitcode 2074              : "($twelevehourss.count)"
No actions(150,157,190)    : "($ignoretable.count)"
Unique (230,239,247)       : "($uniquetables.count)"
Masss Failures             : "($masterfilters.count)"
System State Failures      : "($systemstate.count)"
All others                 : "($finalfilter.count)

$dailytable = @()

$dailytable += $uniquetables
$dailytable += $masterfilters
$dailytable += $finalfilter
$dailytable += $systemstate

 
if ($ignorefilter) {
    'Time taken for execution ' + $valuer >> C:\NBTicketinge5562937DNDELETE\attachments\ilist.txt
  

    "
Failures for Decomissioned : "+ ($decommtable.count) + "
Failures Ignored           : "+ ($ignoreditem.count) + "
Exitcode 2074              : "+ ($twelevehourss.count) + "
No actions(150,157,190,288): "+ ($ignoretable.count) + "
Unique (230,239,247)       : "+ ($uniquetables.count) + "
Masss Failures             : "+ ($masterfilters.count) + "
System State Failures      : "+ ($systemstate.count) + "
All others                 : "+ ($finalfilter.count) >> C:\NBTicketinge5562937DNDELETE\attachments\ilist.txt

    "  " >> C:\NBTicketinge5562937DNDELETE\attachments\ilist.txt

    $incidentlist >> C:\NBTicketinge5562937DNDELETE\attachments\ilist.txt

    $subcontent = @"
Hi Team,

Kindly find the attachments for the current run and Please remove the failures from dashboard which are part of failures150157190.csv.

Below shown are the Contents and Description of attachments in this Email.

############################################################################################################################################################

1.Failedpaths.txt 

This document contains all the Paths related to Job ID for the current run. So if any technician want the Paths to be checked and they can use this. 


2.Ilist.txt 

This document contains the complete output of that run. 

Details like 

Incident updated
Incident created
How much time took to complete the run
Failures that have been ignored on filtering the Decommission list
Failures have been ignored, as per the Guidelines provided during request. Example: Client (NULL, *NONE*, non SQL failures with exit code 1)
Failures that do not require any action but just need to be Emailed to Backup team. (150,157,190 and 288)
Failures that requires unique incident rather than grouped with other failures (230,239 and 247)

3.dailyreport.csv  

This document will have the summary of a day that will be available in the first run of a day.

4.Decomissioned.csv

This document is the filtered version of dashboard which has only decommissioned servers

5.Ignored.csv

This document is the filtered version of dashboard which has only Ignored failures for reference

6.failures150157190.csv 

This document is the filtered version of dashboard which has only No action requested failures for reference.

7.failures230239247.csv

This document is the filtered version of dashboard which has only Unique Incident requested failures for reference.

8.Valids.csv

This document is the filtered version of dashboard which has failures that are not fall under any of the above for reference

9.Weeklystatus.txt

This document provides the Incidents that have been created or updated for last 7 days and it will reset by itself to Null every 7 days. You can find this file in attachments of email once in 7 days.

Handling Failures:

1.The failures are Auto-handled, As an example the scheduled Job failed due to unexpected server failures, Then the next run will take care of all the failures which are not updated in previous run. 
Hence everything will be taken care in next hour of run. Please monitor emails and have it verified in case of failures.
 
2.In case of  not receiving the Emails for continuous hours, Please email to Windows.Automation@company.com , We will Tool the issue for you.
Please Make subject as NetBackup Ticketing -253 for easy identification

###############################################################################################################################################################

"@

    $subcontentWeekly = @"
Hi Team,

Kindly find the attachment of the Weekly Report in weeklyReport.csv.

Thanks,

Automation Team

"@

    $subcontentDaily = @"
Hi Team,

Kindly find the attachment of the Daily Report in daily.csv.

Thanks,

Automation Team

"@

    if (test-path "C:\NBTicketinge5562937DNDELETE\daily.csv") {
 
        $dailytable | export-csv "C:\NBTicketinge5562937DNDELETE\daily.csv" -NoTypeInformation -Append

    }
    else {
	
        $dailytable | export-csv "C:\NBTicketinge5562937DNDELETE\daily.csv" -NoTypeInformation

    }



    if ((get-date).Hour -le 4) {

        $dj = Import-Csv 'C:\NBTicketinge5562937DNDELETE\daily.csv'
        $finalvalues = @()

        $finalvalues += $dj | where { $_.JobID -eq 'NA' } | Group Client | ForEach {

            $_.Group | Select-Object -Last 1
                
        } 

        $finalvalues += $dj | where { $_.JobID -ne 'NA' } | Group JobID | ForEach {

            $_.Group | Select-Object -Last 1
                
        } 

        $finalvalues | export-csv  C:\NBTicketinge5562937DNDELETE\dailyreport.csv -NoTypeInformation

        Move-Item C:\NBTicketinge5562937DNDELETE\dailyreport.csv C:\NBTicketinge5562937DNDELETE\attachments\dailyreport.csv -Force

    }
    else {
        write-host "File not older to send in an email"
    }


    #Version 1.1 : Merging the report
    $weeklytable = $dailytable
    $date = Get-Date
    $weeklytable | Add-Member -MemberType NoteProperty -Name "DateTime" -Value $date
    #$weeklytable | Export-Csv "C:\NBTicketinge5562937DNDELETE\weeklyReport.csv" -NoTypeInformation -Append 

    if (Test-Path "C:\NBTicketinge5562937DNDELETE\WeeklyReport") {
        "C:\NBTicketinge5562937DNDELETE\WeeklyReport Path already Present"
        $weeklytable | Export-Csv "C:\NBTicketinge5562937DNDELETE\WeeklyReport\weeklyReport.csv" -NoTypeInformation -Append 
    }
    else {
        "C:\NBTicketinge5562937DNDELETE\WeeklyReport Path is not Present. Creating a new Folder"
        New-Item -ItemType "directory" -Path "C:\NBTicketinge5562937DNDELETE\WeeklyReport" -Force
        $weeklytable | Export-Csv "C:\NBTicketinge5562937DNDELETE\WeeklyReport\weeklyReport.csv" -NoTypeInformation -Append 
    }
 
    if ((get-date).DayOfWeek -eq "Sunday" -and (Get-Date).hour -ge 21) {
        try {
            #Ziping the File
            if (Test-Path "C:\NBTicketinge5562937DNDELETE\WeeklyReport.zip") {
                "Found old Zip File : C:\NBTicketinge5562937DNDELETE\WeeklyReport\weeklyReport.zip before creating a new one"
                Remove-Item 'C:\NBTicketinge5562937DNDELETE\WeeklyReport.zip' -Force -Confirm:$false
                "Deleting Zip File : C:\NBTicketinge5562937DNDELETE\WeeklyReport\weeklyReport.zip"
            }

            Add-Type -Assembly "System.IO.Compression.FileSystem" 
            [System.IO.Compression.ZipFile]::CreateFromDirectory("C:\NBTicketinge5562937DNDELETE\WeeklyReport", "C:\NBTicketinge5562937DNDELETE\WeeklyReport.zip")

            "Sending Weekly Report"
            Send-MailMessage -from "Toolsystems@company.com" `
                -to "bkpservices@company.com" `
                -cc "teamops@company.com" `
                -subject "Backup Ticketing Summary Weekly Report" `
                -body $subcontentWeekly `
                -Attachment ('C:\NBTicketinge5562937DNDELETE\WeeklyReport.zip') -smtpServer companyToolsRelay.company.com -ErrorAction SilentlyContinue
    
            if (Test-Path "C:\NBTicketinge5562937DNDELETE\WeeklyReport\weeklyReport.csv") {
                Remove-Item 'C:\NBTicketinge5562937DNDELETE\WeeklyReport\weeklyReport.csv' -Force -Confirm:$false
                "Deleting File : C:\NBTicketinge5562937DNDELETE\WeeklyReport\weeklyReport.csv"
            }
            if (Test-Path "C:\NBTicketinge5562937DNDELETE\WeeklyReport.zip") {
                Remove-Item 'C:\NBTicketinge5562937DNDELETE\WeeklyReport.zip' -Force -Confirm:$false
                "Deleting Zip File : C:\NBTicketinge5562937DNDELETE\WeeklyReport\weeklyReport.zip"
            }
        }
        catch {
            "Error Occured while sending Email or Zipping File : $($_.Exception)"
            if (Test-Path "C:\NBTicketinge5562937DNDELETE\WeeklyReport.zip") {
                Remove-Item 'C:\NBTicketinge5562937DNDELETE\WeeklyReport.zip' -Force -Confirm:$false
                "Deleting Zip File : C:\NBTicketinge5562937DNDELETE\WeeklyReport\weeklyReport.zip"
            }
        }
    }

    #Version 1.1 : Merging the report 
 
 
    write-host "Information have been fetched"

    Send-MailMessage -from "Toolsystems@company.com" `
        -to "Backup.Services@company.com" `
        -cc "SLM_Automation_Operations@company.com" `
        -subject "Backup Daily ticketing Summary" `
        -body $subcontentDaily `
        -Attachment ('C:\NBTicketinge5562937DNDELETE\daily.csv') -smtpServer companyToolsRelay.company.com -ErrorAction SilentlyContinue

    Send-MailMessage -from "Toolsystems@company.com" `
        -to "Backup.Services@company.com" `
        -cc "SLM_Automation_Operations@company.com" `
        -subject "Backup ticketing Summary" `
        -body $subcontent `
        -Attachment ((Get-ChildItem "C:\NBTicketinge5562937DNDELETE\attachments\" | Where { -NOT $_.PSIsContainer }).FullName) -smtpServer companyToolsRelay.company.com -ErrorAction SilentlyContinue

    if (test-path 'C:\NBTicketinge5562937DNDELETE\attachments\dailyreport.csv') {
        Remove-Item 'C:\NBTicketinge5562937DNDELETE\attachments\dailyreport.csv' -Force -Confirm:$false
    }
    if (test-path 'C:\NBTicketinge5562937DNDELETE\dailyreport.csv') {
        Remove-Item 'C:\NBTicketinge5562937DNDELETE\dailyreport.csv' -Force -Confirm:$false
    }
    if (test-path 'C:\NBTicketinge5562937DNDELETE\daily.csv') {
        Remove-Item 'C:\NBTicketinge5562937DNDELETE\daily.csv' -Force -Confirm:$false
    }
    if (test-path 'C:\NBTicketinge5562937DNDELETE\attachments\todaycontent1.html') {
        Remove-Item 'C:\NBTicketinge5562937DNDELETE\attachments\todaycontent1.html' -Force -Confirm:$false	
    }

}

#######################

######################COMM valt self heal#########

$COMSERVER = '$INPUT{COMSERVERNAME}'
$username = '$INPUT{USERNAME}'
$password = '$INPUT{PASSWORD}'
$password2 = ConvertTo-SecureString $password -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password2


if($COMSERVER)
{
    if ($COMSERVER -like 'server1*')
    {
    $SERVER = '0.0.0.0'
    $JUMPSERVER = '0.0.0.0'
    }
    elseif ($COMSERVER -like 'server2*') 
    {
    $SERVER = '0.0.0.0'
    $JUMPSERVER = '0.0.0.0'
    }
    
}

Invoke-Command -ComputerName $JUMPSERVER -Credential $credential -Scriptblock { 



$username = $using:username;
$password = $using:password;
$SERVER = $using:SERVER;

	
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

$APIURL = "http://$($SERVER):81/SearchSvc/CVWebService.svc"
$startTime = (get-date).ToString('M_d_y_hh_mm_ss_tt')

$headers = @{} 
#default is XML
$headers["Accept"] = "application/xml"
$APIURLaction = "$APIURL/login" 
$APIURLaction
$passwordB64byte = [System.Text.Encoding]::UTF8.GetBytes($password) 
$encodedPassword = [System.Convert]::ToBase64String($passwordB64byte) 
$loginReq = "<DM2ContentIndexing_CheckCredentialReq mode=""Webconsole"" username=""$username"" password=""$encodedPassword"" />" 

try
{
$result = Invoke-WebRequest -Uri $APIURLaction -Method POST -Body $loginReq -ContentType 'application/xml' -Headers $headers -UseBasicParsing 
$token = (([xml]$result.content).SelectSingleNode("/DM2ContentIndexing_CheckCredentialResp/@token")).value
$token
    
    function GET_JOB_Details
    {
    
                #GET- Client details:
		        $service_1 = "/Job?completedJobLookupTime=300" 
                $baseurl_1 = "http://$($SERVER):81/SearchSvc/CVWebService.svc"
		        $APIURLaction_1 = "$baseurl_1$service_1"
		        $headersclient_1 = @{} 
		        $headersclient_1["Accept"] = "application/json" 
		        $headersclient_1["Authtoken"] = $token
            
            try
                {
                $a = @{}
                $result_1 = Invoke-WebRequest -Uri $APIURLaction_1 -Headers $headersclient_1 -Method 'GET' 
				$resultin_JOB = ( $result_1.content | ConvertFrom-Json)
               
               
                $acount = $($resultin_JOB.totalRecordsWithoutPaging)
                $i=0              

                do
                {
                $CSTATUS=$resultin_JOB.jobs.jobSummary.status[$i]
                $CJOBID=$resultin_JOB.jobs.jobSummary.jobid[$i]
                $JST=$resultin_JOB.jobs.jobSummary.jobStartTime[$i]
                $LUT=$resultin_JOB.jobs.jobSummary.lastUpdateTime[$i]
                $CommCelName=$resultin_JOB.jobs.jobSummary.subclient.commCellName[$i]
                $StoragePolciy=$resultin_JOB.jobs.jobSummary.storagePolicy.storagePolicyName[$i]
                $clientName=$resultin_JOB.jobs.jobSummary.destinationClient.clientName[$i]
                
                
                $origin = New-Object -Type DateTime -ArgumentList 1970, 1, 1, 0, 0, 0, 0
                $JobStartTime = $origin.AddSeconds($JST)
                #$JobStartTime

                $origin_1 = New-Object -Type DateTime -ArgumentList 1970, 1, 1, 0, 0, 0, 0
                $LastUpdateTime = $origin_1.AddSeconds($LUT)
                #$LastUpdateTime

                $currentdateandtime = get-date
                $diff = ((get-date $LastUpdateTime)-(get-date $currentdateandtime))
                $value = $diff.Minutes
                              

                if($value -ge 120)
                {
                 #Suspend the JOB
                                       #POST- Suspend:
		                               $service_1 = "/Job/$CJOBID/action/pause" 
		                               $baseurl_1 = "http://$($SERVER):81/SearchSvc/CVWebService.svc"
		                               $APIURLaction_1 = "$baseurl_1$service_1"
		                               $headersclient_1 = @{} 
		                               $headersclient_1["Accept"] = "application/json" 
		                               $headersclient_1["Authtoken"] = $token
            
                                       try
                                           {
                                           $result_1 = Invoke-WebRequest -Uri $APIURLaction_1 -Headers $headersclient_1 -Method 'POST' 
				                           $resultin_JOB = ( $result_1.content | ConvertFrom-Json)
                                           $resultin_JOB          
                                                                    
                                            }
                                           catch [Exception] 
                                           {
                                           Write-Host "Unable to Pull the JoB information $JOBID ."
                                           } 


                  #Wait for 5min 
                   
                   Start-Sleep 300

                  #Re-Submit the JOB

                                       #POST-Re-Submit:
		                               $service_1 = "/Job/$CJOBID/action/Resubmit" 
		                               $baseurl_1 = "http://$($SERVER):81/SearchSvc/CVWebService.svc"
		                               $APIURLaction_1 = "$baseurl_1$service_1"
		                               $headersclient_1 = @{} 
		                               $headersclient_1["Accept"] = "application/json" 
		                               $headersclient_1["Authtoken"] = $token
            
                                       try
                                           {
                                           $result_1 = Invoke-WebRequest -Uri $APIURLaction_1 -Headers $headersclient_1 -Method 'POST' 
				                           $resultin_JOB = ( $result_1.content | ConvertFrom-Json)
                                           $resultin_JOB
                                           $NewJobId = $resultin_JOB.jobIds              
                                           $global:TableBody+="<tr><td>$CJOBID</td><td>$clientName</td><td>$CommCelName</td><td>$StoragePolciy</td><td>$JST</td><td>$LUT</td><td>$CSTATUS</td><td>Yes</td><td>$NewJobId</td></tr>`r`n"	                             
                                            }
                                           catch [Exception] 
                                           {
                                           Write-Host "Unable to Pull the JoB information $JOBID ."
                                           } 
    

                }
                else
                {
                $global:TableBody+="<tr><td>$CJOBID</td><td>$clientName</td><td>$CommCelName</td><td>$StoragePolciy</td><td>$JST</td><td>$LUT</td><td>$CSTATUS</td><td>NA</td><td>NA</td></tr>`r`n"	
                
                }
                 $i++                             
                
                }
                until($i -ge $acount)

                
                }
                catch [Exception] {
                                Write-Host $_.Exception.Message 
                } 
    }

    GET_JOB_Details

           
}
catch [Exception]
{
    
    Write-Host "Unable to Connect the CommServer $_.Exception.Message ."
} 

#OUTPUT Block
$Body =@"
<html>
<head>
<title>Automation-Commvault</title>
</head><body>
<html>
<head>
<style>
table {border-width: 2px; border-style: solid; border-color: black; border-collapse: collapse; width: 75%;}
th {border-width: 1px; padding: 1px; border-style: solid; border-color: black; background-color:#ede2b6;}
td {border-width: 1px; padding: 1px; border-style: solid; border-color: black;}
</style>
</head>
<body>
<table>
<tr><td colspan=7 style="background-color:#005ebd;font-family:Ebrima;font-size:18px;color:white"><center><b>Automation Status</b></center></td></tr>
<th>Job ID</th><th>Client Name</th><th>Comm Cell Name</th><th>Storage Policy</th><th>Job Start</th><th>Last Update</th><th>Job Status</th><th>Job Suspend</th><th>Re-Submit ID</th>
$global:TableBody
</table>
</body>
</html>
<table>
</table>
</body></html>
"@

$HTML = ConvertTo-Html -Body $Body 
"#####"
$HTML
}-SessionOption (New-PSSessionOption -SkipCACheck -SkipRevocationCheck)


####################

#############COMM RC verfy#########


$jobid = '$INPUT{JOBID}'
$errorcode = '$INPUT{ERROR_CODE}'
$servername = '$INPUT{SERVERNAME}'
$spass = '$INPUT{SNOWPASSWORD}'
$user='$PROPERTY{STARDB_USER}'
$pwd='$PROPERTY{STARDB_PWD}'
$currentdate=(get-date).ToString("yyyy-MM-dd hh:mm:ss")
$ISERVICENOWLINK = '$INPUT{SERVICENOWLINK}'


$muser = 'tool'
$mpassword = ConvertTo-SecureString $spass -AsPlainText -Force
$mcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $muser, $mpassword

function GetConnectionString ($user, $passwd)
{
    return "Server=server1;Database=Automation;Integrated Security=False;User ID= $user ;Password= $pwd"
}

function todaycount()
{
$query = @"
SELECT count(CREATEDON) as TOTAL_TO FROM [Automation].[dbo].[commcheckaudit] 
where [SERVERNAME]='$servername' and [ERRORCODE]='$errorcode' and [CREATEDON] >= DATEADD(day, -1, getdate());
"@


[string]$connectionString = GetConnectionString -user $user -pwd $pwd
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
$SqlConnection.ConnectionString = $connectionString 
$SqlConnection.Open()

$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
$SqlCmd.CommandText = $query   
$SqlCmd.Connection = $SqlConnection


try
{
    $result = $SqlCmd.ExecuteReader()    

if($result)
{

$table = new-object "System.Data.DataTable"
$table.Load($result)

$final=@()
Foreach ($t in $table)
{
    if($t -ne "")
    {
    $global:countoftoday = $t.TOTAL_TO;
        }
}
write-host "COUNTOFTHEDAT=$global:countoftoday"

}

}
catch
{
    $ErrorMessage = $_.Exception.Message
    $FailedItem = $_.Exception.ItemName
    write-host "Entry Error,$ErrorMessage"
}


#Close the connection
$SqlConnection.Close()

}

function inserttoday()
{
$query = @"
INSERT INTO [test].[dbo].[CommCheckAudit] (SERVERNAME,ERRORCODE,JOBID,CREATEDON,INCIDENTSTATUS,INCIDENT1)
VALUES ('$servername','$errorcode','$jobid',getdate(),'NA','NA');
"@

#Connection Open
[string]$connectionString = GetConnectionString -user $user -pwd $pwd
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
$SqlConnection.ConnectionString = $connectionString 
$SqlConnection.Open()


#$result = $SqlCmd.ExecuteReader()
#Query excution block
$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
$SqlCmd.CommandText = $query   
$SqlCmd.Connection = $SqlConnection

try
{
  $result = $SqlCmd.ExecuteNonQuery()
}
catch
{
     $ErrorMessage1 = $_.Exception.Message
	 write-host "RESULTTODAYINSERT=0"
    $TableBody+="<tr><td colspan=1 ><b>No of Row insert into DB:</b></td><td>$($ErrorMessage1)</td><td><b><font color=#F51010>FAIL</font></b></td></tr>`r`n"
}


if($result -eq 0)
{
 	 write-host "RESULTTODAYINSERT=0"
    $TableBody+="<tr><td colspan=1 ><b>No of Row insert into DB:</b></td><td>$($result)</td><td><b><font color=#F51010>FAIL</font></b></td></tr>`r`n"
 	
}
else
{
    #write-host "Info: $result rows are affected"
    write-host "RESULTTODAYINSERT=$result"
    $TableBody+="<tr><td colspan=1 ><b>No of Row insert into DB:</b></td><td>$($result)</td><td><b><font color=#089A28>PASS</font></b></td></tr>`r`n"
    	
}

#Close the connection
$SqlConnection.Close()

}

function getlast30day_count() 
{

$query = @"
SELECT count(CREATEDON) as TOTAL_TO FROM [Automation].[dbo].[commcheckaudit] 
where [SERVERNAME]='$servername' and [ERRORCODE]='$errorcode' and  [CREATEDON] >= DATEADD(day, -30, getdate()) ORDER BY TOTAL_TO DESC
"@

[string]$connectionString = GetConnectionString -user $user -pwd $pwd
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
$SqlConnection.ConnectionString = $connectionString 
$SqlConnection.Open()

$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
$SqlCmd.CommandText = $query   
$SqlCmd.Connection = $SqlConnection

try
{ $result = $SqlCmd.ExecuteReader()
    
if($result)
{

$table = new-object "System.Data.DataTable"
$table.Load($result)

$final=@()
Foreach ($t in $table)
{
    if($t -ne "")
    {
    $global:countofro = $t.TOTAL_TO;
    $TableBody+="<tr><td colspan=1 ><b>Repted Offnder count of last 30 days:</b></td><td>$($global:countofro)</td><td><b><font color=#089A28>PASS</font></b></td></tr>`r`n"
     }

}

}

}
catch
{
    $ErrorMessage = $_.Exception.Message
    $FailedItem = $_.Exception.ItemName
    write-host "Entry Error,$ErrorMessage"
    $TableBody+="<tr><td colspan=1 ><b>Repted Offnder count of last 30 days:</b></td><td>$($ErrorMessage)</td><td><b><font color=#F51010>FAIL</font></b></td></tr>`r`n"

}


#Close the connection
$SqlConnection.Close()

}

function getlast30day_lastincident() 
{
$global:tincident = "";
$query = @"
select TOP 1 INCIDENT1 from [Automation].[dbo].[commcheckaudit] where 
INCIDENT1 like 'IN%' and [SERVERNAME]='$servername' and [ERRORCODE]='$errorcode'
and [CREATEDON] >= DATEADD(day, -30, getdate()) order by sno DESC
"@


[string]$connectionString = GetConnectionString -user $user -pwd $pwd
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
$SqlConnection.ConnectionString = $connectionString 
$SqlConnection.Open()

$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
$SqlCmd.CommandText = $query   
$SqlCmd.Connection = $SqlConnection

try
{ $result = $SqlCmd.ExecuteReader()
    
if($result)
{

$table = new-object "System.Data.DataTable"
$table.Load($result)

$final=@()
Foreach ($t in $table)
{
    if($t -ne "")
    {
    $global:tincident = $t.INCIDENT1;
    $TableBody+="<tr><td colspan=1 ><b>Last Incident#:</b></td><td>$($global:tincident)</td><td><b><font color=#089A28>NA</font></b></td></tr>`r`n"
     }
     else 
     {
     $global:tincident = "NA";
     $TableBody+="<tr><td colspan=1 ><b>Last Incident#:</b></td><td>$($global:tincident)</td><td><b><font color=#089A28>NA</font></b></td></tr>`r`n"
     }

}

}
else {
$global:tincident = "NA";
$TableBody+="<tr><td colspan=1 ><b>Last Incident#:</b></td><td>$($global:tincident)</td><td><b><font color=#089A28>NA</font></b></td></tr>`r`n"
}

}
catch
{
    $ErrorMessage = $_.Exception.Message
    $FailedItem = $_.Exception.ItemName
    write-host "Entry Error,$ErrorMessage"
     $TableBody+="<tr><td colspan=1 ><b>Last Incident#:</b></td><td>$($ErrorMessage)</td><td><b><font color=#F51010>FAIL</font></b></td></tr>`r`n"
}


#Close the connection
$SqlConnection.Close()

write-host "The Last Incident: $global:tincident"

}

function validationticket()
{
	    if($global:countofro -ge 10)
        {
        #create probelm ticket 
        #update the problem ticket number to all .
        createProblemTicket
        updatedb_problem_details_new
        #write-host "Problem Ticket"

        }
        elseif($global:countofro -ge 5)
        {
          #write-host "Count of RO :$global:countofro"
          #write-host "Last Incident: $global:tincident"
			
          if($global:tincident -cmatch "IN*")
          {
             checkticketopenstate
             
    	    if($global:state -ne 7)
            {
            	updateincident
            	updatedb_incident_details_POST_SNOW
            }
            else
            {
            	createincident
        		updatedb_incident_details_new
   		 }
            
          }
          else
          {
          createincident
          updatedb_incident_details_new          
          }
        }
        else
        {
        	write-host "Unable to create incident!"
        }


        
}

function createincident()
{
	     	#Write-Host "create_incident"
$category = 'Server'
$subcategory = 'Monitoring Alert'
$agroup = 'Backup Commvault'
$cttype = 'Event monitor'
$sedesc = 'Commvault Selfheal Repeat offender: 5 time for ServerName:' + $servername +' Error Code: ' + $errorcode +' on last 30 days'
$desc  = 'Commvault Selfheal Repeat offender: 5 time for ServerName:' + $servername +' Error Code: ' + $errorcode +' on last 30 days'
$bimpact = 'NA'
			# 'u_unlisted_ci' = $servername
			# 'u_new_configuration_item' = $servername
			# 			'caller_id' = 'tool Systems'
			# 'opened_by' = 'tool Systems
	     	
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        $rbody = @{
     		            
			'urgency' = '4'
			'category' = $category
			'subcategory' = $subcategory
			'assignment_group' = $agroup
			'short_description' = $sedesc
			'contact_type' = $cttype
			'u_unlisted_ci' = $servername
			'u_new_configuration_item' = $servername
			'cmdb_ci' = $servername
			'u_business_impact' = $bimpact
			'description' = $desc
			'caller_id' = 'tool Systems'
			'opened_by' = 'tool Systems'
        }
        
try
{
	$rIncidentURL = "$ISERVICENOWLINK/api/now/table/incident"
	#$rIncidentURL = "$PROPERTY{SERVICENOW_DEV_LINK}/api/now/table/incident"
	$Type = "application/json"
	$rbodyJson = $rbody | ConvertTo-Json
	 Try 
    {
        $rIncidentPOSTResponse = Invoke-RestMethod -Method POST -Uri $rIncidentURL -Body $rbodyJson -TimeoutSec 100 -Credential $mcredential -ContentType $Type
    }
    Catch 
    {
        Write-Host $_.Exception.ToString()
        $error[0] | Format-List -Force
    }
    
    $agroup = 'Backup Commvault'
    
	# Pulling ticket ID from response
    $global:IncidentID = $rIncidentPOSTResponse.result.number
    
    $Incidentdesc = $rIncidentPOSTResponse.result.description
    $assys =$rIncidentPOSTResponse.result.sys_id
    ###############################################
    # Verifying Incident created and show ID
    ###############################################
    IF ($global:IncidentID -ne $null)
    {	
    	write-host '#####'
        #write-host "IncidentID: $global:IncidentID"
        $TableBody+="<tr><td colspan=1 ><b>Incident created:</b></td><td>$($global:IncidentID)</td><td><b><font color=#F51010>FAIL</font></b></td></tr>`r`n"
        #$global:incout=$IncidentID
        $bodyn = @{
        'assignment_group' = $agroup
        }
        $bodyJsonn = $bodyn | ConvertTo-Json
        #UAT #$URIn = "$PROPERTY{SERVICENOW_UAT_LINK}/api/now/table/incident/$assys"
        # Prod : #
        $URIn = "$ISERVICENOWLINK/api/now/table/incident/$assys"
        #$URIn = "$PROPERTY{SERVICENOW_DEV_LINK}/api/now/table/incident/$assys"
        $Requestsn = Invoke-WebRequest -Uri $URIn  -Method PUT -Credential $mcredential -Body $bodyJsonn -TimeoutSec 100 -ContentType "application/json"
    }
    ELSE
    {
        "Incident Not Created "
        $TableBody+="<tr><td colspan=1 ><b>Incident Not Created:</b></td><td> Please work with SLM team or create ticket manualy!</td><td><b><font color=#F51010>FAIL</font></b></td></tr>`r`n"
    }
		
}
catch [Exception]
{   
    $result2 += "<==FAIL==>: " + $_.Exception.GetType().FullName + $_.Exception.Message + "`n";
    $result2 += ($_.Exception|format-list -force).toString();
}
finally
{
    if($result2 -like "*System.NotSupportedException*")
    {
    echo "______________________________________________________________________________________"	
    }
    else
    {
    echo $result2
    }
}
	
	
}

function updatedb_incident_details_new()
{
	
#$global:IncidentID
	
	
#write to DB
$query = @"
UPDATE [Automation].[dbo].[commcheckaudit] SET INCIDENT1='$global:IncidentID',INCIDENTSTATUS='V'
WHERE  [SERVERNAME]='$servername' and [ERRORCODE]='$errorcode' and [CREATEDON] >= DATEADD(day, -1, getdate())
"@

[string]$connectionString = GetConnectionString -user $user -pwd $pwd
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
$SqlConnection.ConnectionString = $connectionString
$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
$SqlCmd.CommandText = $query  
$SqlCmd.Connection = $SqlConnection

$SqlConnection.Open()
       
#Execute SQL Query
$uresult = $SqlCmd.ExecuteNonQuery()
if($uresult -eq 1)
{
Write-Host "RESULTTODAYICNDENT:NEW"
$TableBody+="<tr><td colspan=1 ><b>RO Incident created for the error code :</b></td><td>$($global:IncidentID)</td><td><b><font color=#089A28>PASS</font></b></td></tr>`r`n"
$SqlConnection.Close()
}
else
{
Write-Host "RESULTTODAYICNDENT:ERROR - $query"
$TableBody+="<tr><td colspan=1 ><b>RO Incident created for the error code :</b></td><td>$($global:IncidentID) - unable to insert into DB</td><td><b><font color=#F51010>FAIL</font></b></td></tr>`r`n"

}               
                   
}

function createProblemTicket()
{
	
	
	
$category = 'Server'
$subcategory = 'Monitoring Alert'
$agroup = 'Backup Commvault'

    $desc='Commvault Selfheal Repeat offender: 10 time for ServerName:' + $servername +' Error Code: ' + $errorcode +' on last 30 days'
    $sedesc='Commvault Selfheal Repeat offender: 10 time for ServerName:' + $servername +' Error Code: ' + $errorcode +' on last 30 days'
    $configitem=$global:incmdb
    $chstarttime='15'
    $chstartdate='15'
    
    if($chstarttime -like "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]")
    {
      $currentdate=(get-date).AddDays($chstartdate).ToString("yyyy-MM-dd "+$chstarttime)
    }
    else
    {
      $currentdate=(get-date).AddDays($chstartdate).ToString("yyyy-MM-dd hh:mm:ss")
    }
    
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
       
    $rbody = @{
                 'u_category' = $category
                 'u_subcategory' = $subcategory
                 'assignment_group' = $agroup
                 'short_description' = $sedesc
            	 'u_unlisted_ci' = $servername
				 'u_new_configuration_item' = $servername
                 'cmdb_ci' = $servername
                 'description' = $desc
                 'due_date'=$currentdate
                 }
    
	    try
	    {
	    	
	    						
	        
	        $rIncidentURL = "$ISERVICENOWLINK/api/now/table/incident"
	        #$rIncidentURL = "$PROPERTY{SERVICENOW_DEV_LINK}/api/now/table/problem"
	        $Type = "application/json"
	        # Specify request body
	        $rbodyJson = $rbody | ConvertTo-Json
	        # POST to API
	        Try 
	        {
	            $rIncidentPOSTResponse = Invoke-RestMethod -Method POST -Uri $rIncidentURL -Body $rbodyJson -TimeoutSec 100 -Credential $mcredential  -ContentType $Type
	            
	        }
	        Catch 
	        {
	            Write-Host $_.Exception.ToString()
	            $error[0] | Format-List -Force
	        }
	        # Pulling ticket ID from response
	        $IncidentID = $rIncidentPOSTResponse.result.number
	        $Incidentdesc = $rIncidentPOSTResponse.result.description
	        $assys =$rIncidentPOSTResponse.result.sys_id
	        ###############################################
	        # Verifying Incident created and show ID
	        ###############################################
	        IF ($IncidentID -ne $null)
	        {
	            "Created Problemrequest With ID:$IncidentID" 
                $global:problemout=$IncidentID
                $TableBody+="<tr><td colspan=1 ><b>Problem Ticket:</b></td><td>$($global:problemout)</td><td><b><font color=#F51010>FAIL</font></b></td></tr>`r`n"
	        }
	        ELSE
	        {
	            "Problemrequest Not Created for $initems"
                $TableBody+="<tr><td colspan=1 ><b>Problem Ticket:</b></td><td>Unable to create Problem ticket please work with SLM team or create ticket manualy!</td><td><b><font color=#F51010>FAIL</font></b></td></tr>`r`n"

	        }
	    
	    }
	    catch [Exception]
	    {   
	        $result += "<==FAIL==>: " + $_.Exception.GetType().FullName + $_.Exception.Message + "`n";
	        $result += ($_.Exception|format-list -force).toString();
	    }
	    finally
	    {
	    	if($result -like "*System.NotSupportedException*")
	    	{
	    	    echo "______________________________________________________________________________________"	
	    	}
	    	else
	    	{
	            echo $result
	    	}
	    }
    
    
    
}

function updatedb_problem_details_new()
{
	
#$global:IncidentID
	
	
#write to DB
$query = @"
UPDATE [Automation].[dbo].[commcheckaudit] SET PROBLEMNO='$global:problemout',INCIDENTSTATUS='V'
WHERE  [SERVERNAME]='$servername' and [ERRORCODE]='$errorcode' and [CREATEDON] >= DATEADD(day, -1, getdate())
"@

[string]$connectionString = GetConnectionString -user $user -pwd $pwd
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
$SqlConnection.ConnectionString = $connectionString
$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
$SqlCmd.CommandText = $query  
$SqlCmd.Connection = $SqlConnection

$SqlConnection.Open()
       
#Execute SQL Query
$uresult = $SqlCmd.ExecuteNonQuery()
if($uresult -eq 1)
{
Write-Host "RESULTTODAYICNDENT:NEW"
$TableBody+="<tr><td colspan=1 ><b>Problem ticke create state:</b></td><td>New ticket created: $($global:problemout)</td><td><b><font color=#089A28>PASS</font></b></td></tr>`r`n"
$SqlConnection.Close()
}
else
{
Write-Host "RESULTTODAYICNDENT:ERROR - $query"
$TableBody+="<tr><td colspan=1 ><b>Problem ticke state:</b></td><td>New ticket created: $($global:problemout) but unable to insert into DB $query</td><td><b><font color=#F51010>FAIL</font></b></td></tr>`r`n"

}               
                   
}

function checkticketopenstate()
{

[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12	
	#$rIncidentPOSTResponse = Invoke-RestMethod -Method POST -Uri $rIncidentURL -Body $rbodyJson -TimeoutSec 100 -Credential $mcredential  -ContentType $Type
$global:GetIncidentURI = "$ISERVICENOWLINK/api/now/table/incident?number=$global:tincident"
$global:GetIncidentURIdisplay = "$ISERVICENOWLINK/api/now/table/incident?number=$global:tincident&sysparm_display_value=true"
	
	
#$global:GetIncidentURI = "$PROPERTY{SERVICENOW_DEV_LINK}/api/now/table/incident?number=$global:tincident"
#$global:GetIncidentURIdisplay = "$PROPERTY{SERVICENOW_DEV_LINK}/api/now/table/incident?number=$global:tincident&sysparm_display_value=true"	
	
	
	$Requests = Invoke-RestMethod -Uri $global:GetIncidentURI -Credential $mcredential -Method GET -ContentType "application/json"
    $disrequests = Invoke-RestMethod -Uri $global:GetIncidentURIdisplay -Credential $mcredential -Method GET -ContentType "application/json"
    if($Requests.result.Count -ne 0)
    {
            
        $global:innumber=$Requests.result.number
        $global:insysid=$Requests.result.sys_id
        $global:inshortd=$Requests.result.short_description

       
            if($Requests.result.cmdb_ci.value)
            {
                $global:incmdb=$Requests.result.cmdb_ci.value

            }
            else
            {
                $global:incmdb="No Value found"
            }

        $global:createdon=$Requests.result.sys_created_on
        $global:assignmentgroup=$Requests.result.assignment_group.value
        $global:category=$Requests.result.category
        $global:subcategory=$Requests.result.subcategory
        $global:contact_type=$Requests.result.contact_type
        $global:desc=$Requests.result.description
        $global:cidisplay=$disrequests.result.cmdb_ci.display_value
        $global:state=$Requests.result.state

        
write-host "$global:createdon"
write-host "$global:assignmentgroup"
write-host "$global:category"
write-host "$global:subcategory"
write-host "$global:contact_type"
write-host "$global:desc"
write-host "$global:cidisplay"
write-host "$global:state"
write-host "$global:insysid"
        
        
    }
    else
    {
     	write-output 'Failed'	
    }	
	
}

function updateincident()
{
	[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12	
	$worknotes="Same Error repeted again kindly take action."
           
    $bodyn = @{ 'work_notes' = "$worknotes" }
    $bodyJsonn = $bodyn | ConvertTo-Json
    
    $URIn = "$ISERVICENOWLINK/api/now/table/incident/$global:insysid"
    #$URIn = "$PROPERTY{SERVICENOW_DEV_LINK}/api/now/table/incident/$global:insysid"
    $Requestsn = Invoke-WebRequest -Uri $URIn  -Method PUT -Credential $mcredential -Body $bodyJsonn -TimeoutSec 100 -ContentType "application/json"
  
    $global:finalstate=$global:state
    
    if($Requestsn.StatusDescription -eq "OK")
    {
    	write-host "$global:innumber has been Updated and status : $global:finalstate"
    }
    else
    {
    	write-host "Incident not Updated due to API error, Please check Incident = $global:innumber"
    }

}

function updatedb_incident_details_POST_SNOW()
{
	
#$global:IncidentID
	
	
#write to DB
$query = @"
UPDATE [Automation].[dbo].[commcheckaudit] SET INCIDENT1='$global:innumber',INCIDENTSTATUS='V'
WHERE  [SERVERNAME]='$servername' and [ERRORCODE]='$errorcode' and [CREATEDON] >= DATEADD(day, -1, getdate())
"@

[string]$connectionString = GetConnectionString -user $user -pwd $pwd
$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
$SqlConnection.ConnectionString = $connectionString
$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
$SqlCmd.CommandText = $query  
$SqlCmd.Connection = $SqlConnection

$SqlConnection.Open()
       
#Execute SQL Query
$uresult = $SqlCmd.ExecuteNonQuery()
if($uresult -eq 1)
{
Write-Host "RESULTTODAYICNDENT:NEW"


$SqlConnection.Close()
}
else
{
Write-Host "RESULTTODAYICNDENT:ERROR - $query"

}               
                   
}


###################
## MAIN FUNCTION ##
###################

todaycount
if( $global:countoftoday -eq 0 )
{
$TableBody+="<tr><td colspan=1 ><b>Count of the day:</b></td><td>$($global:countoftoday)</td><td><b><font color=#089A28>PASS</font></b></td></tr>`r`n"
write-host "RESULTTODAYCOUTN=true"
inserttoday
getlast30day_count
getlast30day_lastincident
validationticket
}
else
{
$TableBody+="<tr><td colspan=1 ><b>Count of the day:</b></td><td>$($global:countoftoday)</td><td><b><font color=#F51010>FAIL</font></b></td></tr>`r`n"
write-host "RESULTTODAYCOUTN=false"
}




#OUTPUT Block
$Body =@"
<html>
<head>
<style>
table {border-width: 2px; border-style: solid; border-color: black; border-collapse: collapse; width: 75%;}
th {border-width: 3px; padding: 3px; border-style: solid; border-color: black; background-color:burlywood; }
td {border-width: 1px; padding: 3px; border-style: solid; border-color: black;}
</style>
</head>
<body>
<b>Hello Team</b><br>
<table>
<tr><td style="background-color:#f5ed56"><center><b>Automation Status</b></td><td style="background-color:#f5ed56" colspan=2><center><b>Repeted Offender Details</b></center></td></tr>
<th>Repted Offender Policy</th><th>Results/Outputs</th><th>Status</th>
$TableBody
</table>
</body>
</html>
"@

$HTML = ConvertTo-Html -Body $Body 

"#####"
$HTML

#################

##########comm unix l1 restart#######3

#!/bin/bash

## Variable declaration
PRINT_HTML=""
/usr/boksm/bin/suexec /usr/bin/rm -rf /tmp/commvault_l1.html

ERROR_CODE='$INPUT{ERRORCODE}';


VMwareToolRestart () 
{

PRINT_HTML+="<tr><td colspan=3 ><center><font color=#3900FF size = '4'><b>VMware tool restart (VMtool)</font></b></center></td></tr>"

OSK=`uname -r | awk -F- '{print $1}'`
if [[ "$OSK" = "2.6.32" ]]; then
/usr/boksm/bin/suexec /etc/vmware-tools/services.sh restart
   
elif [[ "$OSK" = "3.10.0" ]]; then
   /usr/boksm/bin/suexec systemctl restart vmtoolsd
	
	PRINT_HTML+="<tr><td colspan=1 ><b>VMtool restart status</b></td><td>Restarted</td><td><b><font color=#089A28>PASS</font></b></td></tr>"
	else
    PRINT_HTML+="<tr><td colspan=1 ><b>VMtool restart status</b></td><td>Service not found</td><td><b><font color=#F51010>FAIL</font></b></td></tr>"
fi
}

CommvaultReset () {

PRINT_HTML+="<tr><td colspan=3 ><center><font color=#3900FF size = '4'><b>CommVault Service restart</font></b></center></td></tr>"

 COMMVAULT="/opt/simpana/Base"
 SNAPPROTECT="/opt/snapprotect"
 COMMBASE="/opt/commvault/Base"


if [ -d "$SNAPPROTECT" ]; then

			PRINT_HTML+="<tr><td colspan=3 ><center><font color=#3900FF size = '4'><b>Snapprotect Service found ${SNAPPROTECT}</font></b></center></td></tr>"
		/usr/boksm/bin/suexec /usr/bin/snapprotect status
		/usr/boksm/bin/suexec /usr/bin/snapprotect list
		/usr/boksm/bin/suexec /usr/bin/snapprotect restart
			PRINT_HTML+="<tr><td colspan=1 ><b>Snapprotect Service</b></td><td>Restarted</td><td><b><font color=#089A28>PASS</font></b></td></tr>"
		/usr/boksm/bin/suexec /usr/bin/snapprotect list
		
elif [ -d "$COMMVAULT" ]; then
		PRINT_HTML+="<tr><td colspan=3 ><center><font color=#3900FF size = '4'><b>Commvault Service found ${COMMVAULT}</font></b></center></td></tr>"
	/usr/boksm/bin/suexec /opt/simpana/Base/simpana status
	/usr/boksm/bin/suexec /opt/simpana/Base/simpana restart
		PRINT_HTML+="<tr><td colspan=1 ><b>Commvault Service</b></td><td>Restarted</td><td><b><font color=#089A28>PASS</font></b></td></tr>"
elif [ -d "$COMMBASE" ]; then
		PRINT_HTML+="<tr><td colspan=3 ><center><font color=#3900FF size = '4'><b>Commvault Service found ${COMMBASE}</font></b></center></td></tr>"
	/usr/boksm/bin/suexec /opt/commvault/Base/commvault restart
		PRINT_HTML+="<tr><td colspan=1 ><b>Commvault Service</b></td><td>Restarted</td><td><b><font color=#089A28>PASS</font></b></td></tr>"
else
 
		PRINT_HTML+="<tr><td colspan=1 ><b>Commvault Service</b></td><td>Server Not Found Commvault & SnapProtect Backup related Services</td><td><b><font color=#F51010>FAIL</font></b></td></tr>" 
 fi
 
}

#read -p "Enter the error code:" ERROR_CODE  

case $ERROR_CODE in 
10:02|10:03|10:04|10:06|10:07|10:14|13:29|13:30|17:23|17:24|19:1167|19:1307|19:2011|19:518|19:599|23:128|28:132|3:03|3:08|3:14|3:28|30:24|30:25|30:26|31:285|35:1965|35:2353|35:327|36:11|36:3|39:302|58:2|6:616|63:3|68:502|9:8|91:29)
CommvaultReset
;;
17:00)
VMwareToolRestart
;;
esac


## HTML block
>/tmp/commvault_l1.log
cat << 'EOF' >> /tmp/commvault_l1.log
<html>
<head>
<style>
table {border-width: 2px; border-style: solid; border-color: black; border-collapse: collapse; width: 75%;}
th {border-width: 3px; padding: 3px; border-style: solid; border-color: black; background-color:burlywood; }
td {border-width: 1px; padding: 3px; border-style: solid; border-color: black;}
</style>
</head>
<body>
<b>CommVault Service Restart</b>
<br>
<table>
<th>Tools/Particulars</th><th>Results/Outputs</th><th>Status</th>
EOF

echo ${PRINT_HTML} >> /tmp/commvault_l1.log

cat << 'EOF' >> /tmp/commvault_l1.log
</table>
</body>
</html>
EOF

echo "#####"

cat /tmp/commvault_l1.log

#<tr><td colspan=3 ><center><font color=#3900FF size = '4'><b>VMware Snapshot Provider Service (VMSS)</font></b></center></td></tr>
#<tr><td colspan=1 ><b>VMVSS service status</b></td><td>Disabled</td><td><b><font color=#089A28>PASS</font></b></td></tr>
#<tr><td colspan=1 ><b>VM Snapshot Provider service status/b></td><td>Service not found</td><td><b><font color=#F51010>FAIL</font></b></td></tr>


################################

##########SQL drift input##############

#initializing....
	#Resolve Credentails
	[ValidateNotNullOrEmpty()]
	$RES_USERNAME = '$INPUT{VALID_USER}'

	[ValidateNotNullOrEmpty()]
	$RES_PASSWORD = ConvertTo-SecureString '$INPUT{VALID_PASSWORD}' -AsPlainText -Force

	#Densify Credentials
	[ValidateNotNullOrEmpty()]
	$DB_USERNAME = '$INPUT{DB_USERNAME}'

	[ValidateNotNullOrEmpty()]
	$DB_USER_PASSWORD = ConvertTo-SecureString '$INPUT{DB_PASSWORD}' -AsPlainText -Force

	[ValidateNotNullOrEmpty()]
	$DB_HOST = '$INPUT{DB_HOSTNAME}'
  

#Function Connection 
function GetConnectionString ($user, $passwd)
{
  return "Server='$INPUT{DB_HOSTNAME}';Database=Automation;Integrated Security=False;User ID= $user ;Password= '$INPUT{DB_PASSWORD}' " 	
}

#Create SQL Statement
$query = @"
SELECT id,server_Name,server_Instance FROM [test].[dbo].[sqlinstances] where is_Active = 1
"@
	[string]$connectionString = 	GetConnectionString -user $DB_USERNAME -pwd $DB_USER_PASSWORD 
	$SqlConnection = New-Object System.Data.SqlClient.SqlConnection
	$SqlConnection.ConnectionString = $connectionString
	$SqlCmd = New-Object System.Data.SqlClient.SqlCommand
	$SqlCmd.CommandText = $query  
	$SqlCmd.Connection = $SqlConnection  
	
	$SqlConnection.Open()

$result = $SqlCmd.ExecuteReader()

if($result)
{
#Add result to DataTable Object and Display it
$table = new-object "System.Data.DataTable"
$table.Load($result)

#Write-Host ($table | Format-Table | Out-String)
$final=@()
Foreach ($t in $table)
{
	if($t -ne "")
	{
	[STRING]$copy_id		            =   $t.id	
	[STRING]$copy_inputserver            =   $t.server_Name
	[STRING]$copy_serverinstance               =   $t.server_Instance
	[string]$value = ":"+ $copy_id+","+$copy_inputserver+","+$copy_serverinstance;
	$final += $value;
	}
}
$final
}

else
{
	write-host "Unsuccessful : $query"
}
	$SqlConnection.Close()


#########################


#############sql drift mail sc###########

$queueserver = $env:COMPUTERNAME
write-host "RM server is $queueserver"
$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password

$source = '$INPUT{COMPUTERNAME}'
#Resolve Credentails

$DB_TABLE         						= '$INPUT{ETS_DB_TABLE_SQLDRIFT}' # "[TEST].[dbo].[sqlinstanceconfigs]"
$DB_USERNAME      						= '$INPUT{DB_USERNAME}'
$DB_USER_PASSWORD 						= '$INPUT{DB_PASSWORD}'
$DB_HOST          						= '$INPUT{DB_HOST}'
$SERVER_ID								= '$INPUT{SERVER_ID}'
$SERVER_INSTANCE  						= '$INPUT{DESTINATION_SERVER}'
$SERVER_NAME      						= '$INPUT{SOURCE_SERVER}'

Try
{
$executed_date = get-date
$worksheetno = '$INPUT{WORKSHEETNO}'

$insertSQL = @'
        EXEC [TEST].[dbo].[sp_SQL_Drift_Insert]
            @server_Name = N'{0}',
            @server_Instance = N'{1}',
            @install_D = N'{2}',
            @adhoc_DistributedQueries = N'{3}',
            @cross_DB_Ownership = N'{4}',
            @mail_XPs = N'{5}',
            @old_Automation_Procedure = N'{6}',
            @trustworthy_Database = N'{7}',
            @serverProtocol_NamedPipes = N'{8}',
            @serverProtocol_TCPIP = N'{9}',
            @serverProtocol_SharedMemory = N'{10}',
            @xp_Cmdshell = N'{11}',
            @sa_Account= N'{12}',
            @connect_Permission= N'{13}',
            @orphaned_Users= N'{14}',
            @default_Trace= N'{15}',
            @server_Audit= N'{16}',
            @clr_Assembly= N'{17}',
            @symmetric_Key_Encryption= N'{18}',
            @asymmetric_KeySize= N'{19}',
            @error_Log= N'{20}',
            @agentHistory_HistoryLog= N'{21}',
            @agentHistory_Historyrows= N'{22}',
            @extended_Stored_Procedures= N'{23}',
            @authenticated_Logins= N'{24}',
            @check_Expiration= N'{25}',
            @check_Policy= N'{26}',
            @login_Auditing= N'{27}',
            @company_ARC_Data_Collection= N'{28}',
            @company_PMP_PID1= N'{29}',
            @sql_Version= N'{30}'
'@

write-host "server instance is $SERVER_INSTANCE"
write-host "server id is $SERVER_ID"
$Auditdetails = Invoke-Command -ComputerName $source -Credential $credential -Scriptblock {
$SERVER_INSTANCE  = '$INPUT{DESTINATION_SERVER}'
[string] $database    = "master"
[string] $sqlCommand  = $("select PhysicalName = SERVERPROPERTY('ComputerNamePhysicalNetBIOS'), SQLName = SERVERPROPERTY('MachineName'), SQLID = ISNULL(SERVERPROPERTY('InstanceName'), 'MSSQLSERVER'), SQLInstanceName = SERVERPROPERTY('ServerName'), SQLVersion = SUBSTRING(@@VERSION,0,CHARINDEX(CHAR(9),@@VERSION))")


$connectionString     = "Data Source=$SERVER_INSTANCE; " + "Integrated Security=SSPI; " + "Initial Catalog=$database"
$connection           = new-object system.data.SqlClient.SQLConnection($connectionString)
$command              = new-object system.data.sqlclient.sqlcommand($sqlCommand,$connection)
$connection.Open()

$adapter              = New-Object System.Data.sqlclient.sqlDataAdapter $command
$dataset              = New-Object System.Data.DataSet

[void] $adapter.Fill($dataSet)

$table                = new-object system.data.datatable
$table                = $dataset.Tables[0] 

$PhysicalName  = $dataset.Tables[0].Rows[0].PhysicalName
$SQLName       = $dataset.Tables[0].Rows[0].SQLName
$SQLId         = $dataset.Tables[0].Rows[0].SQLID
$SQLInstance   = $dataset.Tables[0].Rows[0].SQLInstanceName
$SQLVersion    = $dataset.Tables[0].Rows[0].SQLVersion

#write-host "PhysicalName $PhysicalName  "
#write-host "SQLName      $SQLName  "
#write-host "SQLId        $SQLId  "
#write-host "SQLInstance  $SQLInstance  "


$connection.Close()

$NPdesc    = "Ensure Unnecessary SQL Server Protocols are set to Disabled : Named Pipes  "
$TCPdesc   = "Ensure Unnecessary SQL Server Protocols are set to Disabled : TCP/IP       "
$SMdesc    = "Ensure Unnecessary SQL Server Protocols are set to Disabled : Shared Memory"

$reg       = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $PhysicalName)
$regkey    = $reg.OpenSubkey("SOFTWARE\\Microsoft\\Microsoft SQL Server\\Instance Names\\SQL")
$RegFolder = $regkey.GetValue("$SQLId")

$RegProperty = "Enabled"

$NPPath      = "SOFTWARE\\Microsoft\\Microsoft SQL Server\\$RegFolder\\MSSQLServer\\SuperSocketNetLib\\NP"
$NPregkey    = $reg.OpenSubkey("$NPPath")
$NPRegValue  = $NPregkey.GetValue("$RegProperty")

$SMPath      = "SOFTWARE\\Microsoft\\Microsoft SQL Server\\$RegFolder\\MSSQLServer\\SuperSocketNetLib\\SM"
$SMregkey    = $reg.OpenSubkey("$SMPath")
$SMRegValue  = $SMregkey.GetValue("$RegProperty")

$TCPPath     = "SOFTWARE\\Microsoft\\Microsoft SQL Server\\$RegFolder\\MSSQLServer\\SuperSocketNetLib\\TCP"
$TCPregkey    = $reg.OpenSubkey("$TCPPath")
$TCPRegValue  = $TCPregkey.GetValue("$RegProperty")

if ($NPRegValue  -eq 1)  {$NPRegValueDesc  = "1"} else {$NPRegValueDesc  = "0"}
if ($SMRegValue  -eq 1)  {$SMRegValueDesc  = "1"} else {$SMRegValueDesc  = "0"}
if ($TCPRegValue -eq 1)  {$TCPRegValueDesc = "1"} else {$TCPRegValueDesc = "0"}

#write-host "Server: $PhysicalName (Instance: $SQLInstance )"
$NPRegValueDesc
$SMRegValueDesc
$TCPRegValueDesc
$SQLVersion
#write-host "$NPdesc  - $NPRegValue (Status - $NPRegValueDesc)   "
#write-host "$SMdesc  - $SMRegValue (Status - $SMRegValueDesc)   "
#write-host "$TCPdesc  - $TCPRegValue (Status - $TCPRegValueDesc)"
#write-host ""
#write-host ""


function exec-sqlCommand() 
{    
	[cmdletbinding(DefaultParameterSetName="integrated")]Param (
        [Parameter(Mandatory=$true                                   )][Alias("Serverinstance")][string]$Server,
        [Parameter(Mandatory=$true                                   )][string]$Database,
        [Parameter(Mandatory=$true, ParameterSetName="not_integrated")][string]$Username,
        [Parameter(Mandatory=$true, ParameterSetName="not_integrated")][string]$Password,
        [Parameter(Mandatory=$false,ParameterSetName="integrated"    )][switch]$UseWindowsAuthentication = $true,
      ##[Parameter(Mandatory=$true                                   )][string]$Query,
        [Parameter(Mandatory=$false                                  )][int]$CommandTimeout=0

    )

    $connstring = "Server=$Server; Database=$Database; "

    If ($PSCmdlet.ParameterSetName -eq "not_integrated") 
    {   $connstring += "User ID=$username; Password=$password;" 
    }
    ElseIf ($PSCmdlet.ParameterSetName -eq "integrated") 
    { 
        $connstring += "Trusted_Connection=Yes; Integrated Security=SSPI;" 
    }
    
    #connect to database
    $connection = New-Object System.Data.SqlClient.SqlConnection($connstring)
    $connection.Open()
    
    #build query object
    $command                = $connection.CreateCommand()
    $command.CommandText    = $Query
    $command.CommandTimeout = $CommandTimeout
    
    #run query
    $adapter = New-Object System.Data.SqlClient.SqlDataAdapter $command
    $dataset = New-Object System.Data.DataSet
    $adapter.Fill($dataset) | out-null
    
    #return the first collection of results or an empty array
    If  ($dataset.Tables[0] -ne $null) 
    {
        $table = $dataset.Tables[0]
    }
    ElseIf ($table.Rows.Count -eq 0) 
    { 
        $table = New-Object System.Collections.ArrayList 
    }
    
    $connection.Close()
    #$result += $table
    #$result1 = $result 
    #$result1 | ConvertTo-Json
    #$result | Format-table -Property CheckListNo,Checklist,Status,Remarks,ServerName,Inserted | Out-String -Width 4096 | convertto-json
    return $table
    }


$Query = @"
USE master
SET NOCOUNT ON

-----------------------------------------------------------------------------------------------------------------------------
--Cleanup - deletes data if exists for same day (i.e. eliminates duplicate data when script ran more than once on same day)
-----------------------------------------------------------------------------------------------------------------------------
DECLARE @RowNo           BIGINT
DECLARE @DateToDelData   DATETIME
SELECT  @DateToDelData = CONVERT(VARCHAR(25), GETDATE(), 111)


DECLARE @vAuditCheckList       TABLE
        ( [AuditRowNo]          bigint        NOT NULL
        , [CheckListNo]         int           NOT NULL IDENTITY(1,1)
        , [Checklist]           varchar (120) NOT NULL
        , [Status]              varchar ( 20) NULL
        , [Remarks]             varchar (MAX) NULL
        , [ServerName]          varchar ( 30) NOT NULL
        , [Inserted]            datetime      NOT NULL
        , [UserName]            varchar ( 30) NOT NULL
		,[Sort]					int               NULL
        )
DECLARE @vAuditCheck_SqlLogins  TABLE
        ( AuditRowNo            bigint        NOT NULL
        , ServerName            varchar(30)   NOT NULL
        , LoginName             varchar(50)   NOT NULL
        , IsDisabled            bit           NULL
        , IsMustChange          varchar(15)   NULL
        , is_policy_checked     varchar(15)   NULL
        , is_expiration_checked varchar(15)   NULL
        , IsSysAdmin            bit           NULL
        , Inserted              datetime      NOT NULL
        )
DECLARE @vAuditCheck_xProcs     TABLE 
        ( AuditRowNo            bigint        NOT NULL
        , ServerName            varchar(30)   NOT NULL
        , RoleName              varchar(15)   NOT NULL
        , RoleDesc              varchar(15)   NULL
        , PermissionName        varchar(18)   NULL
        , StateDesc             varchar(18)   NULL
        , Class_Desc            varchar(20)   NULL
        , ObjectName            varchar(38)   NULL
        , Inserted              datetime      NOT NULL
        )



SELECT  @RowNo         = MAX(AuditRowNo) FROM @vAuditCheckList
SELECT  @RowNo         = ISNULL(@RowNo, 0) + 1


DECLARE @DBList varchar(MAX)

-----------------------------------------------------------------------------------------------------------------------------
--Check for install files under the D:\SQL installation directory
-----------------------------------------------------------------------------------------------------------------------------
DECLARE @SQLOutput   VARCHAR(255)
DECLARE @Status      VARCHAR(15)
EXEC    MASTER.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'
                                     , N'SOFTWARE\Microsoft\MSSQLServer\Setup'
                                     , N'SQLBinRoot'
                                     , @SQLOutput OUTPUT
                                     
SET      @Status     = CASE WHEN LEFT(@SQLOutput, 1) = 'D' then '1' ELSE '0' END

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
VALUES    ( @RowNo
          , 'Check for install files under the D: drive SQL installation directory'
          , @Status
          , @SQLOutput
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                                                                  ------
          )
          
-----------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Ad Hoc Distributed Queries' Server Configuration Option is set to '0'
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Ad Hoc Distributed Queries Server Configuration Option is set to 0'
          , CASE Value_In_Use WHEN 1 THEN '0' Else '1' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                                                                  -------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'Ad Hoc Distributed Queries'

-----------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Cross DB Ownership Chaining' Server Configuration Option is set to '0'
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Cross DB Ownership Chaining Server Configuration Option is set to 0'
          , CASE Value_In_Use WHEN 1 THEN '0' Else '1' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                      -------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'cross db ownership chaining'

-----------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Database Mail XPs' Server Configuration Option is set to '0'
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Database Mail XPs Server Configuration Option is set to 0'
          , CASE Value_In_Use WHEN 1 THEN '0' Else '1' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                          ----------------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'Database Mail XPs'

-----------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Ole Automation Procedures' Server Configuration Option is set to '0'
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Ole Automation Procedures Server Configuration Option is set to 0'
          , CASE Value_In_Use WHEN 1 THEN '0' Else '1' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                              -------------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'Ole Automation Procedures'

----------------------------------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Trustworthy' Database Property is set to 'Off'
----------------------------------------------------------------------------------------------------------------------------------------------------
DECLARE     @DBTrustWorthy  TABLE ( DBName VARCHAR(50) )
INSERT INTO @DBTrustWorthy
SELECT     CONVERT(NVARCHAR(50), Name) FROM sys.databases (nolock) WHERE database_id <> 4 and is_trustworthy_on <>0    

SET @DBList =''
SELECT @DBList = @DBList + CONVERT(varchar, DBName) + ';' FROM @DBTrustWorthy    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Trustworthy Database Property is set to Off'
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '1' Else '0' END
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '' Else 'Trustworthy Database Property is On: ' + LEFT(@DBList, LEN(@DBList) - 1) END
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                          ------------------------------
-----------------------------------------------------------------------------------------------------------------------------
--Verify xp_cmdshell is disabled (default)
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify xp_cmdshell is disabled'
          , CASE Value_In_Use WHEN 1 THEN '0' Else '1' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'xp_cmdshell'

-----------------------------------------------------------------------------------------------------------------------------
--Verify the 'sa' account is disabled
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify the SA account is disabled'
          , CASE is_disabled WHEN 1 THEN '1' Else '0' END
          , CONVERT(VARCHAR(15), is_disabled)
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------
FROM   sys.SQL_LOGINS           (NOLOCK) 
WHERE  [Name] = N'sa' or [Name] = N'sadba'

-----------------------------------------------------------------------------------------------------------------------------
--Ensure CONNECT permissions on the 'guest user' is Revoked within all SQL Server databases excluding the master, msdb and tempdb
-----------------------------------------------------------------------------------------------------------------------------
DECLARE @GuestDBs  TABLE(SNo int identity(1, 1), DatabaseName VARCHAR(50), UserName varchar(15), IsEnabled varchar(5))
DECLARE @GuestUsers VARCHAR(MAX)
DECLARE @SQL       VARCHAR(MAX);

SET @SQL = '
            IF exists (SELECT 1 FROM sys.databases WHERE state=0 and name = ''?'' ) and (db_id(''?'') > 4)
            BEGIN
                         if exists (select 1 from [?].sys.sysusers WHERE  name = ''guest'' and hasdbaccess = 1)
                           begin
                SELECT [DatabaseName] = ''?'', name,  hasdbaccess = CASE hasdbaccess WHEN 0 THEN ''0'' WHEN 1 THEN ''1'' END FROM [?].sys.sysusers SL WHERE SL.NAME IN (''GUEST'') 
                           end
            END';
INSERT   INTO @GuestDBs (DatabaseName, UserName, IsEnabled) EXEC sp_MSforeachdb @SQL;

SET    @GuestUsers = ''
SELECT @GuestUsers = case when SNo = 1 
                         then 'Guest user connect permission exist for db(s) ' + @GuestUsers  + DatabaseName 
                         else @GuestUsers  + ', ' + DatabaseName 
                    end
FROM   @GuestDBs 
WHERE  UserName = 'Guest'


INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure CONNECT permissions on the guest user is Revoked within all SQL Server DBS excluding master msdb model & tempdb'
          , CASE LTRIM(RTRIM(@GuestUsers)) WHEN '' THEN '1' Else '0'        END
          , CASE LTRIM(RTRIM(@GuestUsers)) WHEN '' THEN ''    Else @GuestUsers END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------

-----------------------------------------------------------------------------------------------------------------------------
--Ensure 'Orphaned Users' are Dropped From SQL Server Databases
-----------------------------------------------------------------------------------------------------------------------------
--DECLARE @DBList varchar(150)
DECLARE @OrphanUser TABLE( DatabaseName VARCHAR(50), OrphName VARCHAR(50)
                           );
--DECLARE @SQL VARCHAR(MAX);
IF( SELECT SUBSTRING(CONVERT( VARCHAR(25), SERVERPROPERTY('ProductVersion')), 1, CHARINDEX('.', CONVERT(VARCHAR(25), SERVERPROPERTY('ProductVersion'))) - 1)) < 12
    BEGIN
        SET @SQL = '
            IF exists (SELECT 1 FROM sys.databases WHERE state=0 and database_id not in (1,2 ,3 ,4))
            BEGIN
                SELECT ''?'' [DatabaseName], A.Name
                FROM [?].sys.database_principals a
                LEFT OUTER JOIN sys.server_principals  b on a.sid=b.sid
                WHERE a.type = ''S'' 
                AND a.name NOT IN (''dbo'',''sys'',''INFORMATION_SCHEMA'',''guest'') AND a.name NOT LIKE ''%##%'' AND DB_ID(''?'') > 4
                AND b.sid IS NULL
            END';
    END;
ELSE
    BEGIN
        SET @SQL = '
        IF exists (SELECT 1 FROM sys.databases WHERE state=0 and database_id not in (1,2 ,3 ,4))
        BEGIN
                SELECT ''?'' [DatabaseName], A.Name
                FROM [?].sys.database_principals a
                LEFT OUTER JOIN sys.server_principals  b on a.sid=b.sid
                WHERE a.type = ''S'' 
                AND a.name NOT IN (''dbo'',''sys'',''INFORMATION_SCHEMA'',''guest'') AND a.name NOT LIKE ''%##%'' AND DB_ID(''?'') > 4
                AND b.sid IS NULL AND a.authentication_type=1
        END';
        
    END;
INSERT INTO @OrphanUser
EXEC sp_MSforeachdb   @SQL;

SET @DBList =''
SELECT @DBList = @DBList + CONVERT(varchar, DatabaseName) + '-' + CONVERT(varchar, OrphName) + ';' FROM @OrphanUser    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Orphaned Users are Dropped From SQL Server Databases'
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '1' Else '0' END
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '' Else 'Orphaned users: ' + LEFT(@DBList, LEN(@DBList) - 1) END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------

-----------------------------------------------------------------------------------------------------------------------------
--Verify that 'Default Trace Enabled' server configuration option is set to €œ1€
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify Default Trace Enabled server configuration option is set to 1'
          , CASE Value_In_Use WHEN 1 THEN '1' Else '0' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'default trace enabled'

----------------------------------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Login Auditing' is set to Both 'failed' and 'successful logins'.  Failed applicable only if 'SQL Server Audit' function is unavailable.
----------------------------------------------------------------------------------------------------------------------------------------------------
DECLARE @tmpLgAudits TABLE ( ServerName  VARCHAR(45) NOT NULL DEFAULT (@@servername)                                                    
                         , Description VARCHAR(25)                                                    
                         , Value       VARCHAR(07)                                                    
                         , AuditLevelDescription   AS  CASE Value WHEN 0 THEN 'None'                                                    
                                                                   WHEN 1 THEN 'Successful logins only'                                                    
                                                                   WHEN 2 THEN 'Failed logins only'                                                    
                                                                   WHEN 3 THEN 'Both failed and successful logins'                                                    
                                                       END                                                    
                         )                                                    
INSERT INTO @tmpLgAudits   ([Description], Value)                                                      
EXEC   master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'                                                    
                                     , N'Software\Microsoft\MSSQLServer\MSSQLServer'                                                    
                                     , N'AuditLevel'                                                    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure SQL Server Audit is set to capture both failed and successful logins'
          , CASE WHEN Value = 3 THEN '1' ELSE '0' END 
          , CASE Value WHEN 1 THEN CONVERT(VARCHAR(15), Value) + ' - Successful logins only' WHEN 2 THEN  CONVERT(VARCHAR(15), Value) + ' - Failed logins only' WHEN 3 THEN CONVERT(VARCHAR(15), Value) + ' - Both failed and successful logins' Else 'None' END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------
FROM   @tmpLgAudits
----------------------------------------------------------------------------------------------------------------------------------------------------
-- 6.20    Ensure 'CLR Assembly Permission Set' is set to 'SAFE_ACCESS' for All CLR Assemblies
----------------------------------------------------------------------------------------------------------------------------------------------------
DECLARE  @CLRassemblies  TABLE
(
Name VARCHAR(100),
Permission_Set_Desc VARCHAR(50)
)

INSERT INTO @CLRassemblies
EXEC sp_msforeachdb '
USE [?]
SELECT       ASMBLY.NAME, ASMBLY.PERMISSION_SET_DESC
FROM        SYS.ASSEMBLY_MODULES AM
INNER JOIN  SYS.ASSEMBLIES ASMBLY
        ON  ASMBLY.ASSEMBLY_ID = AM.ASSEMBLY_ID
WHERE ASMBLY.NAME NOT LIKE ''MICROSOFT%'' AND ASMBLY.PERMISSION_SET_DESC NOT IN (''SAFE_ACCESS'')';


SET @DBList =''
SELECT @DBList = @DBList + CONVERT(varchar, Name) + '-' + CONVERT(varchar, Permission_Set_Desc) + ';' FROM @CLRassemblies    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure CLR Assembly Permission Set is set to SAFE_ACCESS for All CLR Assemblies'
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '1' Else '0' END
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '' Else 'CLR Assemblies: ' + LEFT(@DBList, LEN(@DBList) - 1) END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------

          
----------------------------------------------------------------------------------------------------------------------------------------------------
-- 7.10  Ensure 'Symmetric Key encryption algorithm' is set to 'AES_128' or higher in non-system databases
----------------------------------------------------------------------------------------------------------------------------------------------------
DECLARE @SymmetricKys TABLE
([Name] VARCHAR(75),
[Algorithm_Desc] VARCHAR(20)
);
DECLARE @SQLSymKy VARCHAR(400);
SET @SQLSymKy = '
USE [?]
            IF DB_ID() not in  (1,2,3,4)
            BEGIN
                SELECT  Name,Algorithm_Desc FROM sys.symmetric_keys where Algorithm_Desc not in (''AES_128'',''AES_192'',''AES_256'')
            END';
INSERT INTO @SymmetricKys
EXEC sp_msforeachdb @SQLSymKy

SET @DBList =''
SELECT @DBList = @DBList + CONVERT(varchar, Name) + '-' + CONVERT(varchar, Algorithm_Desc) + ';' FROM @SymmetricKys    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Symmetric Key encryption algorithm is set to AES_128 or higher in non-system databases'
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '1' Else '0' END
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN 'AES_128 or Higher in non-system databases' Else 'Symmetric Key Encryption: ' + LEFT(@DBList, LEN(@DBList) - 1) END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------


             
----------------------------------------------------------------------------------------------------------------------------------------------------
-- 7.10  Ensure Asymmetric Key Size is set to 'greater than or equal to 2048' in non-system databases
----------------------------------------------------------------------------------------------------------------------------------------------------
IF EXISTS(SELECT * FROM @SymmetricKys)
    DELETE FROM @SymmetricKys
SET @SQLSymKy = '
USE [?]
            IF DB_ID() not in  (1,2,3,4)
            BEGIN
                SELECT Name,Algorithm_Desc FROM sys.asymmetric_keys where Algorithm_Desc not in (''RSA_2048'')
            END';
INSERT INTO @SymmetricKys
EXEC sp_msforeachdb @SQLSymKy

SET @DBList =''
SELECT @DBList = @DBList + CONVERT(varchar, Name) + '-' + CONVERT(varchar, Algorithm_Desc) + ';' FROM @SymmetricKys    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Asymmetric Key Size is set to greater than or equal to 2048 in non-system databases'
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '1' Else '0' END
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN 'RSA_2048 or Higher in non-system databases' Else 'Asymmetric Key Encryption: ' + LEFT(@DBList, LEN(@DBList) - 1) END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------


-----------------------------------------------------------------------------------------------------------------------------
--Verify the number of default SQL error log files is >= 12
-----------------------------------------------------------------------------------------------------------------------------
DECLARE @tmpErrorLogs TABLE (Value VARCHAR(25), Data Varchar(80))

INSERT INTO @tmpErrorLogs            (Value, Data)  
EXEC MASTER.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'
                                  , N'Software\Microsoft\MSSQLServer\MSSQLServer'
                                  , N'NumErrorLogs'

IF EXISTS (SELECT TOP 1 1 FROM @tmpErrorLogs)
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify number of default SQL error log files is >= 12'
              , CASE WHEN Data >= 12 THEN '1' ELSE '0' END
              , Data
              , @@SERVERNAME
              , GETDATE()
              , SUSER_NAME()
			  ,0                                                               -----------------------------------
    FROM        @tmpErrorLogs
END
ELSE
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify number of default SQL error log files is >= 12'
              , '0'
              , ''
              , @@SERVERNAME, GETDATE(), SUSER_NAME()
			  ,0                                                               -----------------------------------
END
-----------------------------------------------------------------------------------------------------------------------------
--Verify the SQL Agent History (Maximum job history log size (rows) = 50000), Maximum job history rows per job = 5000
-----------------------------------------------------------------------------------------------------------------------------
DECLARE @tmpJobHistRows TABLE (Value VARCHAR(50), Data Varchar(70))


INSERT INTO @tmpJobHistRows          (Value, Data)  
exec master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'
                                  , N'Software\Microsoft\MSSQLServer\SQLServerAgent'
                                  , N'JobHistoryMaxRows'

IF EXISTS (SELECT TOP 1 1 FROM @tmpJobHistRows)
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify SQL Agent History, Max job history log size rows=50000'
              , CASE WHEN Data >= 50000 THEN '1' ELSE '0' END
              , Data
              , @@SERVERNAME
              , GETDATE()
              , SUSER_NAME()
			  ,0                                                               -----------------------------------
    FROM        @tmpJobHistRows
END
ELSE
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify SQL Agent History, Max job history log size rows=50000'
              , 'No'
              , ''
              , @@SERVERNAME, GETDATE(), SUSER_NAME()
			  ,0                                                               -----------------------------------
END

DECLARE @tmpJobHistRowsPerJob TABLE (Value VARCHAR(50), Data Varchar(70))

INSERT INTO @tmpJobHistRowsPerJob    (Value, Data)  
exec master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'
                                  , N'Software\Microsoft\MSSQLServer\SQLServerAgent'
                                  , N'JobHistoryMaxRowsPerJob'

IF EXISTS (SELECT TOP 1 1 FROM @tmpJobHistRowsPerJob)
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify SQL Agent History, Max job history rows per job=5000'
              , CASE WHEN Data >= 5000 THEN '1' ELSE '0' END
              , Data
              , @@SERVERNAME, GETDATE(), SUSER_SNAME()
			  ,0                                                               -----------------------------------
    FROM        @tmpJobHistRowsPerJob
END
ELSE
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify SQL Agent History, Max job history rows per job=5000'
              , 'No'
              , ''
              , @@SERVERNAME, GETDATE(), SUSER_SNAME()
			  ,0                                                               -----------------------------------
END

-----------------------------------------------------------------------------------------------------------------------------
--Verify Revoke execute on extended stored procedures to ?PUBLIC?
-----------------------------------------------------------------------------------------------------------------------------
DECLARE      @xProcsCount   INT
DECLARE      @xProcsStatus  VARCHAR(10)
DECLARE      @xProcsDesc    VARCHAR(100)

INSERT INTO  @vAuditCheck_xProcs
           ( AuditRowNo
           , RoleName       
           , RoleDesc       
           , PermissionName 
           , StateDesc      
           , Class_Desc     
           , ObjectName   
		   , ServerName
		   , Inserted
           )
SELECT     @RowNo
         , RoleName               = CONVERT(VARCHAR(15), sdb.name    )
         , RoleDesc               = CONVERT(VARCHAR(15), sdb.type_desc)
         , PermissionName         = CONVERT(VARCHAR(18), spr.permission_name)
         , StateDesc              = CONVERT(VARCHAR(10), spr.state_desc)
         , Class_Desc             = CONVERT(VARCHAR(20), spr.class_desc)
         , ObjectName             = CONVERT(VARCHAR(38), object_name(spr.major_id))
		 , @@SERVERNAME
		 , GETDATE()
from       sys.database_principals  sdb (NOLOCK) 
left  join sys.database_permissions spr (NOLOCK) ON spr.grantee_principal_id = sdb.principal_id
inner JOIN sys.all_objects          sao (NOLOCK) ON spr.major_id = sao.object_id
WHERE      sdb.name            =  'public' 
       and sao.[type]          =  'X' 
       and sao.is_ms_shipped   <> 1
       and spr.permission_name =  'EXECUTE'
ORDER BY   sao.Name

SELECT     @xProcsCount  = COUNT(*) FROM @vAuditCheck_xProcs
IF         @xProcsCount  > 0
BEGIN
      SET @xProcsStatus = '0'
      SET @xProcsDesc   = CONVERT(VARCHAR(15), @xProcsCount) + ' extended proc(s) has Execute permission to PUBLIC'

END
ELSE
BEGIN
      SET @xProcsStatus = '1'
      SET @xProcsDesc   = ''
END

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Revoke execute on extended stored procedures to PUBLIC'
          , @xProcsStatus
          , @xProcsDesc
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------


-------------------------------------------------------------------------------------------------------------------------------
--Verify the 'MUST_CHANGE'      option is set to ?ON? for all SQL Authenticated Logins
--Verify the 'CHECK_EXPIRATION' option is set to ?ON? for all SQL Authenticated Logins within the SYSADMIN Role
--Verify the 'CHECK_POLICY'     option is set to ?ON? for all SQL Authenticated Logins
-------------------------------------------------------------------------------------------------------------------------------
--Verify the 'MUST_CHANGE'      option is set to ?ON? 
DECLARE    @MustChangeCount  VARCHAR( 20)
DECLARE    @MustChangeStatus VARCHAR( 10)
DECLARE    @MustChangeDesc   VARCHAR(100)

INSERT     INTO @vAuditCheck_SqlLogins
              ( AuditRowNo, LoginName, IsDisabled, IsMustChange, is_policy_checked, is_expiration_checked, IsSysAdmin, ServerName, Inserted)
SELECT          @RowNo
              , slq.Name
              , slq.Is_Disabled
              , CONVERT(VARCHAR(15), LOGINPROPERTY(slq.Name, 'IsMustChange') )
              , CONVERT(VARCHAR(15), slq.is_policy_checked                   )
              , CONVERT(VARCHAR(15), slq.is_expiration_checked               )
              , CONVERT(VARCHAR(15), IS_SRVROLEMEMBER('sysadmin', Name     ) )
              , @@SERVERNAME
              , GETDATE()
FROM            sys.SQL_LOGINS                 slq (NOLOCK) 

SELECT          @MustChangeCount  = COUNT(*) FROM @vAuditCheck_SqlLogins WHERE IsMustChange = 0 AND IsDisabled = 0
IF         @MustChangeCount  > 0
BEGIN
      SET @MustChangeStatus = '0'
      SET @MustChangeDesc   = 'User must change password on next login policy was not SET to ON for ' + CONVERT(VARCHAR(15), @MustChangeCount) + ' sql login(s)'

END
ELSE
BEGIN
      SET @MustChangeStatus = '1'
      SET @MustChangeDesc   = ''
END

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify the MUST_CHANGE option is set to ON for all SQL Authenticated Logins'
          , @MustChangeStatus
          , @MustChangeDesc
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------


--Verify the 'CHECK_EXPIRATION' option is set to ?ON? for all SQL Authenticated Logins within the SYSADMIN Role
DECLARE    @CheckExpirationCount  VARCHAR( 20)
DECLARE    @CheckExpirationStatus VARCHAR( 10)
DECLARE    @CheckExpirationDesc   VARCHAR(100)

SELECT     @CheckExpirationCount  = COUNT(*) FROM @vAuditCheck_SqlLogins WHERE is_expiration_checked = 0 AND IsSysAdmin = 1 AND IsDisabled = 0
IF         @CheckExpirationCount  > 0
BEGIN
      SET @CheckExpirationStatus = '0'
      SET @CheckExpirationDesc   = 'Enforce Password Expiration policy was NOT SET to ON for ' + CONVERT(VARCHAR(15), @CheckExpirationStatus) + ' sql login(s)'

END
ELSE
BEGIN
      SET @CheckExpirationStatus = '1'
      SET @CheckExpirationDesc   = ''
END

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify the CHECK_EXPIRATION option is set to ON for all SQL Authenticated Logins within the SYSADMIN Role'
          , @CheckExpirationStatus
          , @CheckExpirationDesc
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------


--Verify the 'CHECK_POLICY'     option is set to ?ON? for all SQL Authenticated Logins
DECLARE    @CheckPolicyCount  VARCHAR( 20)
DECLARE    @CheckPolicyStatus VARCHAR( 10)
DECLARE    @CheckPolicyDesc   VARCHAR(100)

SELECT     @CheckPolicyCount  = COUNT(*) FROM @vAuditCheck_SqlLogins WHERE is_policy_checked = 0 AND IsDisabled = 0
IF         @CheckPolicyCount  > 0
BEGIN
      SET @CheckPolicyStatus = '0'
      SET @CheckPolicyDesc   = 'Enforce Password policy was NOT SET to ON for ' + CONVERT(VARCHAR(15), @CheckPolicyCount) + ' sql login(s)'

END
ELSE
BEGIN
      SET @CheckPolicyStatus = '1'
      SET @CheckPolicyDesc   = ''
END

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify the CHECK_POLICY option is set to ON for all SQL Authenticated Logins'
          , @CheckPolicyStatus
          , @CheckPolicyDesc
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------



-------------------------------------------------------------------------------------------------------------------------------
--Verify 'Login Auditing' is set minimally to €œFailed€, but also €œSuccessful€ if server and application can support it
-------------------------------------------------------------------------------------------------------------------------------
DECLARE @tmp1Audits TABLE ( ServerName  VARCHAR(45) NOT NULL DEFAULT (CONVERT(VARCHAR(128), @@SERVERNAME))
                         , Description VARCHAR(50)
                         , Value       VARCHAR(70)
                         , AuditLevelDescription   AS  CASE Value  WHEN 0 THEN 'None'
                                                                   WHEN 1 THEN 'Successful logins only'
                                                                   WHEN 2 THEN 'Failed logins only'
                                                                   WHEN 3 THEN 'Both failed and successful logins'
                                                       END
                         )
INSERT INTO @tmp1Audits   ([Description], Value)  
EXEC   master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'
                                     , N'Software\Microsoft\MSSQLServer\MSSQLServer'
                                     , N'AuditLevel'

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify Login Auditing is set minimally to Failed, but also Successful if server & application can support it'
          , CASE WHEN Value = 2 OR Value = 3 THEN '1' ELSE '0' END
          , Value + ' - ' + AuditLevelDescription
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------
FROM        @tmp1Audits
----------------------------------------------------------------------------------------------------------------------------
--Verify stored procedure 000_company_PMP_PID1 is scheduled to change the 'sa' password every 45 days
--Verify the '000 company ARC Data Collection' procedure is set up to run daily and capture the ACL data for the ARC reviews
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT     @RowNo
        , [JobDescription]        = CASE WHEN sjb.name = '000_company_ARC_Data_Collection' THEN 'Verify the 000_company_ARC_Data_Collection procedure is set up to run daily and capture the ACL data for the ARC reviews'
                                           WHEN sjb.name = '000_company_PMP_PID1'            THEN 'Verify stored procedure 000_company_PMP_PID1 is scheduled to change the "sa" password every 45 days'
                                           ELSE sjb.name
                                      END
          , [JobEnabled]            = CASE WHEN sjb.enabled = 0    THEN '0' WHEN sjb.enabled = 1 THEN '1' END
          , Schedule                = CONVERT(VARCHAR(50), 'Schedule - ' 
                                      + 
                                      CASE WHEN sjb.enabled = 0                                THEN 'Disabled'
                                           WHEN sjb.job_id IS NULL                             THEN 'Unscheduled'
                                           WHEN ssc.freq_type = 0x1                            THEN 'Once on ' + CONVERT(CHAR(10), CAST( CAST( ssc.active_start_date AS VARCHAR ) AS DATETIME ), 102 /*yyyy.mm.dd*/ )
                                           WHEN ssc.freq_type = 0x4  AND ssc.freq_interval = 1 THEN 'Daily'
                                           WHEN ssc.freq_type = 0x4  AND ssc.freq_interval > 1 THEN 'Every ' + CONVERT(VARCHAR(12), ssc.freq_interval) + ' day(s)'
                                           WHEN ssc.freq_type = 0x8  THEN -- weekly
                                                                     CASE WHEN ssc.freq_recurrence_factor = 1 THEN 'Weekly on '
                                                                     WHEN ssc.freq_recurrence_factor      > 1 THEN 'Every ' + CAST( ssc.freq_recurrence_factor AS VARCHAR )
                                                                                                                            + ' weeks on '
                                                                     END
                                                                     + 
                                                                     LEFT
                                                                     ( CASE WHEN ssc.freq_interval &  1 =  1 THEN 'Sunday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  2 =  2 THEN 'Monday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  4 =  4 THEN 'Tuesday, '   ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  8 =  8 THEN 'Wednesday, ' ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 16 = 16 THEN 'Thursday, '  ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 32 = 32 THEN 'Friday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 64 = 64 THEN 'Saturday, '  ELSE '' END
                                                                     , 
                                                                     LEN
                                                                     ( CASE WHEN ssc.freq_interval &  1 =  1 THEN 'Sunday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  2 =  2 THEN 'Monday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  4 =  4 THEN 'Tuesday, '   ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  8 =  8 THEN 'Wednesday, ' ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 16 = 16 THEN 'Thursday, '  ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 32 = 32 THEN 'Friday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 64 = 64 THEN 'Saturday, '  ELSE '' END
                                                                     )  - 1  -- LEN() ignores trailing spaces
                                                                     )
                                           WHEN ssc.freq_type = 0x10 THEN  --monthly
                                                                     CASE WHEN ssc.freq_recurrence_factor = 1 THEN 'Monthly on the '
                                                                          WHEN ssc.freq_recurrence_factor > 1 THEN 'Every ' + CAST( ssc.freq_recurrence_factor AS VARCHAR) + ' months on the '
                                                                     END
                                                                     + CAST( ssc.freq_interval AS VARCHAR )
                                                                     + CASE WHEN ssc.freq_interval IN ( 1, 21, 31 ) THEN 'st'
                                                                            WHEN ssc.freq_interval IN ( 2, 22     ) THEN 'nd'
                                                                            WHEN ssc.freq_interval IN ( 3, 23     ) THEN 'rd' ELSE 'th'
                                                                       END
                                           WHEN ssc.freq_type = 0x20 THEN --monthly relative
                                                                     CASE WHEN ssc.freq_recurrence_factor = 1 THEN 'Monthly on the '
                                                                          WHEN ssc.freq_recurrence_factor > 1 THEN 'Every '
                                                                     +    CAST(ssc.freq_recurrence_factor AS VARCHAR ) + ' months on the '
                                                                     END
                                                                     +
                                                                     CASE ssc.freq_relative_interval WHEN 0x01 THEN 'first '
                                                                                                     WHEN 0x02 THEN 'second '
                                                                                                     WHEN 0x04 THEN 'third '
                                                                                                     WHEN 0x08 THEN 'fourth '
                                                                                                     WHEN 0x10 THEN 'last '
                                                                     END
                                                                     + 
                                                                     CASE ssc.freq_interval WHEN  1  THEN 'Sunday'
                                                                                                     WHEN  2 THEN 'Monday'
                                                                                                     WHEN  3 THEN 'Tuesday'
                                                                                                     WHEN  4 THEN 'Wednesday'
                                                                                                     WHEN  5 THEN 'Thursday'
                                                                                                     WHEN  6 THEN 'Friday'
                                                                                                     WHEN  7 THEN 'Saturday'
                                                                                                     WHEN  8 THEN 'day'
                                                                                                     WHEN  9 THEN 'week day'
                                                                                                     WHEN 10 THEN 'weekend day'
                                                                     END
                                           WHEN ssc.freq_type = 0x40 THEN 'Automatically starts when SQLServerAgent starts.'
                                           WHEN ssc.freq_type = 0x80 THEN 'Starts whenever the CPUs become idle'
                                           ELSE ''
                                           END
                                      + 
                                      CASE WHEN sjb.enabled = 0 THEN ''
                                           WHEN sjb.job_id IS NULL THEN ''
                                           WHEN ssc.freq_subday_type = 0x1 OR ssc.freq_type = 0x1 THEN ' at '
                                           + 
                                           Case  -- Depends on time being integer to drop right-side digits
                                           when(ssc.active_start_time % 1000000)/10000 = 0  then '12'
                                                                                               + ':'  
                                                                                               + Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100)))
                                                                                               + convert(char(2),(ssc.active_start_time % 10000)/100) 
                                                                                               + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000< 10 then convert(char(1),(ssc.active_start_time % 1000000)/10000) 
                                                                                               + ':'  
                                                                                               + Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                                                               + convert(char(2),(ssc.active_start_time % 10000)/100) 
                                                                                               + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000< 12 then convert(char(2),(ssc.active_start_time % 1000000)/10000) 
                                                                                               + ':'  
                                                                                               + Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                                                               + convert(char(2),(ssc.active_start_time % 10000)/100) 
                                                                                               + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000< 22 then convert(char(1),((ssc.active_start_time % 1000000)/10000) - 12) 
                                                                                               + ':'  
                                                                                               + Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                                                               + convert(char(2),(ssc.active_start_time % 10000)/100) 
                                                                                               + ' PM'
                                           else                                                  convert(char(2),((ssc.active_start_time % 1000000)/10000) - 12)
                                                                                               + ':'  
                                                                                               + Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                                                               + convert(char(2),(ssc.active_start_time % 10000)/100) 
                                                                                               + ' PM'
                                           end
                                      WHEN ssc.freq_subday_type IN ( 0x2, 0x4, 0x8 ) 
                                      THEN ' every '
                                           + CAST( ssc.freq_subday_interval AS VARCHAR )
                                           + 
                                           CASE freq_subday_type WHEN 0x2 THEN ' second'
                                                                 WHEN 0x4 THEN ' minute'
                                                                 WHEN 0x8 THEN ' hour'
                                      END
                                      + 
                                      CASE 
                                      WHEN ssc.freq_subday_interval > 1 THEN 's'
                                      ELSE                                    '' -- Added default 3/21/08; John Arnott
                                      END
                                      ELSE ''
                                      END
                                      + 
                                      CASE
                                      WHEN sjb.enabled = 0                           THEN ''
                                      WHEN sjb.job_id IS NULL                        THEN ''
                                      WHEN ssc.freq_subday_type IN ( 0x2, 0x4, 0x8 ) THEN ' between '
                                           + Case  -- Depends on time being integer to drop right-side digits
                                           when(ssc.active_start_time % 1000000)/10000 = 0 then 
                                                      '12'
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100)))
                                                    + rtrim(convert(char(2),(ssc.active_start_time % 10000)/100))
                                                    + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000< 10 then
                                                    convert(char(1),(ssc.active_start_time % 1000000)/10000) 
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_start_time % 10000)/100))
                                                    + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000 < 12 then
                                                    convert(char(2),(ssc.active_start_time % 1000000)/10000) 
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_start_time % 10000)/100)) 
                                                    + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000< 22 then
                                                    convert(char(1),((ssc.active_start_time % 1000000)/10000) - 12) 
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_start_time % 10000)/100)) 
                                                    + ' PM'
                                           else        convert(char(2),((ssc.active_start_time % 1000000)/10000) - 12)
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_start_time % 10000)/100))
                                                    + ' PM'
                                           end
                            + ' and '
                            + Case  -- Depends on time being integer to drop right-side digits
                                    when(ssc.active_end_time % 1000000)/10000 = 0 then 
                                                    '12'
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_end_time % 10000)/100)))
                                                    + rtrim(convert(char(2),(ssc.active_end_time % 10000)/100))
                                                    + ' AM'
                                    when (ssc.active_end_time % 1000000)/10000< 10 then
                                                    convert(char(1),(ssc.active_end_time % 1000000)/10000) 
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_end_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_end_time % 10000)/100))
                                                    + ' AM'
                                    when (ssc.active_end_time % 1000000)/10000 < 12 then
                                                    convert(char(2),(ssc.active_end_time % 1000000)/10000) 
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_end_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_end_time % 10000)/100))
                                                    + ' AM'
                                    when (ssc.active_end_time % 1000000)/10000< 22 then
                                                    convert(char(1),((ssc.active_end_time % 1000000)/10000) - 12)
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_end_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_end_time % 10000)/100)) 
                                                    + ' PM'
                                    else        convert(char(2),((ssc.active_end_time % 1000000)/10000) - 12)
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_end_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_end_time % 10000)/100)) 
                                                    + ' PM'
                            end
           ELSE ''
       END
       )
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  , [Sort] = CASE WHEN sjb.name = '000_company_ARC_Data_Collection' THEN 1
                                           WHEN sjb.name = '000_company_PMP_PID1' THEN 2
                                           ELSE 0 END
FROM       msdb.dbo.SYSJOBS             sjb (NOLOCK) 
LEFT  JOIN msdb.dbo.SYSJOBSCHEDULES     sjs (NOLOCK) ON sjb.job_id = sjs.job_id
LEFT  JOIN msdb.dbo.SYSSCHEDULES        ssc (NOLOCK) ON sjs.schedule_id = ssc.schedule_id
WHERE      sjb.name in ('000_company_ARC_Data_Collection', '000_company_PMP_PID1') 
-----------------------------------------------------------------------------------------------------------------------------
--OUTPUT
-----------------------------------------------------------------------------------------------------------------------------
SELECT [CheckListNo],Checklist, [Status], Remarks, ServerName, Inserted FROM @vAuditCheckList WHERE AuditRowNo = @RowNo order by Sort
"@



$result = exec-SqlCommand -Server $SERVER_INSTANCE -Database Master #-Username $DB_USERNAME -Password $DB_USER_PASSWORD
return $result #| Format-table -Property CheckListNo,Checklist,Status,Remarks,ServerName,Inserted | Out-String -Width 4096

} -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck -ProxyAccessType NoProxyServer) -EA Stop
#write-host "SQL port check"
$NPRegValueDesc =$Auditdetails[0]
$SMRegValueDesc =$Auditdetails[1]
$TCPRegValueDesc=$Auditdetails[2]
$SQLversion = $Auditdetails[3]

$Auditdetails | Format-table -Property CheckListNo,Checklist,Status,Remarks,ServerName,Inserted | Out-String -Width 4096
write-host "         26 Ensure Unnecessary SQL Server Protocols are set to Disabled : Named Pipes        					   $NPRegValueDesc "
write-host "         27 Ensure Unnecessary SQL Server Protocols are set to Disabled : Shared Memory      					   $SMRegValueDesc "
write-host "         28 Ensure Unnecessary SQL Server Protocols are set to Disabled : TCP/IP             				           $TCPRegValueDesc "
write-host " Sqlversion is $SQLversion"


function InsertNewHost($Auditdetails){
       try 
    {
if ($Auditdetails.Checklist[23] -cmatch "000_company_PMP_PID1")
{$insertSQLCMD = $insertSQL -f $SERVER_NAME, $SERVER_INSTANCE, $Auditdetails.status[0], $Auditdetails.status[1], $Auditdetails.status[2], $Auditdetails.status[3], $Auditdetails.status[4], $Auditdetails.status[5], $NPRegValueDesc, $SMRegValueDesc, $TCPRegValueDesc, $Auditdetails.status[6], $Auditdetails.status[7], $Auditdetails.status[8], $Auditdetails.status[9],	$Auditdetails.status[10], $Auditdetails.status[11], $Auditdetails.status[12], $Auditdetails.status[13],	$Auditdetails.status[14], $Auditdetails.status[15], $Auditdetails.status[16], $Auditdetails.status[17],	$Auditdetails.status[18], $Auditdetails.status[19], $Auditdetails.status[20], $Auditdetails.status[21], $Auditdetails.status[22], $Auditdetails.status[24], $Auditdetails.status[23], $SQLversion
    #Write-Host $insertSQLCMD
    }
    else
    {$insertSQLCMD = $insertSQL -f $SERVER_NAME, $SERVER_INSTANCE, $Auditdetails.status[0], $Auditdetails.status[1], $Auditdetails.status[2], $Auditdetails.status[3], $Auditdetails.status[4], $Auditdetails.status[5], $NPRegValueDesc, $SMRegValueDesc, $TCPRegValueDesc, $Auditdetails.status[6], $Auditdetails.status[7], $Auditdetails.status[8], $Auditdetails.status[9],	$Auditdetails.status[10], $Auditdetails.status[11], $Auditdetails.status[12], $Auditdetails.status[13],	$Auditdetails.status[14], $Auditdetails.status[15], $Auditdetails.status[16], $Auditdetails.status[17],	$Auditdetails.status[18], $Auditdetails.status[19], $Auditdetails.status[20], $Auditdetails.status[21], $Auditdetails.status[22], $Auditdetails.status[23], $Auditdetails.status[24], $SQLversion
    #Write-Host $insertSQLCMD
    }
    Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -Username $DB_USERNAME -Password $DB_USER_PASSWORD -ErrorAction Stop
    Write-Host "Inserted new entry in SQL Drift DB: $($SERVER_INSTANCE)"
    } 
    catch 
    {
        'Error: {0}' -f $_.Exception.Message
    }
}

function Build-hostReport(){
    InsertNewHost -Auditdetails $Auditdetails     
    }         

Build-hostReport

}
catch
{
$Executed_date = get-date
$worksheetno = '$INPUT{WORKSHEETNO}'

$insertSQL = @'
        EXEC [TEST].[dbo].[sp_SQL_Drift_Insert]
            @server_Name = N'{0}',
            @server_Instance = N'{1}',
            @install_D = N'{2}',
            @adhoc_DistributedQueries = N'{3}',
            @cross_DB_Ownership = N'{4}',
            @mail_XPs = N'{5}',
            @old_Automation_Procedure = N'{6}',
            @trustworthy_Database = N'{7}',
            @serverProtocol_NamedPipes = N'{8}',
            @serverProtocol_TCPIP = N'{9}',
            @serverProtocol_SharedMemory = N'{10}',
            @xp_Cmdshell = N'{11}',
            @sa_Account= N'{12}',
            @connect_Permission= N'{13}',
            @orphaned_Users= N'{14}',
            @default_Trace= N'{15}',
            @server_Audit= N'{16}',
            @clr_Assembly= N'{17}',
            @symmetric_Key_Encryption= N'{18}',
            @asymmetric_KeySize= N'{19}',
            @error_Log= N'{20}',
            @agentHistory_HistoryLog= N'{21}',
            @agentHistory_Historyrows= N'{22}',
            @extended_Stored_Procedures= N'{23}',
            @authenticated_Logins= N'{24}',
            @check_Expiration= N'{25}',
            @check_Policy= N'{26}',
            @login_Auditing= N'{27}',
            @company_ARC_Data_Collection= N'{28}',
            @company_PMP_PID1= N'{29}',
            @sql_Version= N'{30}'
'@

write-host "server instance is $SERVER_INSTANCE"
write-host "server id is $SERVER_ID"
$Auditdetails =Invoke-Command -ComputerName $source -Credential $credential -Scriptblock {
$SERVER_INSTANCE  = '$INPUT{DESTINATION_SERVER}'
[string] $database    = "master"
[string] $sqlCommand  = $("select PhysicalName = SERVERPROPERTY('ComputerNamePhysicalNetBIOS'), SQLName = SERVERPROPERTY('MachineName'), SQLID = ISNULL(SERVERPROPERTY('InstanceName'), 'MSSQLSERVER'), SQLInstanceName = SERVERPROPERTY('ServerName'), SQLVersion = SUBSTRING(@@VERSION,0,CHARINDEX(CHAR(9),@@VERSION))")


$connectionString     = "Data Source=$SERVER_INSTANCE; " + "Integrated Security=SSPI; " + "Initial Catalog=$database"
$connection           = new-object system.data.SqlClient.SQLConnection($connectionString)
$command              = new-object system.data.sqlclient.sqlcommand($sqlCommand,$connection)
$connection.Open()

$adapter              = New-Object System.Data.sqlclient.sqlDataAdapter $command
$dataset              = New-Object System.Data.DataSet

[void] $adapter.Fill($dataSet)

$table                = new-object system.data.datatable
$table                = $dataset.Tables[0] 

$PhysicalName  = $dataset.Tables[0].Rows[0].PhysicalName
$SQLName       = $dataset.Tables[0].Rows[0].SQLName
$SQLId         = $dataset.Tables[0].Rows[0].SQLID
$SQLInstance   = $dataset.Tables[0].Rows[0].SQLInstanceName
$SQLVersion    = $dataset.Tables[0].Rows[0].SQLVersion

#write-host "PhysicalName $PhysicalName  "
#write-host "SQLName      $SQLName  "
#write-host "SQLId        $SQLId  "
#write-host "SQLInstance  $SQLInstance  "


$connection.Close()

$NPdesc    = "Ensure Unnecessary SQL Server Protocols are set to Disabled : Named Pipes  "
$TCPdesc   = "Ensure Unnecessary SQL Server Protocols are set to Disabled : TCP/IP       "
$SMdesc    = "Ensure Unnecessary SQL Server Protocols are set to Disabled : Shared Memory"

$reg       = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $PhysicalName)
$regkey    = $reg.OpenSubkey("SOFTWARE\\Microsoft\\Microsoft SQL Server\\Instance Names\\SQL")
$RegFolder = $regkey.GetValue("$SQLId")

$RegProperty = "Enabled"

$NPPath      = "SOFTWARE\\Microsoft\\Microsoft SQL Server\\$RegFolder\\MSSQLServer\\SuperSocketNetLib\\NP"
$NPregkey    = $reg.OpenSubkey("$NPPath")
$NPRegValue  = $NPregkey.GetValue("$RegProperty")

$SMPath      = "SOFTWARE\\Microsoft\\Microsoft SQL Server\\$RegFolder\\MSSQLServer\\SuperSocketNetLib\\SM"
$SMregkey    = $reg.OpenSubkey("$SMPath")
$SMRegValue  = $SMregkey.GetValue("$RegProperty")

$TCPPath     = "SOFTWARE\\Microsoft\\Microsoft SQL Server\\$RegFolder\\MSSQLServer\\SuperSocketNetLib\\TCP"
$TCPregkey    = $reg.OpenSubkey("$TCPPath")
$TCPRegValue  = $TCPregkey.GetValue("$RegProperty")

if ($NPRegValue  -eq 1)  {$NPRegValueDesc  = "1"} else {$NPRegValueDesc  = "0"}
if ($SMRegValue  -eq 1)  {$SMRegValueDesc  = "1"} else {$SMRegValueDesc  = "0"}
if ($TCPRegValue -eq 1)  {$TCPRegValueDesc = "1"} else {$TCPRegValueDesc = "0"}

#write-host "Server: $PhysicalName (Instance: $SQLInstance )"
$NPRegValueDesc
$SMRegValueDesc
$TCPRegValueDesc
$SQLVersion
#write-host "$NPdesc  - $NPRegValue (Status - $NPRegValueDesc)   "
#write-host "$SMdesc  - $SMRegValue (Status - $SMRegValueDesc)   "
#write-host "$TCPdesc  - $TCPRegValue (Status - $TCPRegValueDesc)"
#write-host ""
#write-host ""



function exec-sqlCommand() 
{    
	[cmdletbinding(DefaultParameterSetName="integrated")]Param (
        [Parameter(Mandatory=$true                                   )][Alias("Serverinstance")][string]$Server,
        [Parameter(Mandatory=$true                                   )][string]$Database,
        [Parameter(Mandatory=$true, ParameterSetName="not_integrated")][string]$Username,
        [Parameter(Mandatory=$true, ParameterSetName="not_integrated")][string]$Password,
        [Parameter(Mandatory=$false,ParameterSetName="integrated"    )][switch]$UseWindowsAuthentication = $true,
      ##[Parameter(Mandatory=$true                                   )][string]$Query,
        [Parameter(Mandatory=$false                                  )][int]$CommandTimeout=0

    )

    $connstring = "Server=$Server; Database=$Database; "

    If ($PSCmdlet.ParameterSetName -eq "not_integrated") 
    {   $connstring += "User ID=$username; Password=$password;" 
    }
    ElseIf ($PSCmdlet.ParameterSetName -eq "integrated") 
    { 
        $connstring += "Trusted_Connection=Yes; Integrated Security=SSPI;" 
    }
    
    #connect to database
    $connection = New-Object System.Data.SqlClient.SqlConnection($connstring)
    $connection.Open()
    
    #build query object
    $command                = $connection.CreateCommand()
    $command.CommandText    = $Query
    $command.CommandTimeout = $CommandTimeout
    
    #run query
    $adapter = New-Object System.Data.SqlClient.SqlDataAdapter $command
    $dataset = New-Object System.Data.DataSet
    $adapter.Fill($dataset) | out-null
    
    #return the first collection of results or an empty array
    If  ($dataset.Tables[0] -ne $null) 
    {
        $table = $dataset.Tables[0]
    }
    ElseIf ($table.Rows.Count -eq 0) 
    { 
        $table = New-Object System.Collections.ArrayList 
    }
    
    $connection.Close()
    #$result += $table
    #$result1 = $result 
    #$result1 | ConvertTo-Json
    #$result | Format-table -Property CheckListNo,Checklist,Status,Remarks,ServerName,Inserted | Out-String -Width 4096 | convertto-json
    return $table
    }


$Query = @"
USE master
SET NOCOUNT ON

-----------------------------------------------------------------------------------------------------------------------------
--Cleanup - deletes data if exists for same day (i.e. eliminates duplicate data when script ran more than once on same day)
-----------------------------------------------------------------------------------------------------------------------------
DECLARE @RowNo           BIGINT
DECLARE @DateToDelData   DATETIME
SELECT  @DateToDelData = CONVERT(VARCHAR(25), GETDATE(), 111)


DECLARE @vAuditCheckList       TABLE
        ( [AuditRowNo]          bigint        NOT NULL
        , [CheckListNo]         int           NOT NULL IDENTITY(1,1)
        , [Checklist]           varchar (120) NOT NULL
        , [Status]              varchar ( 20) NULL
        , [Remarks]             varchar (MAX) NULL
        , [ServerName]          varchar ( 30) NOT NULL
        , [Inserted]            datetime      NOT NULL
        , [UserName]            varchar ( 30) NOT NULL
		,[Sort]					int               NULL
        )
DECLARE @vAuditCheck_SqlLogins  TABLE
        ( AuditRowNo            bigint        NOT NULL
        , ServerName            varchar(30)   NOT NULL
        , LoginName             varchar(50)   NOT NULL
        , IsDisabled            bit           NULL
        , IsMustChange          varchar(15)   NULL
        , is_policy_checked     varchar(15)   NULL
        , is_expiration_checked varchar(15)   NULL
        , IsSysAdmin            bit           NULL
        , Inserted              datetime      NOT NULL
        )
DECLARE @vAuditCheck_xProcs     TABLE 
        ( AuditRowNo            bigint        NOT NULL
        , ServerName            varchar(30)   NOT NULL
        , RoleName              varchar(15)   NOT NULL
        , RoleDesc              varchar(15)   NULL
        , PermissionName        varchar(18)   NULL
        , StateDesc             varchar(18)   NULL
        , Class_Desc            varchar(20)   NULL
        , ObjectName            varchar(38)   NULL
        , Inserted              datetime      NOT NULL
        )



SELECT  @RowNo         = MAX(AuditRowNo) FROM @vAuditCheckList
SELECT  @RowNo         = ISNULL(@RowNo, 0) + 1


DECLARE @DBList varchar(MAX)

-----------------------------------------------------------------------------------------------------------------------------
--Check for install files under the D:\SQL installation directory
-----------------------------------------------------------------------------------------------------------------------------
DECLARE @SQLOutput   VARCHAR(255)
DECLARE @Status      VARCHAR(15)
EXEC    MASTER.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'
                                     , N'SOFTWARE\Microsoft\MSSQLServer\Setup'
                                     , N'SQLBinRoot'
                                     , @SQLOutput OUTPUT
                                     
SET      @Status     = CASE WHEN LEFT(@SQLOutput, 1) = 'D' then '1' ELSE '0' END

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
VALUES    ( @RowNo
          , 'Check for install files under the D: drive SQL installation directory'
          , @Status
          , @SQLOutput
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                                                                  ------
          )
          
-----------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Ad Hoc Distributed Queries' Server Configuration Option is set to '0'
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Ad Hoc Distributed Queries Server Configuration Option is set to 0'
          , CASE Value_In_Use WHEN 1 THEN '0' Else '1' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                                                                  -------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'Ad Hoc Distributed Queries'

-----------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Cross DB Ownership Chaining' Server Configuration Option is set to '0'
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Cross DB Ownership Chaining Server Configuration Option is set to 0'
          , CASE Value_In_Use WHEN 1 THEN '0' Else '1' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                      -------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'cross db ownership chaining'

-----------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Database Mail XPs' Server Configuration Option is set to '0'
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Database Mail XPs Server Configuration Option is set to 0'
          , CASE Value_In_Use WHEN 1 THEN '0' Else '1' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                          ----------------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'Database Mail XPs'

-----------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Ole Automation Procedures' Server Configuration Option is set to '0'
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Ole Automation Procedures Server Configuration Option is set to 0'
          , CASE Value_In_Use WHEN 1 THEN '0' Else '1' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                              -------------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'Ole Automation Procedures'

----------------------------------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Trustworthy' Database Property is set to 'Off'
----------------------------------------------------------------------------------------------------------------------------------------------------
DECLARE     @DBTrustWorthy  TABLE ( DBName VARCHAR(50) )
INSERT INTO @DBTrustWorthy
SELECT     CONVERT(NVARCHAR(50), Name) FROM sys.databases (nolock) WHERE database_id <> 4 and is_trustworthy_on <>0    

SET @DBList =''
SELECT @DBList = @DBList + CONVERT(varchar, DBName) + ';' FROM @DBTrustWorthy    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Trustworthy Database Property is set to Off'
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '1' Else '0' END
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '' Else 'Trustworthy Database Property is On: ' + LEFT(@DBList, LEN(@DBList) - 1) END
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                          ------------------------------
-----------------------------------------------------------------------------------------------------------------------------
--Verify xp_cmdshell is disabled (default)
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify xp_cmdshell is disabled'
          , CASE Value_In_Use WHEN 1 THEN '0' Else '1' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'xp_cmdshell'

-----------------------------------------------------------------------------------------------------------------------------
--Verify the 'sa' account is disabled
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify the SA account is disabled'
          , CASE is_disabled WHEN 1 THEN '1' Else '0' END
          , CONVERT(VARCHAR(15), is_disabled)
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------
FROM   sys.SQL_LOGINS           (NOLOCK) 
WHERE  [Name] = N'sa' or [Name] = N'sadba'

-----------------------------------------------------------------------------------------------------------------------------
--Ensure CONNECT permissions on the 'guest user' is Revoked within all SQL Server databases excluding the master, msdb and tempdb
-----------------------------------------------------------------------------------------------------------------------------
DECLARE @GuestDBs  TABLE(SNo int identity(1, 1), DatabaseName VARCHAR(50), UserName varchar(15), IsEnabled varchar(5))
DECLARE @GuestUsers VARCHAR(MAX)
DECLARE @SQL       VARCHAR(MAX);

SET @SQL = '
            IF exists (SELECT 1 FROM sys.databases WHERE state=0 and name = ''?'' ) and (db_id(''?'') > 4)
            BEGIN
                         if exists (select 1 from [?].sys.sysusers WHERE  name = ''guest'' and hasdbaccess = 1)
                           begin
                SELECT [DatabaseName] = ''?'', name,  hasdbaccess = CASE hasdbaccess WHEN 0 THEN ''0'' WHEN 1 THEN ''1'' END FROM [?].sys.sysusers SL WHERE SL.NAME IN (''GUEST'') 
                           end
            END';
INSERT   INTO @GuestDBs (DatabaseName, UserName, IsEnabled) EXEC sp_MSforeachdb @SQL;

SET    @GuestUsers = ''
SELECT @GuestUsers = case when SNo = 1 
                         then 'Guest user connect permission exist for db(s) ' + @GuestUsers  + DatabaseName 
                         else @GuestUsers  + ', ' + DatabaseName 
                    end
FROM   @GuestDBs 
WHERE  UserName = 'Guest'


INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure CONNECT permissions on the guest user is Revoked within all SQL Server DBS excluding master msdb model & tempdb'
          , CASE LTRIM(RTRIM(@GuestUsers)) WHEN '' THEN '1' Else '0'        END
          , CASE LTRIM(RTRIM(@GuestUsers)) WHEN '' THEN ''    Else @GuestUsers END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------

-----------------------------------------------------------------------------------------------------------------------------
--Ensure 'Orphaned Users' are Dropped From SQL Server Databases
-----------------------------------------------------------------------------------------------------------------------------
--DECLARE @DBList varchar(150)
DECLARE @OrphanUser TABLE( DatabaseName VARCHAR(50), OrphName VARCHAR(50)
                           );
--DECLARE @SQL VARCHAR(MAX);
IF( SELECT SUBSTRING(CONVERT( VARCHAR(25), SERVERPROPERTY('ProductVersion')), 1, CHARINDEX('.', CONVERT(VARCHAR(25), SERVERPROPERTY('ProductVersion'))) - 1)) < 12
    BEGIN
        SET @SQL = '
            IF exists (SELECT 1 FROM sys.databases WHERE state=0 and database_id not in (1,2 ,3 ,4))
            BEGIN
                SELECT ''?'' [DatabaseName], A.Name
                FROM [?].sys.database_principals a
                LEFT OUTER JOIN sys.server_principals  b on a.sid=b.sid
                WHERE a.type = ''S'' 
                AND a.name NOT IN (''dbo'',''sys'',''INFORMATION_SCHEMA'',''guest'') AND a.name NOT LIKE ''%##%'' AND DB_ID(''?'') > 4
                AND b.sid IS NULL
            END';
    END;
ELSE
    BEGIN
        SET @SQL = '
        IF exists (SELECT 1 FROM sys.databases WHERE state=0 and database_id not in (1,2 ,3 ,4))
        BEGIN
                SELECT ''?'' [DatabaseName], A.Name
                FROM [?].sys.database_principals a
                LEFT OUTER JOIN sys.server_principals  b on a.sid=b.sid
                WHERE a.type = ''S'' 
                AND a.name NOT IN (''dbo'',''sys'',''INFORMATION_SCHEMA'',''guest'') AND a.name NOT LIKE ''%##%'' AND DB_ID(''?'') > 4
                AND b.sid IS NULL AND a.authentication_type=1
        END';
        
    END;
INSERT INTO @OrphanUser
EXEC sp_MSforeachdb   @SQL;

SET @DBList =''
SELECT @DBList = @DBList + CONVERT(varchar, DatabaseName) + '-' + CONVERT(varchar, OrphName) + ';' FROM @OrphanUser    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Orphaned Users are Dropped From SQL Server Databases'
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '1' Else '0' END
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '' Else 'Orphaned users: ' + LEFT(@DBList, LEN(@DBList) - 1) END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------

-----------------------------------------------------------------------------------------------------------------------------
--Verify that 'Default Trace Enabled' server configuration option is set to €œ1€
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify Default Trace Enabled server configuration option is set to 1'
          , CASE Value_In_Use WHEN 1 THEN '1' Else '0' END
          , CONVERT(VARCHAR(15), Value_In_Use)
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------
FROM   sys.CONFIGURATIONS (NOLOCK)
WHERE  [NAME] = N'default trace enabled'

----------------------------------------------------------------------------------------------------------------------------------------------------
-- Ensure 'Login Auditing' is set to Both 'failed' and 'successful logins'.  Failed applicable only if 'SQL Server Audit' function is unavailable.
----------------------------------------------------------------------------------------------------------------------------------------------------
DECLARE @tmpLgAudits TABLE ( ServerName  VARCHAR(45) NOT NULL DEFAULT (@@servername)                                                    
                         , Description VARCHAR(25)                                                    
                         , Value       VARCHAR(07)                                                    
                         , AuditLevelDescription   AS  CASE Value WHEN 0 THEN 'None'                                                    
                                                                   WHEN 1 THEN 'Successful logins only'                                                    
                                                                   WHEN 2 THEN 'Failed logins only'                                                    
                                                                   WHEN 3 THEN 'Both failed and successful logins'                                                    
                                                       END                                                    
                         )                                                    
INSERT INTO @tmpLgAudits   ([Description], Value)                                                      
EXEC   master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'                                                    
                                     , N'Software\Microsoft\MSSQLServer\MSSQLServer'                                                    
                                     , N'AuditLevel'                                                    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure SQL Server Audit is set to capture both failed and successful logins'
          , CASE WHEN Value = 3 THEN '1' ELSE '0' END 
          , CASE Value WHEN 1 THEN CONVERT(VARCHAR(15), Value) + ' - Successful logins only' WHEN 2 THEN  CONVERT(VARCHAR(15), Value) + ' - Failed logins only' WHEN 3 THEN CONVERT(VARCHAR(15), Value) + ' - Both failed and successful logins' Else 'None' END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------
FROM   @tmpLgAudits
----------------------------------------------------------------------------------------------------------------------------------------------------
-- 6.20    Ensure 'CLR Assembly Permission Set' is set to 'SAFE_ACCESS' for All CLR Assemblies
----------------------------------------------------------------------------------------------------------------------------------------------------
DECLARE  @CLRassemblies  TABLE
(
Name VARCHAR(100),
Permission_Set_Desc VARCHAR(50)
)

INSERT INTO @CLRassemblies
EXEC sp_msforeachdb '
USE [?]
SELECT       ASMBLY.NAME, ASMBLY.PERMISSION_SET_DESC
FROM        SYS.ASSEMBLY_MODULES AM
INNER JOIN  SYS.ASSEMBLIES ASMBLY
        ON  ASMBLY.ASSEMBLY_ID = AM.ASSEMBLY_ID
WHERE ASMBLY.NAME NOT LIKE ''MICROSOFT%'' AND ASMBLY.PERMISSION_SET_DESC NOT IN (''SAFE_ACCESS'')';


SET @DBList =''
SELECT @DBList = @DBList + CONVERT(varchar, Name) + '-' + CONVERT(varchar, Permission_Set_Desc) + ';' FROM @CLRassemblies    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure CLR Assembly Permission Set is set to SAFE_ACCESS for All CLR Assemblies'
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '1' Else '0' END
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '' Else 'CLR Assemblies: ' + LEFT(@DBList, LEN(@DBList) - 1) END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------

          
----------------------------------------------------------------------------------------------------------------------------------------------------
-- 7.10  Ensure 'Symmetric Key encryption algorithm' is set to 'AES_128' or higher in non-system databases
----------------------------------------------------------------------------------------------------------------------------------------------------
DECLARE @SymmetricKys TABLE
([Name] VARCHAR(75),
[Algorithm_Desc] VARCHAR(20)
);
DECLARE @SQLSymKy VARCHAR(400);
SET @SQLSymKy = '
USE [?]
            IF DB_ID() not in  (1,2,3,4)
            BEGIN
                SELECT  Name,Algorithm_Desc FROM sys.symmetric_keys where Algorithm_Desc not in (''AES_128'',''AES_192'',''AES_256'')
            END';
INSERT INTO @SymmetricKys
EXEC sp_msforeachdb @SQLSymKy

SET @DBList =''
SELECT @DBList = @DBList + CONVERT(varchar, Name) + '-' + CONVERT(varchar, Algorithm_Desc) + ';' FROM @SymmetricKys    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Symmetric Key encryption algorithm is set to AES_128 or higher in non-system databases'
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '1' Else '0' END
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN 'AES_128 or Higher in non-system databases' Else 'Symmetric Key Encryption: ' + LEFT(@DBList, LEN(@DBList) - 1) END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------


             
----------------------------------------------------------------------------------------------------------------------------------------------------
-- 7.10  Ensure Asymmetric Key Size is set to 'greater than or equal to 2048' in non-system databases
----------------------------------------------------------------------------------------------------------------------------------------------------
IF EXISTS(SELECT * FROM @SymmetricKys)
    DELETE FROM @SymmetricKys
SET @SQLSymKy = '
USE [?]
            IF DB_ID() not in  (1,2,3,4)
            BEGIN
                SELECT Name,Algorithm_Desc FROM sys.asymmetric_keys where Algorithm_Desc not in (''RSA_2048'')
            END';
INSERT INTO @SymmetricKys
EXEC sp_msforeachdb @SQLSymKy

SET @DBList =''
SELECT @DBList = @DBList + CONVERT(varchar, Name) + '-' + CONVERT(varchar, Algorithm_Desc) + ';' FROM @SymmetricKys    

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Ensure Asymmetric Key Size is set to greater than or equal to 2048 in non-system databases'
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN '1' Else '0' END
          , CASE LTRIM(RTRIM(@DBList)) WHEN '' THEN 'RSA_2048 or Higher in non-system databases' Else 'Asymmetric Key Encryption: ' + LEFT(@DBList, LEN(@DBList) - 1) END
          , @@SERVERNAME, GETDATE(), SUSER_SNAME()
		  ,0                                                               -----------------------------------


-----------------------------------------------------------------------------------------------------------------------------
--Verify the number of default SQL error log files is >= 12
-----------------------------------------------------------------------------------------------------------------------------
DECLARE @tmpErrorLogs TABLE (Value VARCHAR(25), Data Varchar(80))

INSERT INTO @tmpErrorLogs            (Value, Data)  
EXEC MASTER.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'
                                  , N'Software\Microsoft\MSSQLServer\MSSQLServer'
                                  , N'NumErrorLogs'

IF EXISTS (SELECT TOP 1 1 FROM @tmpErrorLogs)
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify number of default SQL error log files is >= 12'
              , CASE WHEN Data >= 12 THEN '1' ELSE '0' END
              , Data
              , @@SERVERNAME
              , GETDATE()
              , SUSER_NAME()
			  ,0                                                               -----------------------------------
    FROM        @tmpErrorLogs
END
ELSE
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify number of default SQL error log files is >= 12'
              , '0'
              , ''
              , @@SERVERNAME, GETDATE(), SUSER_NAME()
			  ,0                                                               -----------------------------------
END
-----------------------------------------------------------------------------------------------------------------------------
--Verify the SQL Agent History (Maximum job history log size (rows) = 50000), Maximum job history rows per job = 5000
-----------------------------------------------------------------------------------------------------------------------------
DECLARE @tmpJobHistRows TABLE (Value VARCHAR(50), Data Varchar(70))


INSERT INTO @tmpJobHistRows          (Value, Data)  
exec master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'
                                  , N'Software\Microsoft\MSSQLServer\SQLServerAgent'
                                  , N'JobHistoryMaxRows'

IF EXISTS (SELECT TOP 1 1 FROM @tmpJobHistRows)
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify SQL Agent History, Max job history log size rows=50000'
              , CASE WHEN Data >= 50000 THEN '1' ELSE '0' END
              , Data
              , @@SERVERNAME
              , GETDATE()
              , SUSER_NAME()
			  ,0                                                               -----------------------------------
    FROM        @tmpJobHistRows
END
ELSE
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify SQL Agent History, Max job history log size rows=50000'
              , 'No'
              , ''
              , @@SERVERNAME, GETDATE(), SUSER_NAME()
			  ,0                                                               -----------------------------------
END

DECLARE @tmpJobHistRowsPerJob TABLE (Value VARCHAR(50), Data Varchar(70))

INSERT INTO @tmpJobHistRowsPerJob    (Value, Data)  
exec master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'
                                  , N'Software\Microsoft\MSSQLServer\SQLServerAgent'
                                  , N'JobHistoryMaxRowsPerJob'

IF EXISTS (SELECT TOP 1 1 FROM @tmpJobHistRowsPerJob)
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify SQL Agent History, Max job history rows per job=5000'
              , CASE WHEN Data >= 5000 THEN '1' ELSE '0' END
              , Data
              , @@SERVERNAME, GETDATE(), SUSER_SNAME()
			  ,0                                                               -----------------------------------
    FROM        @tmpJobHistRowsPerJob
END
ELSE
BEGIN
    INSERT INTO @vAuditCheckList  
              ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
    SELECT      @RowNo
              , 'Verify SQL Agent History, Max job history rows per job=5000'
              , 'No'
              , ''
              , @@SERVERNAME, GETDATE(), SUSER_SNAME()
			  ,0                                                               -----------------------------------
END

-----------------------------------------------------------------------------------------------------------------------------
--Verify Revoke execute on extended stored procedures to ?PUBLIC?
-----------------------------------------------------------------------------------------------------------------------------
DECLARE      @xProcsCount   INT
DECLARE      @xProcsStatus  VARCHAR(10)
DECLARE      @xProcsDesc    VARCHAR(100)

INSERT INTO  @vAuditCheck_xProcs
           ( AuditRowNo
           , RoleName       
           , RoleDesc       
           , PermissionName 
           , StateDesc      
           , Class_Desc     
           , ObjectName   
		   , ServerName
		   , Inserted
           )
SELECT     @RowNo
         , RoleName               = CONVERT(VARCHAR(15), sdb.name    )
         , RoleDesc               = CONVERT(VARCHAR(15), sdb.type_desc)
         , PermissionName         = CONVERT(VARCHAR(18), spr.permission_name)
         , StateDesc              = CONVERT(VARCHAR(10), spr.state_desc)
         , Class_Desc             = CONVERT(VARCHAR(20), spr.class_desc)
         , ObjectName             = CONVERT(VARCHAR(38), object_name(spr.major_id))
		 , @@SERVERNAME
		 , GETDATE()
from       sys.database_principals  sdb (NOLOCK) 
left  join sys.database_permissions spr (NOLOCK) ON spr.grantee_principal_id = sdb.principal_id
inner JOIN sys.all_objects          sao (NOLOCK) ON spr.major_id = sao.object_id
WHERE      sdb.name            =  'public' 
       and sao.[type]          =  'X' 
       and sao.is_ms_shipped   <> 1
       and spr.permission_name =  'EXECUTE'
ORDER BY   sao.Name

SELECT     @xProcsCount  = COUNT(*) FROM @vAuditCheck_xProcs
IF         @xProcsCount  > 0
BEGIN
      SET @xProcsStatus = '0'
      SET @xProcsDesc   = CONVERT(VARCHAR(15), @xProcsCount) + ' extended proc(s) has Execute permission to PUBLIC'

END
ELSE
BEGIN
      SET @xProcsStatus = '1'
      SET @xProcsDesc   = ''
END

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Revoke execute on extended stored procedures to PUBLIC'
          , @xProcsStatus
          , @xProcsDesc
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------


-------------------------------------------------------------------------------------------------------------------------------
--Verify the 'MUST_CHANGE'      option is set to ?ON? for all SQL Authenticated Logins
--Verify the 'CHECK_EXPIRATION' option is set to ?ON? for all SQL Authenticated Logins within the SYSADMIN Role
--Verify the 'CHECK_POLICY'     option is set to ?ON? for all SQL Authenticated Logins
-------------------------------------------------------------------------------------------------------------------------------
--Verify the 'MUST_CHANGE'      option is set to ?ON? 
DECLARE    @MustChangeCount  VARCHAR( 20)
DECLARE    @MustChangeStatus VARCHAR( 10)
DECLARE    @MustChangeDesc   VARCHAR(100)

INSERT     INTO @vAuditCheck_SqlLogins
              ( AuditRowNo, LoginName, IsDisabled, IsMustChange, is_policy_checked, is_expiration_checked, IsSysAdmin, ServerName, Inserted)
SELECT          @RowNo
              , slq.Name
              , slq.Is_Disabled
              , CONVERT(VARCHAR(15), LOGINPROPERTY(slq.Name, 'IsMustChange') )
              , CONVERT(VARCHAR(15), slq.is_policy_checked                   )
              , CONVERT(VARCHAR(15), slq.is_expiration_checked               )
              , CONVERT(VARCHAR(15), IS_SRVROLEMEMBER('sysadmin', Name     ) )
              , @@SERVERNAME
              , GETDATE()
FROM            sys.SQL_LOGINS                 slq (NOLOCK) 

SELECT          @MustChangeCount  = COUNT(*) FROM @vAuditCheck_SqlLogins WHERE IsMustChange = 0 AND IsDisabled = 0
IF         @MustChangeCount  > 0
BEGIN
      SET @MustChangeStatus = '0'
      SET @MustChangeDesc   = 'User must change password on next login policy was not SET to ON for ' + CONVERT(VARCHAR(15), @MustChangeCount) + ' sql login(s)'

END
ELSE
BEGIN
      SET @MustChangeStatus = '1'
      SET @MustChangeDesc   = ''
END

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify the MUST_CHANGE option is set to ON for all SQL Authenticated Logins'
          , @MustChangeStatus
          , @MustChangeDesc
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------


--Verify the 'CHECK_EXPIRATION' option is set to ?ON? for all SQL Authenticated Logins within the SYSADMIN Role
DECLARE    @CheckExpirationCount  VARCHAR( 20)
DECLARE    @CheckExpirationStatus VARCHAR( 10)
DECLARE    @CheckExpirationDesc   VARCHAR(100)

SELECT     @CheckExpirationCount  = COUNT(*) FROM @vAuditCheck_SqlLogins WHERE is_expiration_checked = 0 AND IsSysAdmin = 1 AND IsDisabled = 0
IF         @CheckExpirationCount  > 0
BEGIN
      SET @CheckExpirationStatus = '0'
      SET @CheckExpirationDesc   = 'Enforce Password Expiration policy was NOT SET to ON for ' + CONVERT(VARCHAR(15), @CheckExpirationStatus) + ' sql login(s)'

END
ELSE
BEGIN
      SET @CheckExpirationStatus = '1'
      SET @CheckExpirationDesc   = ''
END

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify the CHECK_EXPIRATION option is set to ON for all SQL Authenticated Logins within the SYSADMIN Role'
          , @CheckExpirationStatus
          , @CheckExpirationDesc
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------


--Verify the 'CHECK_POLICY'     option is set to ?ON? for all SQL Authenticated Logins
DECLARE    @CheckPolicyCount  VARCHAR( 20)
DECLARE    @CheckPolicyStatus VARCHAR( 10)
DECLARE    @CheckPolicyDesc   VARCHAR(100)

SELECT     @CheckPolicyCount  = COUNT(*) FROM @vAuditCheck_SqlLogins WHERE is_policy_checked = 0 AND IsDisabled = 0
IF         @CheckPolicyCount  > 0
BEGIN
      SET @CheckPolicyStatus = '0'
      SET @CheckPolicyDesc   = 'Enforce Password policy was NOT SET to ON for ' + CONVERT(VARCHAR(15), @CheckPolicyCount) + ' sql login(s)'

END
ELSE
BEGIN
      SET @CheckPolicyStatus = '1'
      SET @CheckPolicyDesc   = ''
END

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify the CHECK_POLICY option is set to ON for all SQL Authenticated Logins'
          , @CheckPolicyStatus
          , @CheckPolicyDesc
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------



-------------------------------------------------------------------------------------------------------------------------------
--Verify 'Login Auditing' is set minimally to €œFailed€, but also €œSuccessful€ if server and application can support it
-------------------------------------------------------------------------------------------------------------------------------
DECLARE @tmp1Audits TABLE ( ServerName  VARCHAR(45) NOT NULL DEFAULT (CONVERT(VARCHAR(128), @@SERVERNAME))
                         , Description VARCHAR(50)
                         , Value       VARCHAR(70)
                         , AuditLevelDescription   AS  CASE Value  WHEN 0 THEN 'None'
                                                                   WHEN 1 THEN 'Successful logins only'
                                                                   WHEN 2 THEN 'Failed logins only'
                                                                   WHEN 3 THEN 'Both failed and successful logins'
                                                       END
                         )
INSERT INTO @tmp1Audits   ([Description], Value)  
EXEC   master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE'
                                     , N'Software\Microsoft\MSSQLServer\MSSQLServer'
                                     , N'AuditLevel'

INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT      @RowNo
          , 'Verify Login Auditing is set minimally to Failed, but also Successful if server & application can support it'
          , CASE WHEN Value = 2 OR Value = 3 THEN '1' ELSE '0' END
          , Value + ' - ' + AuditLevelDescription
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  ,0                                                               -----------------------------------
FROM        @tmp1Audits
----------------------------------------------------------------------------------------------------------------------------
--Verify stored procedure 000_company_PMP_PID1 is scheduled to change the 'sa' password every 45 days
--Verify the '000 company ARC Data Collection' procedure is set up to run daily and capture the ACL data for the ARC reviews
-----------------------------------------------------------------------------------------------------------------------------
INSERT INTO @vAuditCheckList  
          ( AuditRowNo, Checklist, [Status], Remarks, ServerName, Inserted, UserName,Sort)
SELECT     @RowNo
        , [JobDescription]        = CASE WHEN sjb.name = '000_company_ARC_Data_Collection' THEN 'Verify the 000_company_ARC_Data_Collection procedure is set up to run daily and capture the ACL data for the ARC reviews'
                                           WHEN sjb.name = '000_company_PMP_PID1'            THEN 'Verify stored procedure 000_company_PMP_PID1 is scheduled to change the "sa" password every 45 days'
                                           ELSE sjb.name
                                      END
          , [JobEnabled]            = CASE WHEN sjb.enabled = 0    THEN '0' WHEN sjb.enabled = 1 THEN '1' END
          , Schedule                = CONVERT(VARCHAR(50), 'Schedule - ' 
                                      + 
                                      CASE WHEN sjb.enabled = 0                                THEN 'Disabled'
                                           WHEN sjb.job_id IS NULL                             THEN 'Unscheduled'
                                           WHEN ssc.freq_type = 0x1                            THEN 'Once on ' + CONVERT(CHAR(10), CAST( CAST( ssc.active_start_date AS VARCHAR ) AS DATETIME ), 102 /*yyyy.mm.dd*/ )
                                           WHEN ssc.freq_type = 0x4  AND ssc.freq_interval = 1 THEN 'Daily'
                                           WHEN ssc.freq_type = 0x4  AND ssc.freq_interval > 1 THEN 'Every ' + CONVERT(VARCHAR(12), ssc.freq_interval) + ' day(s)'
                                           WHEN ssc.freq_type = 0x8  THEN -- weekly
                                                                     CASE WHEN ssc.freq_recurrence_factor = 1 THEN 'Weekly on '
                                                                     WHEN ssc.freq_recurrence_factor      > 1 THEN 'Every ' + CAST( ssc.freq_recurrence_factor AS VARCHAR )
                                                                                                                            + ' weeks on '
                                                                     END
                                                                     + 
                                                                     LEFT
                                                                     ( CASE WHEN ssc.freq_interval &  1 =  1 THEN 'Sunday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  2 =  2 THEN 'Monday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  4 =  4 THEN 'Tuesday, '   ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  8 =  8 THEN 'Wednesday, ' ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 16 = 16 THEN 'Thursday, '  ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 32 = 32 THEN 'Friday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 64 = 64 THEN 'Saturday, '  ELSE '' END
                                                                     , 
                                                                     LEN
                                                                     ( CASE WHEN ssc.freq_interval &  1 =  1 THEN 'Sunday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  2 =  2 THEN 'Monday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  4 =  4 THEN 'Tuesday, '   ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval &  8 =  8 THEN 'Wednesday, ' ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 16 = 16 THEN 'Thursday, '  ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 32 = 32 THEN 'Friday, '    ELSE '' END
                                                                     + CASE WHEN ssc.freq_interval & 64 = 64 THEN 'Saturday, '  ELSE '' END
                                                                     )  - 1  -- LEN() ignores trailing spaces
                                                                     )
                                           WHEN ssc.freq_type = 0x10 THEN  --monthly
                                                                     CASE WHEN ssc.freq_recurrence_factor = 1 THEN 'Monthly on the '
                                                                          WHEN ssc.freq_recurrence_factor > 1 THEN 'Every ' + CAST( ssc.freq_recurrence_factor AS VARCHAR) + ' months on the '
                                                                     END
                                                                     + CAST( ssc.freq_interval AS VARCHAR )
                                                                     + CASE WHEN ssc.freq_interval IN ( 1, 21, 31 ) THEN 'st'
                                                                            WHEN ssc.freq_interval IN ( 2, 22     ) THEN 'nd'
                                                                            WHEN ssc.freq_interval IN ( 3, 23     ) THEN 'rd' ELSE 'th'
                                                                       END
                                           WHEN ssc.freq_type = 0x20 THEN --monthly relative
                                                                     CASE WHEN ssc.freq_recurrence_factor = 1 THEN 'Monthly on the '
                                                                          WHEN ssc.freq_recurrence_factor > 1 THEN 'Every '
                                                                     +    CAST(ssc.freq_recurrence_factor AS VARCHAR ) + ' months on the '
                                                                     END
                                                                     +
                                                                     CASE ssc.freq_relative_interval WHEN 0x01 THEN 'first '
                                                                                                     WHEN 0x02 THEN 'second '
                                                                                                     WHEN 0x04 THEN 'third '
                                                                                                     WHEN 0x08 THEN 'fourth '
                                                                                                     WHEN 0x10 THEN 'last '
                                                                     END
                                                                     + 
                                                                     CASE ssc.freq_interval WHEN  1  THEN 'Sunday'
                                                                                                     WHEN  2 THEN 'Monday'
                                                                                                     WHEN  3 THEN 'Tuesday'
                                                                                                     WHEN  4 THEN 'Wednesday'
                                                                                                     WHEN  5 THEN 'Thursday'
                                                                                                     WHEN  6 THEN 'Friday'
                                                                                                     WHEN  7 THEN 'Saturday'
                                                                                                     WHEN  8 THEN 'day'
                                                                                                     WHEN  9 THEN 'week day'
                                                                                                     WHEN 10 THEN 'weekend day'
                                                                     END
                                           WHEN ssc.freq_type = 0x40 THEN 'Automatically starts when SQLServerAgent starts.'
                                           WHEN ssc.freq_type = 0x80 THEN 'Starts whenever the CPUs become idle'
                                           ELSE ''
                                           END
                                      + 
                                      CASE WHEN sjb.enabled = 0 THEN ''
                                           WHEN sjb.job_id IS NULL THEN ''
                                           WHEN ssc.freq_subday_type = 0x1 OR ssc.freq_type = 0x1 THEN ' at '
                                           + 
                                           Case  -- Depends on time being integer to drop right-side digits
                                           when(ssc.active_start_time % 1000000)/10000 = 0  then '12'
                                                                                               + ':'  
                                                                                               + Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100)))
                                                                                               + convert(char(2),(ssc.active_start_time % 10000)/100) 
                                                                                               + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000< 10 then convert(char(1),(ssc.active_start_time % 1000000)/10000) 
                                                                                               + ':'  
                                                                                               + Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                                                               + convert(char(2),(ssc.active_start_time % 10000)/100) 
                                                                                               + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000< 12 then convert(char(2),(ssc.active_start_time % 1000000)/10000) 
                                                                                               + ':'  
                                                                                               + Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                                                               + convert(char(2),(ssc.active_start_time % 10000)/100) 
                                                                                               + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000< 22 then convert(char(1),((ssc.active_start_time % 1000000)/10000) - 12) 
                                                                                               + ':'  
                                                                                               + Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                                                               + convert(char(2),(ssc.active_start_time % 10000)/100) 
                                                                                               + ' PM'
                                           else                                                  convert(char(2),((ssc.active_start_time % 1000000)/10000) - 12)
                                                                                               + ':'  
                                                                                               + Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                                                               + convert(char(2),(ssc.active_start_time % 10000)/100) 
                                                                                               + ' PM'
                                           end
                                      WHEN ssc.freq_subday_type IN ( 0x2, 0x4, 0x8 ) 
                                      THEN ' every '
                                           + CAST( ssc.freq_subday_interval AS VARCHAR )
                                           + 
                                           CASE freq_subday_type WHEN 0x2 THEN ' second'
                                                                 WHEN 0x4 THEN ' minute'
                                                                 WHEN 0x8 THEN ' hour'
                                      END
                                      + 
                                      CASE 
                                      WHEN ssc.freq_subday_interval > 1 THEN 's'
                                      ELSE                                    '' -- Added default 3/21/08; John Arnott
                                      END
                                      ELSE ''
                                      END
                                      + 
                                      CASE
                                      WHEN sjb.enabled = 0                           THEN ''
                                      WHEN sjb.job_id IS NULL                        THEN ''
                                      WHEN ssc.freq_subday_type IN ( 0x2, 0x4, 0x8 ) THEN ' between '
                                           + Case  -- Depends on time being integer to drop right-side digits
                                           when(ssc.active_start_time % 1000000)/10000 = 0 then 
                                                      '12'
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100)))
                                                    + rtrim(convert(char(2),(ssc.active_start_time % 10000)/100))
                                                    + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000< 10 then
                                                    convert(char(1),(ssc.active_start_time % 1000000)/10000) 
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_start_time % 10000)/100))
                                                    + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000 < 12 then
                                                    convert(char(2),(ssc.active_start_time % 1000000)/10000) 
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_start_time % 10000)/100)) 
                                                    + ' AM'
                                           when (ssc.active_start_time % 1000000)/10000< 22 then
                                                    convert(char(1),((ssc.active_start_time % 1000000)/10000) - 12) 
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_start_time % 10000)/100)) 
                                                    + ' PM'
                                           else        convert(char(2),((ssc.active_start_time % 1000000)/10000) - 12)
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_start_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_start_time % 10000)/100))
                                                    + ' PM'
                                           end
                            + ' and '
                            + Case  -- Depends on time being integer to drop right-side digits
                                    when(ssc.active_end_time % 1000000)/10000 = 0 then 
                                                    '12'
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_end_time % 10000)/100)))
                                                    + rtrim(convert(char(2),(ssc.active_end_time % 10000)/100))
                                                    + ' AM'
                                    when (ssc.active_end_time % 1000000)/10000< 10 then
                                                    convert(char(1),(ssc.active_end_time % 1000000)/10000) 
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_end_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_end_time % 10000)/100))
                                                    + ' AM'
                                    when (ssc.active_end_time % 1000000)/10000 < 12 then
                                                    convert(char(2),(ssc.active_end_time % 1000000)/10000) 
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_end_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_end_time % 10000)/100))
                                                    + ' AM'
                                    when (ssc.active_end_time % 1000000)/10000< 22 then
                                                    convert(char(1),((ssc.active_end_time % 1000000)/10000) - 12)
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_end_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_end_time % 10000)/100)) 
                                                    + ' PM'
                                    else        convert(char(2),((ssc.active_end_time % 1000000)/10000) - 12)
                                                    + ':'  
                                                    +Replicate('0',2 - len(convert(char(2),(ssc.active_end_time % 10000)/100))) 
                                                    + rtrim(convert(char(2),(ssc.active_end_time % 10000)/100)) 
                                                    + ' PM'
                            end
           ELSE ''
       END
       )
          , @@SERVERNAME
          , GETDATE()
          , SUSER_SNAME()
		  , [Sort] = CASE WHEN sjb.name = '000_company_ARC_Data_Collection' THEN 1
                                           WHEN sjb.name = '000_company_PMP_PID1' THEN 2
                                           ELSE 0 END
FROM       msdb.dbo.SYSJOBS             sjb (NOLOCK) 
LEFT  JOIN msdb.dbo.SYSJOBSCHEDULES     sjs (NOLOCK) ON sjb.job_id = sjs.job_id
LEFT  JOIN msdb.dbo.SYSSCHEDULES        ssc (NOLOCK) ON sjs.schedule_id = ssc.schedule_id
WHERE      sjb.name in ('000_company_ARC_Data_Collection', '000_company_PMP_PID1') 
-----------------------------------------------------------------------------------------------------------------------------
--OUTPUT
-----------------------------------------------------------------------------------------------------------------------------
SELECT [CheckListNo],Checklist, [Status], Remarks, ServerName, Inserted FROM @vAuditCheckList WHERE AuditRowNo = @RowNo order by Sort
"@



$result = exec-SqlCommand -Server $SERVER_INSTANCE -Database Master #-Username $DB_USERNAME -Password $DB_USER_PASSWORD
return $result #| Format-table -Property CheckListNo,Checklist,Status,Remarks,ServerName,Inserted | Out-String -Width 4096
	
} -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)
$NPRegValueDesc =$Auditdetails[0]
$SMRegValueDesc =$Auditdetails[1]
$TCPRegValueDesc=$Auditdetails[2]
$SQLversion = $Auditdetails[3]

$Auditdetails | Format-table -Property CheckListNo,Checklist,Status,Remarks,ServerName,Inserted | Out-String -Width 4096
write-host "         26 Ensure Unnecessary SQL Server Protocols are set to Disabled : Named Pipes        					   $NPRegValueDesc "
write-host "         27 Ensure Unnecessary SQL Server Protocols are set to Disabled : Shared Memory      					   $SMRegValueDesc "
write-host "         28 Ensure Unnecessary SQL Server Protocols are set to Disabled : TCP/IP             				           $TCPRegValueDesc "
write-host " Sqlversion is $SQLversion"

function InsertNewHost($Auditdetails){
       try 
    {
if ($Auditdetails.Checklist[23] -cmatch "000_company_PMP_PID1")
{$insertSQLCMD = $insertSQL -f $SERVER_NAME, $SERVER_INSTANCE, $Auditdetails.status[0], $Auditdetails.status[1], $Auditdetails.status[2], $Auditdetails.status[3], $Auditdetails.status[4], $Auditdetails.status[5], $NPRegValueDesc, $SMRegValueDesc, $TCPRegValueDesc, $Auditdetails.status[6], $Auditdetails.status[7], $Auditdetails.status[8], $Auditdetails.status[9],	$Auditdetails.status[10], $Auditdetails.status[11], $Auditdetails.status[12], $Auditdetails.status[13],	$Auditdetails.status[14], $Auditdetails.status[15], $Auditdetails.status[16], $Auditdetails.status[17],	$Auditdetails.status[18], $Auditdetails.status[19], $Auditdetails.status[20], $Auditdetails.status[21], $Auditdetails.status[22], $Auditdetails.status[24], $Auditdetails.status[23], $SQLversion
    #Write-Host $insertSQLCMD
    }
    else
    {$insertSQLCMD = $insertSQL -f $SERVER_NAME, $SERVER_INSTANCE, $Auditdetails.status[0], $Auditdetails.status[1], $Auditdetails.status[2], $Auditdetails.status[3], $Auditdetails.status[4], $Auditdetails.status[5], $NPRegValueDesc, $SMRegValueDesc, $TCPRegValueDesc, $Auditdetails.status[6], $Auditdetails.status[7], $Auditdetails.status[8], $Auditdetails.status[9],	$Auditdetails.status[10], $Auditdetails.status[11], $Auditdetails.status[12], $Auditdetails.status[13],	$Auditdetails.status[14], $Auditdetails.status[15], $Auditdetails.status[16], $Auditdetails.status[17],	$Auditdetails.status[18], $Auditdetails.status[19], $Auditdetails.status[20], $Auditdetails.status[21], $Auditdetails.status[22], $Auditdetails.status[23], $Auditdetails.status[24], $SQLversion
    #Write-Host $insertSQLCMD
    }
    Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -Username $DB_USERNAME -Password $DB_USER_PASSWORD -ErrorAction Stop
    Write-Host "Inserted new entry in SQL Drift DB: $($SERVER_INSTANCE)"
    } 
    catch 
    {
        'Error: {0}' -f $_.Exception.Message
    }
}

function Build-hostReport(){
   InsertNewHost -Auditdetails $Auditdetails
   }         

Build-hostReport

}

########################

##############3

