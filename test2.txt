#########reboot sc##################

get-item env:computername
$vcs = '$INPUT{VCENTERSERVER}'

[ValidateNotNullOrEmpty()]
[string]$client = '$INPUT{SERVERLIST}'

#if(($client -eq 'server1') -or ($client -eq 'server2'))
#{

if ($vcs -eq 'server1.example.com') {
	
    [ValidateNotNullOrEmpty()]
    $varPassword = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force

    [ValidateNotNullOrEmpty()]
    [string]$varUsername = '$INPUT{USERNAME}'

    [ValidateNotNullOrEmpty()]
    [string] $vcenterserver = '$INPUT{VCENTERSERVER}'

    [ValidateNotNullOrEmpty()]
    [string]$client = '$INPUT{SERVERLIST}'

  
   
    if ($client -like "*.*") {
        $client = $client.split('.')[0].trim()
    }
   
   
    $client = $client.ToUpper()

    #Credentials
    $varCredentials = New-Object System.Management.Automation.PSCredential($varUsername, $varPassword )
    $VarVcenter = $VarVcenter.trim()
    $connectedServer = $global:defaultviserver	
	

    Invoke-Command -ComputerName 'server1.example.com' -Credential $varCredentials -Scriptblock {
	
        get-item env:computername

        if (!(Get-Module -Name VMware.VimAutomation.Core)) {
            Import-Module -Name VMware.VimAutomation.Core
            if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
        }

        $varUsername = $args[0]
        $varPassword = $args[1]
        $client = $args[2]
        $ipaddress = $args[3]

        $varCredentials = New-Object System.Management.Automation.PSCredential($varUsername, $varPassword )
        $vcenterserver = 'server1.example.com'

        if ($vcenterserver -eq 'server1.example.com' -or $vcenterserver -eq 'server2.example.com' -or $vcenterserver -eq 'server3.example.com' ) {
            Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false | Out-Null
        }
   

        if (!(Get-Module -Name VMware.VimAutomation.Core)) {
            Import-Module -Name VMware.VimAutomation.Core
    	
            if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
            else {
                try {
                    $cnvar = connect-viserver $vcenterserver -Credential $varCredentials  -ErrorAction Stop
                    $connected = "INFO: Connected to vcenter Server $vcenterserver"
                }
                catch {
                    $connectmsg = $_.Exception.Message
                    $connected = "ERROR: Could not connect to vCenter $vcenterserver $connectmsg"
                }

        
            }
        }
        else {
            try {
                $connectvar = connect-viserver $vcenterserver -Credential $varCredentials  -ErrorAction Stop
                $connected = "INFO: Connected to vcenter Server $vcenterserver"
            }
            catch {
                $connectmsg = $_.Exception.Message
                $connected = "ERROR: Could not connect to vCenter $vcenterserver $connectmsg"
            }

        
        }


        if ($connected) {
            if ($connected -notlike "ERROR: Could not connect to vCenter*") {
                try {
                    $vm = get-vm -Name $client -ErrorAction Stop 
                    $vmid = $vm.Id
                }
                catch {
                    $clientmsg = $_.Exception.Message
                    if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                        try {
                            $decomclient = "$client-DECOM*"
                            $vm = get-vm -Name $decomclient -ErrorAction Stop 
                            $vmid = $vm.Id
                            write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                            $decommsg = "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                        }
                        catch {
                            $clientmsg = $_.Exception.Message
                            write-host "ERROR: Unable to find VM $client in $vcenterserver $clientmsg"
                            $decommsg = $null
                        }
                    }
                }
            }
            else {
                $connected
            }

        }

        if (!$decommsg) {
            if ($vm.Name -eq "$client") {
                $pretask = get-task -Server $vcenterserver | where { $_.ObjectId -eq $vmid }
                $pregueststate = $vm.Guest.State
                $pretoolstate = $vm.ExtensionData.Guest.ToolsRunningStatus
                if ($pretask.State -ccontains "Queued" -or $pretask.State -ccontains "Running") {  
                    $pretaskdesc = $pretask.Description
                    $precheck = "Tasks in progress are " + $pretaskdesc
                }
                else {
                    $precheck = $Null
                }
                if ($pregueststate -ne 'Running') {
                    $precheck = "$vm is in $pregueststate state"
                }
                else {
                    $precheck = $Null
                }
                if ($pretoolstate -eq 'guestToolsRunning') {
                    $precheck = $Null
                }
                else {
                    $precheck = "$vm vmware tools are in $pretoolstate State"
                }


                if (!$precheck) {
    
        
                    try {
                        Write-Host "INFO: Rebooting the Virtual machine $vm "
                        #$reboottime = get-date
                        $rt = Get-VM -Name $VM | Restart-VM -Confirm:$false -ErrorAction Stop -Verbose
                        $reenableuid = $rt.Uid.split('/')[1]
                        $currenttask = get-task -Server $vcenterserver | where { ($_.ObjectId -eq $vmid) -and ($_.Name -eq 'ReconfigVM_Task') -and ($_.Uid -like "*$reenableuid*") -and ($_.StartTime -gt (get-date).AddSeconds(-10)) } -Verbose
                        $taskid = $currenttask.Id
                        $t = get-task -id $taskid -Verbose
                        $targettime = (get-date).AddMinutes(3)
                        $attempt = 1
                        do {
                            Write-Host "INFO: Virtual Center Task progress ..  $($t.PercentComplete)% complete and re check Attempt is $attempt"
                            start-sleep -Seconds 10
                            $Time1 = get-date -Verbose
                            $TimeDiff = New-TimeSpan $Time1 $targettime
                            $diffminutes = $TimeDiff.TotalMinutes
                            if ($t.PercentComplete -ne 100) {
                                $t = get-task -Id $t.ID
                            }
                            $attempt = $attempt + 1
                            try {
                                $finpgdet = (Get-VM -Name $VM -ErrorAction stop -Verbose).Guest.State
                            }
                            catch {
                                $verificationmsg = $_.Exception.Message
                                Write-Host "ERROR: Getting VM details failed $verificationmsg"
                                $finpgdet = $Null
                            }
                        }until(($finpgdet -eq 'Running') -or ($diffminutes -lt 0))
                    }
                    catch {
                        $rebootmsg = $_.Exception.Message
                        Write-Host "ERROR: $rebootmsg"
                    }
                 
                }
                else {
                    write-host "ERROR: The VM $client has failed to intiate the Backup NIC Remediation due to prechecks $precheck"
                }

            }
            else {
                write-host "ERROR: The VM $client not found in vCenter $vcenterserver"
            }
            if ($finpgdet -eq 'Running') {
	
                Write-Host "ACCOMPLISHED > VMreeboot is success current status of VM is $finpgdet"
            }
            else {
                Write-Host "NOTACCOMPLISHED > VMreeboot is not successful current status of VM is $finpgdet"
            }
        }
        else {
            write-host $decommsg
        }

    } -Argumentlist $varUsername, $varPassword, $client, $ipaddress -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck -ProxyAccessType NoProxyServer) -EA Stop	
	
}
else {


    #Declarations

    [ValidateNotNullOrEmpty()]
    $varPassword = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force

    [ValidateNotNullOrEmpty()]
    [string]$varUsername = '$INPUT{USERNAME}'

    [ValidateNotNullOrEmpty()]
    [string] $vcenterserver = '$INPUT{VCENTERSERVER}'

    [ValidateNotNullOrEmpty()]
    [string]$client = '$INPUT{SERVERLIST}'
   
    if ($client -like "*.*") {
        $client = $client.split('.')[0].trim()
    }
    $varCredentials = New-Object System.Management.Automation.PSCredential($varUsername, $varPassword )
   
    $client = $client.ToUpper()
   
   
    if ($vcenterserver -eq 'server1.example.com' -or $vcenterserver -eq 'server2.example.com') {
        Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false | Out-Null
    }
   
    if (!(Get-Module -Name VMware.VimAutomation.Core)) {
        Import-Module -Name VMware.VimAutomation.Core
    	
        if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
        else {
            try {
                $cnvar = connect-viserver $vcenterserver -Credential $varCredentials  -ErrorAction Stop
                $connected = "INFO: Connected to vcenter Server $vcenterserver"
            }
            catch {
                $connectmsg = $_.Exception.Message
                $connected = "ERROR: Could not connect to vCenter $vcenterserver $connectmsg"
            }

        
        }
    }
    else {
        try {
            $connectvar = connect-viserver $vcenterserver -Credential $varCredentials  -ErrorAction Stop
            $connected = "INFO: Connected to vcenter Server $vcenterserver"
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR: Could not connect to vCenter $vcenterserver $connectmsg"
        }

        
    }


    if ($connected) {
        if ($connected -notlike "ERROR: Could not connect to vCenter*") {
            try {
                $vm = get-vm -Name $client -ErrorAction Stop 
                $vmid = $vm.Id
            }
            catch {
                $clientmsg = $_.Exception.Message
                if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                    try {
                        $decomclient = "$client-DECOM*"
                        $vm = get-vm -Name $decomclient -ErrorAction Stop 
                        $vmid = $vm.Id
                        write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                        $decommsg = "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                    }
                    catch {
                        $clientmsg = $_.Exception.Message
                        write-host "ERROR: Unable to find VM $client in $vcenterserver $clientmsg"
                        $decommsg = $null
                    }
                }
            }
        }
        else {
            $connected
        }

    }

    if (!$decommsg) {
        if ($vm.Name -eq "$client") {
            $pretask = get-task -Server $vcenterserver | where { $_.ObjectId -eq $vmid }
            $pregueststate = $vm.Guest.State
            $pretoolstate = $vm.ExtensionData.Guest.ToolsRunningStatus
            if ($pretask.State -ccontains "Queued" -or $pretask.State -ccontains "Running") {  
                $pretaskdesc = $pretask.Description
                $precheck = "Tasks in progress are " + $pretaskdesc
            }
            else {
                $precheck = $Null
            }
            if ($pregueststate -ne 'Running') {
                $precheck = "$vm is in $pregueststate state"
            }
            else {
                $precheck = $Null
            }
            if ($pretoolstate -eq 'guestToolsRunning') {
                $precheck = $Null
            }
            else {
                $precheck = "$vm vmware tools are in $pretoolstate State"
            }


            if (!$precheck) {
    
        
                try {
                    Write-Host "INFO: Rebooting the Virtual machine $vm "
                    #$reboottime = get-date
                    $rt = Get-VM -Name $VM | Restart-VM -Confirm:$false -ErrorAction Stop -Verbose
                    $reenableuid = $rt.Uid.split('/')[1]
                    $currenttask = get-task -Server $vcenterserver | where { ($_.ObjectId -eq $vmid) -and ($_.Name -like '*reset*') -and ($_.Uid -like "*$reenableuid*") -and ($_.StartTime -gt (get-date).AddSeconds(-120)) } -Verbose
                    $taskid = $currenttask.Id
                    $t = get-task -id $taskid -Verbose
                    $targettime = (get-date).AddMinutes(5)
                    $attempt = 1
                    do {
                        Write-Host "INFO: Virtual Center Task progress ..  $($t.PercentComplete)% complete and re check Attempt is $attempt"
                        start-sleep -Seconds 10
                        $Time1 = get-date -Verbose
                        $TimeDiff = New-TimeSpan $Time1 $targettime
                        $diffminutes = $TimeDiff.TotalMinutes
                        if ($t.PercentComplete -ne 100) {
                            $t = get-task -Id $t.ID
                        }
                        $attempt = $attempt + 1
                        try {
                            $finpgdet = (Get-VM -Name $VM -ErrorAction stop -Verbose).Guest.State
                        }
                        catch {
                            $verificationmsg = $_.Exception.Message
                            Write-Host "ERROR: Getting VM details failed $verificationmsg"
                            $finpgdet = $Null
                        }
                    }until(($finpgdet -eq 'Running') -or ($diffminutes -lt 0))
                }
                catch {
                    $rebootmsg = $_.Exception.Message
                    Write-Host "ERROR: $rebootmsg"
                }
                 
            }
            else {
                write-host "ERROR: The VM $client has failed to intiate the Backup NIC Remediation due to prechecks $precheck"
            }

        }
        else {
            write-host "ERROR: The VM $client not found in vCenter $vcenterserver"
        }
        if ($finpgdet -eq 'Running') {
	
            Write-Host "ACCOMPLISHED > VMreeboot is success current status of VM is $finpgdet"
        }
        else {
            Write-Host "NOTACCOMPLISHED > VMreeboot is not successful current status of VM is $finpgdet"
        }
    }
    else {
        write-host $decommsg
    }

}
#}

 start-sleep -Seconds 150


######################################

###########CAPACITY PREVERIFY###########


[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{VALID_PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{VALID_USER}'


[ValidateNotNullOrEmpty()]
[string] $vcenterserver = '$INPUT{VALID_SERVER_FQDN}'

[ValidateNotNullOrEmpty()]
[string]$client = '$INPUT{VMSDATA}'

[ValidateNotNullOrEmpty()]
[int]$expectedcpu = '$INPUT{EXCPU}'

[ValidateNotNullOrEmpty()]
[int]$expectedsocket = '$INPUT{EXSOCKET}'

[ValidateNotNullOrEmpty()]
[int]$expectedmemgb = '$INPUT{EXMEM}'

$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()
   
   
if ($vcenterserver -eq 'server1' -or $vcenterserver -eq 'server2' ) {
    try {
        Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false -ErrorAction Stop | Out-Null
        $configset = "INFO No proxy has been set "
    }
    catch { $configset = "ERROR Setting Proxy has failed" }  
}
else {
    $configset = "INFO No proxy has been set "
}


if ($configset) {
    $tabaobj.Add("Proxy", $configset)
}
   

if (!(Get-Module -Name VMware.VimAutomation.Core)) {
    try {
        Import-Module -Name VMware.VimAutomation.Core -ErrorAction stop
        $moduleset = "INFOVmware module has been imported"
    }
    catch { $moduleset = "ERRORVmware module has not been imported" }

    if ($moduleset) {
        $tabaobj.Add("Modules", $moduleset)
    }
    	
    if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
    else {
        try {
            $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
            $cnvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
            $connected = "INFO Connected to vcenter Server $vcenterserver"
            
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
        }
        if ($connected) {
            $tabaobj.Add("Connection", $connected)
        }
        
    }
}
else {
    try {
        $CREDENTIALS = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD
        $connectvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
        $connected = "INFO Connected to vcenter Server $vcenterserver"
    }
    catch {
        $connectmsg = $_.Exception.Message
        $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
    }


    if ($connected) {
        if ($tabaobj.ContainsKey("Connection")) {
            $tabaobj["Connection"] = $connected
        }
        else {
            $tabaobj.Add("Connection", $connected)
        }
    }
     
}


if ($connected) {
    if ($connected -notlike "ERROR Could not connect to vCenter*") {
        try {
            $vm = get-vm -Name $client -ErrorAction Stop 
            $vmid = $vm.Id
            $vmfound = "INFO VM $client is found in $vcenterserver"
        }
        catch {
            $clientmsg = $_.Exception.Message
            if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                try {
                    $decomclient = "$client-DECOM*"
                    $vm = get-vm -Name $decomclient -ErrorAction Stop 
                    $vmid = $vm.Id
                    #write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                    $vmfound = "ERROR :  VM $client in $vcenterserver is renamed for Decomission or Not Found"
                    
                }
                catch {
                    $clientmsg = $_.Exception.Message
                    #write-host "ERROR Unable to find VM $client in $vcenterserver $clientmsg"
                    $vmfound = "ERROR $clientmsg"
                }
            }
        }
    }
    else {
        $vmfound = "ERROR VM $client is not found in $vcenterserver"
    }

}


if ($vmfound) {
    if ($tabaobj.ContainsKey("VmStatus")) {
        $tabaobj["VmStatus"] = $vmfound
    }
    else {
        $tabaobj.Add("VmStatus", $vmfound)
    }
}


if ($vmfound -eq "INFO VM $client is found in $vcenterserver") {
    if ($vm.Name -eq "$client") {
        $pretask = get-task -Server $vcenterserver | where-object { $_.ObjectId -eq $vmid }
        $pregueststate = $vm.Guest.State
        $pretoolstate = $vm.ExtensionData.Guest.ToolsRunningStatus
        if ($pretask.State -ccontains "Queued" -or $pretask.State -ccontains "Running") {  
            $pretaskdesc = $pretask.Description
            $precheck = "Tasks in progress are " + $pretaskdesc
        }
        else {
            $precheck = $Null
        }
        if ($pregueststate -ne 'Running') {
            $precheck = "$vm is in $pregueststate state"
        }
        else {
            $precheck = $Null
        }
        if ($pretoolstate -eq 'guestToolsRunning') {
            $precheck = $Null
        }
        else {
            $precheck = "$vm vmware tools are in $pretoolstate State"
        }

        if ($precheck) {
            if ($tabaobj.ContainsKey("Prechecks")) {
                $tabaobj["Prechecks"] = $precheck
            }
            else {
                $tabaobj.Add("Prechecks", $precheck)
            }
        }
        else {
            if ($tabaobj.ContainsKey("Prechecks")) {
                $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
            }
            else {
                $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
            }
        }
        if (!$precheck) {
    
            try {
                function Get-OptimalvCPU {
                    [cmdletbinding()]
                    Param
                    (
                        [Parameter(Mandatory = $false)]$vmName,
                        [Parameter(Mandatory = $false)]$excpu,
                        [Parameter(Mandatory = $false)]$exsocket,
                        [Parameter(Mandatory = $false)]$exmem,
                        [Parameter(Mandatory = $false)][switch]$simple
                    )

                    $nameFilter = ""
                    $vmFilter = @{'RunTime.ConnectionState' = '^(?!disconnected|inaccessible|invalid|orphaned).*$'; 'Runtime.PowerState' = 'poweredOn'; 'Config.Template' = 'False' }
                    $hostFilter = @{'Runtime.ConnectionState' = 'connected'; 'Runtime.PowerState' = 'poweredOn' }
                    $results = @()
                    $vms = @()
                    Write-Verbose "Retrieving VMs information - Skipping Disconnected, Powered Off, or Template VMs"

                    Try {
                        If ($VMName -ne $null) {
                            foreach ($name in $VMName) {
                                $nameFilter += "$name|"
                            }
                            $nameFilter = $nameFilter.TrimEnd("|")
                            $vmFilter += @{"Name" = $nameFilter }
                        }
                        #gets VM information
                        if ($excpu -and $exsocket) {
                            $vms = get-view -ViewType VirtualMachine -Filter $vmFilter -Property Name, Config.Hardware.MemoryMB, Config.Hardware.NumCPU, Config.Hardware.NumCoresPerSocket, Config.CpuHotAddEnabled, Config.MemoryHotAddEnabled, Config.Version, Config.ExtraConfig, Runtime.Host | 
                            select-object Name, @{n = 'MemoryGB'; e = { [math]::Round(($_.Config.Hardware.MemoryMB / 1024), 2) } }, 
                            @{n = 'Sockets'; e = { ( $exsocket ) } },
                            @{n = 'CoresPerSocket'; e = { $excpu / $exsocket } }, 
                            @{n = 'NumCPU'; e = { $excpu } },
                            @{n = 'CpuHotAdd'; e = { $_.Config.CpuHotAddEnabled } },
                            @{n = 'MemHotAdd'; e = { $_.Config.MemoryHotAddEnabled } },
                            @{n = 'HWVersion'; e = { $_.Config.Version } }, @{n = 'HostId'; e = { $_.Runtime.Host.Value } },
                            @{n = 'vCenter'; e = { ([uri]$_.client.ServiceUrl).Host } }, 
                            @{n = 'NumaVcpuMin'; e = { ($_.Config.ExtraConfig | where-object { $_.Key -eq "numa.vcpu.min" }).Value } }
                        }
                        else {

                            $vms = get-view -ViewType VirtualMachine -Filter $vmFilter -Property Name, Config.Hardware.MemoryMB, Config.Hardware.NumCPU, Config.Hardware.NumCoresPerSocket, Config.CpuHotAddEnabled, Config.Version, Config.ExtraConfig, Runtime.Host | 
                            select-object Name, @{n = 'MemoryGB'; e = { [math]::Round(($_.Config.Hardware.MemoryMB / 1024), 2) } }, @{n = 'Sockets'; e = { ($_.Config.Hardware.NumCPU) / ($_.Config.Hardware.NumCoresPerSocket) } }, @{n = 'CoresPerSocket'; 
                                e                                                                                                                                                                                                 = { $_.Config.Hardware.NumCoresPerSocket }
                            }, @{n = 'NumCPU'; e = { $_.Config.Hardware.NumCPU } }, @{n = 'CpuHotAdd'; e = { $_.Config.CpuHotAddEnabled } }, @{n = 'MemHotAdd'; e = { $_.Config.MemoryHotAddEnabled } }, @{n = 'HWVersion'; e = { $_.Config.Version } }, @{n = 'HostId';
                                e                                                                                                                                                                = { $_.Runtime.Host.Value }
                            }, @{n = 'vCenter'; e = { ([uri]$_.client.ServiceUrl).Host } }, @{n = 'NumaVcpuMin'; e = { ($_.Config.ExtraConfig | where-object { $_.Key -eq "numa.vcpu.min" }).Value } } 
                        }
                        If ($vms -eq $null) {
                            Throw "No VMs found, or VMs are not powered on, or connected"
                        }
                    }
                    Catch {
                        Write-Error -Message "Error retrieving VM information: $($_.Exception.Message) at line $($_.InvocationInfo.ScriptLineNumber)"
                        break
                    }
    
                    Try {
                        Write-Verbose "Retrieving Host information. Skipping Disconnected or Powered Off Hosts"
                        If ($VMName -ne $null) {
                            $hostsUnique = $vms | Select @{n = "Id"; e = { "HostSystem-" + "$($_.HostId)" } }, vCenter | Sort-Object -Property @{e = "Id" }, @{e = "vCenter" } -Unique
                            $hostCommand = { get-view -Id $($hostsUnique.Id) -Property Name, Parent, Config.Product.Version, Config.HyperThread, Hardware.MemorySize, Hardware.CpuInfo, Config.PowerSystemInfo.CurrentPolicy.Key, Config.Option }
                        }
                        Else {
                            $hostCommand = { get-view -ViewType HostSystem -Filter $hostFilter -Property Name, Parent, Config.Product.Version, Config.HyperThread, Hardware.MemorySize, Hardware.CpuInfo, Config.PowerSystemInfo.CurrentPolicy.Key, Config.Option }
                        }
    
                        $vmHosts = Invoke-Command $hostCommand | select-object Name, @{n = 'Id'; e = { $_.MoRef.Value } }, @{n = 'Version'; e = { $_.Config.Product.Version } }, @{n = 'vCenter'; e = { ([uri]$_.Client.serviceurl).Host } }, @{n = "ClusterId";
                            e                                                                                                                                                                                                              = { $_.Parent | where-object { $_.Type -eq "ClusterComputeResource" } | select-object -expand Value }
                        }, @{n = 'MemoryGB'; e = { [int](($_.Hardware.MemorySize) / 1073741824) } }, @{n = "MemPerChannel";
                            e                                                                            = { [int](($_.Hardware.MemorySize) / 1073741824) / ($_.Hardware.CpuInfo.NumCpuPackages) }
                        }, @{n = 'Sockets'; e = { ($_.Hardware.CpuInfo.NumCpuPackages) } }, @{n = 'CoresPerSocket';
                            e                                                                   = { ($_.Hardware.CpuInfo.NumCPUCores) / $($_.Hardware.CpuInfo.NumCpuPackages) }
                        }, @{n = 'CPUs'; e = { $_.Hardware.CpuInfo.NumCPUCores } }, @{n = 'CpuThreads'; e = { ($_.Hardware.CpuInfo.NumCpuThreads) } }, @{n = 'HTActive';
                            e                                                                                                                              = { $_.Config.HyperThread.Active }
                        }, @{n = 'NumaVcpuMin'; e = { $_.Config.Option | where-object { $_.Key -eq "numa.vcpu.min" } } }, @{n = 'PowerPolicy'; 
                            e                                                                                          = {
                                switch ($_.Config.PowerSystemInfo.CurrentPolicy.Key) {
                                    "1" { "HighPerformance" }
                                    "2" { "Balanced" }
                                    "3" { "LowPower" }
                                    "4" { "Custom" }
                                }
                            }
                        }
                    }
                    Catch {
                        Write-Error -Message "Error retrieving Host information: $($_.Exception.Message) at line $($_.InvocationInfo.ScriptLineNumber)"
                        break
                    }

                    Try {
                        Write-Verbose "Retrieving Cluster information" 
                        $clustersUnique = $vmHosts | where-object { $_.ClusterId -ne $null } | Select @{n = "Id"; e = { "ClusterComputeResource-" + "$($_.ClusterId)" } }, vCenter | Sort-Object -Property @{e = "Id" }, @{e = "vCenter" } -Unique
                        #accounts for hosts with no cluster
                        If ($clustersUnique -ne $Null) {
                            $clusters = get-view -Id $($clustersUnique.Id) -Property Name | Select Name, @{n = "Id"; e = { $_.MoRef.Value } }, @{n = "vCenter";
                                e                                                                                                                  = { ([uri]$_.Client.serviceurl).Host }
                            }, MinMemoryGB, MinSockets, MinCoresPerSocket -ErrorAction Stop
 
                            foreach ($cluster in $clusters) {
                                $clusterHosts = $vmHosts | where-object { ($_.vCenter -eq $cluster.vCenter) -and $_.clusterID -eq $cluster.Id } | select-object Name, Id, MemoryGB, Sockets, CoresperSocket
                                $cluster.MinMemoryGB = ($clusterHosts.MemoryGB | measure-object -Minimum).Minimum
                                $cluster.MinSockets = ($clusterHosts.Sockets | measure-object -Minimum).Minimum
                                $cluster.MinCoresPerSocket = ($clusterHosts.CoresPerSocket | measure-object -Minimum).Minimum
                            }
                        }
                    }
                    Catch {
                        Write-Error -Message "Error retrieving Cluster information: $($_.Exception.Message) at line $($_.InvocationInfo.ScriptLineNumber)"
                        break
                    }

                    #process VM calculations
                    $vmCount = ($vms | Measure-Object).Count
                    Write-Verbose "Calculating Optimal vCPU settings for $vmCount VMs"
                    $n = 1
                    foreach ($vm in $vms) {
                        $vmsPercent = [math]::Round(($n / $vmCount) * 100)
                        Write-Progress -Activity "Calculating Optimum vCPU Config for VMs" -Status "$vmsPercent% Complete:" -PercentComplete $vmsPercent -CurrentOperation "Current VM: $($vm.Name)"
            
                        $priorities = @() 
                        $priorities += 0   
                        $details = ""
                        $pNumaNotExpDetails = ""

                        $vmHost = $vmHosts | where-object { $($_.vCenter) -eq $($vm.vCenter) -and $($_.Id) -eq $($vm.HostId) } | select-object -first 1

                        If ($vmHost.ClusterId -eq $null) {
                            $cluster = "" | Select Name, MinMemoryGB, MinSockets, MinCoresPerSocket
                        }
                        Else {
                            $cluster = $clusters | where-object { ($($_.Id) -eq $($vmHost.ClusterId)) -and ($($_.vCenter) -eq $($vmHost.vCenter)) } | Select Name, MinMemoryGB, MinSockets, MinCoresPerSocket | select-object -first 1
                        }
                        Try {
                            #flags if vmMemory spans pNUMA node
                            If ($vm.MemoryGB -gt $vmHost.MemPerChannel) {
                                $memWide = $true
                                $memWideDetail = "memory"
                            }
                            Else {
                                $memWide = $false
                                $memWideDetail = ""
                            } 
                            #flags if vCPUs span pNUMA node
                            If ($vm.NumCPU -gt $vmHost.CoresPerSocket) {
                                $cpuWide = $true
                                $cpuWideDetail = "CPU"
                            }
                            Else {
                                $cpuWide = $false
                                $cpuWideDetail = ""
                            }
        
                            #if #vCPUs is odd and crosses pNUMA nodes
                            If (($memWide -or $cpuWide) -and (($vm.NumCPU % 2) -ne 0)) {
                                $calcVmCPUs = $vm.NumCPU + 1
                                $cpuOdd = $true
                            }
                            Else {
                                $calcVmCPUs = $vm.NumCPU
                                $cpuOdd = $false
                            }
                            #calculations for optimal vCPU
                            $i = 0
                            Do {
                                $i++
                            }
                            Until (
                                (($vm.MemoryGB / $i -le $vmHost.MemPerChannel) -or ($calcVmCPUs / $i -eq 1)) `
                                    -and (($calcVmCPUs / $i -le $vmHost.CoresPerSocket) -or ($calcVmCPUs / $i -eq 1) -or ($calcVmCPUs -eq $vmHost.CPUs)) `
                                    -and (($calcVmCPUs / $i) % 2 -eq 0 -or ($calcVmCPUs / $i) % 2 -eq 1)
                            )
                            $optSockets = $i
                            $optCoresPerSocket = $calcVmCPUs / $optSockets
                            #flags if adjustments had to be made to the vCPUs
                            If (($optSockets -ne $vm.Sockets) -or ($optCoresPerSocket -ne $vm.CoresPerSocket) -or $cpuOdd) {
                                $cpuOpt = $false
                            }
                            Else {
                                $cpuOpt = $true
                            }
                            #vCPUs are not optimal, but VM is not wide
                            If (-not ($memWide -or $cpuWide) -and (-not $cpuOpt)) {
                                $details += "VM does not span pNUMA nodes, but consider configuring it to match pNUMA architecture | "
                                $priorities += 1
                            }

                            ######################################################
                            #if crossing pNUMA node(s), additional flags
                            If (($memWide -or $cpuWide) -and (-not $cpuOpt)) {
                                If ($memWideDetail -ne "" -and $cpuWideDetail -ne "") {
                                    $wideDetails = "$memWideDetail and $cpuWideDetail"
                                }
                                Else {
                                    $wideDetails = ("$memWideDetail $cpuWideDetail").Trim()
                                }
                                $details += "VM $wideDetails spans pNUMA nodes and should be distributed evenly across as few as possible | "
            
                                #flags if VM is crossing pNUMA nodes, and vHW version is less than 8 (pNUMA not exposed to guest) 
                                $vmHWVerNo = [int]$vm.HWVersion.Split("-")[1]
                                If ($vmHWVerNo -lt 8) {
                                    $pNumaNotExp = $true
                                    $pNumaNotExpDetails = "(vHW < 8) "
                                }
                                #flags if VM is crossing pNUMA nodes, and CPUHotAdd is enabled (pNUMA not exposed to guest) 
                                If ($vm.CpuHotAdd -eq $true) {
                                    $pNumaNotExp = $true
                                    $pNumaNotExpDetails = $pNumaNotExpDetails + " (CpuHotAddEnabled = TRUE)"
                                }
                                #flags if VM is crossing pNUMA nodes, and vCPUs is less than 9 (pNUMA not exposed to guest)
                                If ($vm.NumCPU -lt 9 -and $vm.NumaVcpuMin -eq $null -and $vmHost.NumaVcpuMin -eq $null) {
                                    $pNumaNotExp = $true
                                    $pNumaNotExpDetails = $pNumaNotExpDetails + " (vCPUs < 9). Consider modifying advanced setting ""Numa.Vcpu.Min"" to $($vm.NumCPU) or lower. "
 
                                }
                                #if NumaVcpuMin has been modified
                                Elseif ($vm.NumaVcpuMin -ne $null -or $vmHost.NumaVcpuMin -ne $null) {
                                    If ($vm.NumaVcpuMin -ne $null) {
                                        $modVM = "VMValue: $($vm.NumaVcpuMin) "
                                    }
                                    ElseIf ($vmHost.NumaVcpuMin -ne $null) {
                                        $modHost = "HostValue: $($vmHost.NumaVcpuMin)"
                                    }
                                    $modDetail = ("$modVM, $modHost").Trim(", ")

                                    switch ($vm.NumaVcpuMin -le $vm.NumCPU -or $vmHost.NumaVcpuMin -le $vm.NumCPU) {
                                        $true { $details += "vCPUs < 9, but advanced setting ""Numa.Vcpu.Min"" has been modified ($modDetail) to expose pNUMA to guest OS | " }
                                        $false {
                                            $pNumaNotExp = $true
                                            $pNumaNotExpDetails = $pNumaNotExpDetails + " (Advanced setting ""Numa.Vcpu.Min"" is > VM vCPUs). The setting has been modified ($modDetail), but is still higher than VM vCPUs. Change the value to $($vm.NumCPU) or lower to expose pNUMA to the guest OS"
                                        }
                                    }
                                }
                                If ($pNumaNotExp) {
                                    $pNumaNotExpDetails = $pNumaNotExpDetails.Trim() 
                                    $details += "VM spans pNUMA nodes, but pNUMA is not exposed to the guest OS: $pNumaNotExpDetails | "
                                }
             
                                #flags if VM has odd # of vCPUs and spans pNUMA nodes
                                If ($cpuOdd) {
                                    $details += "VM has an odd number of vCPUs and spans pNUMA nodes | "
                                }
                                $priorities += 3
                            }#end if (($memWide -or $cpuWide) -and (-not $cpuOpt))

                            #flags if hosts in a cluster are of different size memory or CPU
                            If (($vmHost.MemoryGB -ne $cluster.MinMemoryGB -or $vmHost.Sockets -ne $cluster.MinSockets -or $vmHost.CoresPerSocket -ne $cluster.MinCoresPerSocket) -and $cluster.MinMemoryGB -ne "") {
                                $details += "Host hardware in the cluster is inconsistent. Consider sizing VMs based on the minimums for the cluster | "
                                $priorities += 2
                            }
                            #flags VMs with CPU count higher than physical cores
                            If ($vm.NumCPU -gt ($vmHost.Sockets * $vmHost.CoresPerSocket)) {
                                $optSockets = $hostSockets
                                $optCoresPerSocket = $vmHost.CoresPerSocket
                                $priorities += 2
                                $details += "VM vCPUs exceed the host's physical cores. Consider reducing the number of vCPUs | "
                            }
                            #flags if vCPU count is > 8 and Host PowerPolicy is not "HighPerformance"
                            If ($vm.NumCPU -gt 8 -and $vmHost.PowerPolicy -ne "HighPerformance" -and $vmHost.PowerPolicy -ne "N/A") {
                                #$priorities += 2
                                $details += 'Consider changing the host Power Policy to "High Performance" for clusters with VMs larger than 8 vCPUs | '
                            } 
  
                            #gets highest priority
                            $highestPriority = ($priorities | measure-object -Maximum).Maximum
                            Switch ($highestPriority) {
                                0 { $priority = "N/A" }
                                1 { $priority = "LOW" }
                                2 { $priority = "MEDIUM" }
                                3 { $priority = "HIGH" }
                            }

                            #flags whether the VM is configured optimally or not
                            If ($priority -eq "N/A") {
                                $vmOptimized = "YES"
                            }
                            Else {
                                $vmOptimized = "NO"
                            }
                            #creates object with data to return from function
                            If ($simple -eq $true) {
                                $objInfo = [pscustomobject]@{
                                    VMName                = $($vm.Name);
                                    VMSockets             = $($vm.Sockets);
                                    VMCoresPerSocket      = $($vm.CoresPerSocket);
                                    vCPUs                 = $($vm.NumCPU);
                                    VMOptimized           = $vmOptimized;
                                    OptimalSockets        = $optSockets;
                                    OptimalCoresPerSocket = $optCoresPerSocket;
                                    Priority              = $priority;
                                    Details               = $details.Trim("| ");
                                    result 	 		      = "success";
									message               = "VM Found in VCenter"
                                } #end pscustomobject
                            }
                            Else {
                                $objInfo = [pscustomobject]@{
                                    vCenter                  = $($vmHost.vCenter);
                                    Cluster                  = $($cluster.Name);
                                    ClusterMinMemoryGB       = $($cluster.MinMemoryGB);
                                    ClusterMinSockets        = $($cluster.MinSockets);
                                    ClusterMinCoresPerSocket = $($cluster.MinCoresPerSocket);
                                    HostName                 = $($vmHost.Name);
                                    ESXi_Version             = $($vmHost.Version);
                                    HostMemoryGB             = $($vmHost.MemoryGB);
                                    HostSockets              = $($vmHost.Sockets);
                                    HostCoresPerSocket       = $($vmHost.CoresPerSocket);
                                    HostCpuThreads           = $($vmHost.CpuThreads);
                                    HostHTActive             = $($vmHost.HTActive);
                                    HostPowerPolicy          = $($vmHost.PowerPolicy);
                                    VMName                   = $($vm.Name);
                                    VMHWVersion              = $($vm.HWVersion);
                                    VMCpuHotAddEnabled       = $($vm.CpuHotAdd).ToString();
                                    VMMemHotAddEnabled       = $($vm.MemHotAdd).ToString();               
                                    VMMemoryGB               = $($vm.MemoryGB);
                                    VMSockets                = $($vm.Sockets);
                                    VMCoresPerSocket         = $($vm.CoresPerSocket);
                                    vCPUs                    = $($vm.NumCPU);
                                    VMOptimized              = $vmOptimized;
                                    OptimalSockets           = $optSockets;
                                    OptimalCoresPerSocket    = $optCoresPerSocket;
                                    Priority                 = $priority;
                                    Details                  = $details.Trim("| ");
                                    result 			         = "success";
									message                  = "VM Found in VCenter";
                                } #end pscustomobject
                            }
                            $results += $objInfo
                        }
                        Catch {
                            Write-Error "Error calculationing optimal CPU for $($vm.Name): $($_.Exception.Message) at line $($_.InvocationInfo.ScriptLineNumber)"
                        }
                        $n++
                    }#end foreach ($vm in $vms)
                    Write-Progress -Activity "Calculating Optimum vCPU Config for VMs" -Completed
                    $global:optimal = $results
                    
                }
                if ($vm.Guest.VmName -eq $client) {
                    if (($expectedcpu -is [int]) -and ($expectedcpu -ne 0)) { $expectedcpu = $expectedcpu }else { $expectedcpu = $vm.NumCpu }
                    if ($expectedsocket -is [int] -and ($expectedsocket -ne 0)) { $expectedsocket = $expectedsocket }else { $expectedsocket = ($vm.NumCpu / $vm.CoresPerSocket) }
                    if ($expectedmemgb -is [int] -and ($expectedmemgb -ne 0)) { $expectedmemgb = $expectedmemgb }else { $expectedmemgb = ($vm.MemoryGB) }
                    try
                    {
                      Get-OptimalvCPU -vmName $vm -excpu $expectedcpu -exsocket $expectedsocket -exmem $expectedmemgb
                    }
                    catch{
                    	$msg=$_.Exception.Message
                    	$tabaobj.Add("VMData", "$msg")	
                    }
                    if ($global:optimal) {
    
                        $tabaobj.Add("VMData", $global:optimal)
                        
                    }
                    else {
                        $tabaobj.Add("VMData", "ERROR Failed to Evaluate")
                    }
                }
                else {
                    $opitmalmsg = "ERROR The VM $client not found in vCenter $vcenterserver"
                    if ($global:optimal) {
                        $results.GetType()
                        $tabaobj.Add("VMData", $global:optimal)
                    }
                    else {
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                }
            }
            catch {
                $opitmalmsg = $_.Exception.Message
                if ($global:optimal) {
                    $results.GetType()
                    $tabaobj.Add("VMData", $global:optimal)
                }
                else {
                    $tabaobj.Add("VMData", $opitmalmsg)
                }
            }

        }
        else {
            $precheck = "ERROR The VM $client has failed due to prechecks $precheck"
            if ($precheck) {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = $precheck
                }
                else {
                    $tabaobj.Add("Prechecks", $precheck)
                }
            }
            else {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                }
                else {
                    $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                }
            }
        }

    }
    else {
        $vmfound = "ERROR The VM $client not found in vCenter $vcenterserver"
        if ($vmfound) {
            if ($tabaobj.ContainsKey("VmStatus")) {
                $tabaobj["VmStatus"] = $vmfound
            }
            else {
                $tabaobj.Add("VmStatus", $vmfound)
            }
        }
    }
   
}
else {
    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
            $result = "fail"
			$message = "VM not Found in VCenter"
			$objresultserr=@()
			$objInfoerror =@{}
			$objInfoerror = [pscustomobject]@{
                            	result                           = $result;
                                message                          = $message                 
                            }
			$objresultserr += $objInfoerror 
			$tabaobj.Add("VMData", $objresultserr)
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }
}
$tabaobj | ConvertTo-Json


################################################

##########CAPACITY ADD(HOT ADD)##################

#$ErrorActionPreference = "silentlycontinue"

[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{VALID_PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{VALID_USER}'


[ValidateNotNullOrEmpty()]
[string] $vcenterserver = '$INPUT{VALID_SERVER_FQDN}'

[ValidateNotNullOrEmpty()]
[string]$client = '$INPUT{VMSDATA}'

[ValidateNotNullOrEmpty()]
[int]$expectedcpu = '$INPUT{EXCPU}'

[ValidateNotNullOrEmpty()]
[int]$expectedsocket = '$INPUT{EXSOCKET}'

[ValidateNotNullOrEmpty()]
[int]$expectedmemgb = '$INPUT{EXMEM}'


$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()

#if ($client -eq 'sampleserver') {
   
    if ($vcenterserver -eq 'server1' -or $vcenterserver -eq 'server2') {
        try {
            Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false -ErrorAction Stop | Out-Null
            $configset = "INFO No proxy has been set "
        }
        catch { $configset = "ERROR Setting Proxy has failed" }  
    }
    else {
        $configset = "INFO No proxy has been set "
    }


    if ($configset) {
        $tabaobj.Add("Proxy", $configset)
    }
   

    if (!(Get-Module -Name VMware.VimAutomation.Core)) {
        try {
            Import-Module -Name VMware.VimAutomation.Core -ErrorAction stop
            $moduleset = "INFOVmware module has been imported"
        }
        catch { $moduleset = "ERRORVmware module has not been imported" }

        if ($moduleset) {
            $tabaobj.Add("Modules", $moduleset)
        }
    	
        if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
        else {
            try {
                $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
                $cnvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
                $connected = "INFO Connected to vcenter Server $vcenterserver"
            
            }
            catch {
                $connectmsg = $_.Exception.Message
                $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
            }
            if ($connected) {
                $tabaobj.Add("Connection", $connected)
            }
        
        }
    }
    else {
        try {
            $CREDENTIALS = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD
            $connectvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
            $connected = "INFO Connected to vcenter Server $vcenterserver"
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
        }


        if ($connected) {
            if ($tabaobj.ContainsKey("Connection")) {
                $tabaobj["Connection"] = $connected
            }
            else {
                $tabaobj.Add("Connection", $connected)
            }
        }
     
    }


    if ($connected) {
        if ($connected -notlike "ERROR Could not connect to vCenter*") {
            try {
                $vm = get-vm -Name $client -ErrorAction Stop 
                $vmid = $vm.Id
                $vmfound = "INFO VM $client is found in $vcenterserver"
            }
            catch {
                $clientmsg = $_.Exception.Message
                if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                    try {
                        $decomclient = "$client-DECOM*"
                        $vm = get-vm -Name $decomclient -ErrorAction Stop 
                        $vmid = $vm.Id
                        #write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                        $vmfound = "ERROR :  VM $client in $vcenterserver is renamed for Decomission"
                    }
                    catch {
                        $clientmsg = $_.Exception.Message
                        #write-host "ERROR Unable to find VM $client in $vcenterserver $clientmsg"
                        $vmfound = "ERROR $clientmsg"
                    }
                }
            }
        }
        else {
            $vmfound = "ERROR VM $client is not found in $vcenterserver"
        }

    }


    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }


    if ($vmfound -eq "INFO VM $client is found in $vcenterserver") {
        if ($vm.Name -eq "$client") {
            $pretask = get-task -Server $vcenterserver | where-object { $_.ObjectId -eq $vmid }
            $pregueststate = $vm.Guest.State
            $pretoolstate = $vm.ExtensionData.Guest.ToolsRunningStatus
            if ($pretask.State -ccontains "Queued" -or $pretask.State -ccontains "Running") {  
                $pretaskdesc = $pretask.Description
                $precheck = "Tasks in progress are " + $pretaskdesc
            }
            else {
                $precheck = $Null
            }
            if ($pregueststate -ne 'Running') {
                $precheck = "$vm is in $pregueststate state"
            }
            else {
                $precheck = $Null
            }
            if ($pretoolstate -eq 'guestToolsRunning') {
                $precheck = $Null
            }
            else {
                $precheck = "$vm vmware tools are in $pretoolstate State"
            }

            if ($precheck) {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = $precheck
                }
                else {
                    $tabaobj.Add("Prechecks", $precheck)
                }
            }
            else {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                }
                else {
                    $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                }
            }
            if (!$precheck) {
    
                try {
                    if ($vm.Guest.VmName -eq $client) {
                        if (($expectedcpu -is [int]) -and ($expectedcpu -ne 0)) { $expectedcpu = $expectedcpu }else { $expectedcpu = $vm.NumCpu }
                        if ($expectedsocket -is [int] -and ($expectedsocket -ne 0)) { $expectedsocket = $expectedsocket }else { $expectedsocket = ($vm.NumCpu / $vm.CoresPerSocket) }
                        if ($expectedmemgb -is [int] -and ($expectedmemgb -ne 0)) { $expectedmemgb = $expectedmemgb }else { $expectedmemgb = ($vm.MemoryGB) }
                    
                        If (($expectedcpu -gt $vm.NumCpu) -or ($expectedmemgb -gt $vm.MemoryGB)) {
                        
                            try {
                                If (($expectedcpu -gt $vm.NumCpu) -and ($expectedmemgb -gt $vm.MemoryGB)) {
                                    $out = get-vm -name $vm.Guest.VmName | set-vm -NumCpu $expectedcpu -Confirm:$false -ErrorAction Stop 
                                    if ($out.NumCpu -eq $expectedcpu) {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [int]$successoutcpu = $out.NumCpu.ToString()
                                        [string]$successcpustr = "Successful Configurations Old CPU Config $successcpu New CPU Config $expectedcpu"
                                    }
                                    else {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [string]$successcpustr = "UnSuccessful Configurations Old CPU Config $successcpu New CPU Config $successoutcpu"
                                  
                                    }
                                    $out = get-vm -name $vm.Guest.VmName | set-vm -MemoryGB  $expectedmemgb -Confirm:$false -ErrorAction Stop 
                                    if ($out.MemoryGB -eq $expectedmemgb) {
                                        [int]$successmemgb = $vm.MemoryGB.ToString()
                                        [int]$successoutmemgb = $out.MemoryGB.ToString()
                                        [string]$successmemstr = "Successful Configurations Old Memory Config $successmemgb New Memory Config $successoutmemgb"
                                  
                                    }
                                    else {
                                        [int]$successmemgb = $vm.MemoryGB.ToString()
                                        [int]$successoutmemgb = $out.MemoryGB.ToString()
                                        [string]$successmemstr = "UnSuccessful Configurations Old Memory Config $successmemgb New Memory Config $successoutmemgb"
                               
                                    } 
                                    [string]$finstring = $successcpustr + ' ' + $successmemstr
                                    $tabaobj.Add("VMData", $finstring)
                                }
                                elseIf ($expectedcpu -gt $vm.NumCpu) {
                                    $out = get-vm -name $vm.Guest.VmName | set-vm -NumCpu $expectedcpu -Confirm:$false -ErrorAction Stop 
                                    if ($out.NumCpu -eq $expectedcpu) {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [int]$successoutcpu = $out.NumCpu.ToString()
                                        [string]$successcpustr = "Successful Configurations Old Config $successcpu New Config $expectedcpu"
                                        $tabaobj.Add("VMData", $successcpustr)
                                    }
                                    else {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [string]$unsuccesscpustr = "UnSuccessful Configurations Old Config $successcpu New Config $successoutcpu"
                                        $tabaobj.Add("VMData", $unsuccesscpustr)
                                    }
                                }
                                elseIf ($expectedmemgb -gt $vm.MemoryGB) {
                                    $out = get-vm -name $vm.Guest.VmName | set-vm -MemoryGB  $expectedmemgb -Confirm:$false -ErrorAction Stop
                                    if ($out.MemoryGB -eq $expectedmemgb) {
                                        [int]$successmemgb = $vm.MemoryGB.ToString()
                                        [int]$successoutmemgb = $out.MemoryGB.ToString()
                                        [string]$successmemstr = "Successful Configurations Old Config $successmemgb New Config $successoutmemgb"
                                        $tabaobj.Add("VMData", $successmemstr)
                                    }
                                    else {
                                        [int]$successmemgb = $vm.MemoryGB.ToString()
                                        [int]$successoutmemgb = $out.MemoryGB.ToString()
                                        [string]$unsuccessmemstr = "UnSuccessful Configurations Old Config $successmemgb New Config $successoutmemgb"
                                        $tabaobj.Add("VMData", $unsuccessmemstr)
                                    } 
                                }
                                else {
                                    [int]$elsememgb = $vm.MemoryGB.ToString()
                                    [int]$elsenumcpu = $vm.NumCpu.ToString()
                                    [string]$elsememstr = "The values provided are not greater than existing configuarations Memory Existing $elsememgb Memory where Inputs $expectedcpu and CPU Existing $elsenumcpu where CPU Inputs $expectedcpu"
                                    $tabaobj.Add("VMData", $elsememstr)
                                }
  
                            }
                            Catch {
                                $global:configmsg = $_.Exception.Message
                                if ($global:configmsg ) {
                  
                                    $tabaobj.Add("VMData", $global:configmsg)
                                }
                                else {
                                    $tabaobj.Add("VMData", $global:configmsg)
                                }

                            }
                        }
                        else {
                            $global:configmsg = "The values provided are not greater than existing configuarations"
                            if ($global:configmsg) {
                  
                                $tabaobj.Add("VMData", $global:configmsg)
                            }
                            else {
                                $tabaobj.Add("VMData", $global:configmsg)
                            }
                        }
                    }
                }
                catch {
                    $opitmalmsg = $_.Exception.Message
                    if ($opitmalmsg) {
                        $results.GetType()
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                    else {
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                }

            }
            else {
                $precheck = "ERROR The VM $client has failed due to prechecks $precheck"
                if ($precheck) {
                    if ($tabaobj.ContainsKey("Prechecks")) {
                        $tabaobj["Prechecks"] = $precheck
                    }
                    else {
                        $tabaobj.Add("Prechecks", $precheck)
                    }
                }
                else {
                    if ($tabaobj.ContainsKey("Prechecks")) {
                        $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                    }
                    else {
                        $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                    }
                }
            }

        }
        else {
            $vmfound = "ERROR The VM $client not found in vCenter $vcenterserver"
            if ($vmfound) {
                if ($tabaobj.ContainsKey("VmStatus")) {
                    $tabaobj["VmStatus"] = $vmfound
                }
                else {
                    $tabaobj.Add("VmStatus", $vmfound)
                }
            }
        }
   
    }
    else {
        if ($vmfound) {
            if ($tabaobj.ContainsKey("VmStatus")) {
                $tabaobj["VmStatus"] = $vmfound
            }
            else {
                $tabaobj.Add("VmStatus", $vmfound)
            }
        }
    }
    $tabaobj | ConvertTo-Json
#}

#######################

################CAPACITY VNUMA CHECK##########


[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{VALID_PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{VALID_USER}'


[ValidateNotNullOrEmpty()]
[string] $vcenterserver = '$INPUT{VALID_SERVER_FQDN}'

[ValidateNotNullOrEmpty()]
[string]$client = '$INPUT{VMSDATA}'

[ValidateNotNullOrEmpty()]
[int]$expectedcpu = '$INPUT{EXCPU}'

[ValidateNotNullOrEmpty()]
[int]$expectedsocket = '$INPUT{EXSOCKET}'

[ValidateNotNullOrEmpty()]
[int]$expectedmemgb = '$INPUT{EXMEM}'

$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()
   
   
if ($vcenterserver -eq 'servervc.example.com' -or $vcenterserver -eq 'servervc.example.com' ) {
    try {
        Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false -ErrorAction Stop | Out-Null
        $configset = "INFO No proxy has been set "
    }
    catch { $configset = "ERROR Setting Proxy has failed" }  
}
else {
    $configset = "INFO No proxy has been set "
}


if ($configset) {
    $tabaobj.Add("Proxy", $configset)
}
   

if (!(Get-Module -Name VMware.VimAutomation.Core)) {
    try {
        Import-Module -Name VMware.VimAutomation.Core -ErrorAction stop
        $moduleset = "INFOVmware module has been imported"
    }
    catch { $moduleset = "ERRORVmware module has not been imported" }

    if ($moduleset) {
        $tabaobj.Add("Modules", $moduleset)
    }
    	
    if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
    else {
        try {
            $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
            $cnvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
            $connected = "INFO Connected to vcenter Server $vcenterserver"
            
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
        }
        if ($connected) {
            $tabaobj.Add("Connection", $connected)
        }
        
    }
}
else {
    try {
        $CREDENTIALS = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD
        $connectvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
        $connected = "INFO Connected to vcenter Server $vcenterserver"
    }
    catch {
        $connectmsg = $_.Exception.Message
        $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
    }


    if ($connected) {
        if ($tabaobj.ContainsKey("Connection")) {
            $tabaobj["Connection"] = $connected
        }
        else {
            $tabaobj.Add("Connection", $connected)
        }
    }
     
}


if ($connected) {
    if ($connected -notlike "ERROR Could not connect to vCenter*") {
        try {
            $vm = get-vm -Name $client -ErrorAction Stop 
            $vmid = $vm.Id
            $vmfound = "INFO VM $client is found in $vcenterserver"
        }
        catch {
            $clientmsg = $_.Exception.Message
            if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                try {
                    $decomclient = "$client-DECOM*"
                    $vm = get-vm -Name $decomclient -ErrorAction Stop 
                    $vmid = $vm.Id
                    #write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                    $vmfound = "ERROR :  VM $client in $vcenterserver is renamed for Decomission"
                }
                catch {
                    $clientmsg = $_.Exception.Message
                    #write-host "ERROR Unable to find VM $client in $vcenterserver $clientmsg"
                    $vmfound = "ERROR $clientmsg"
                }
            }
        }
    }
    else {
        $vmfound = "ERROR VM $client is not found in $vcenterserver"
    }

}


if ($vmfound) {
    if ($tabaobj.ContainsKey("VmStatus")) {
        $tabaobj["VmStatus"] = $vmfound
    }
    else {
        $tabaobj.Add("VmStatus", $vmfound)
    }
}


if ($vmfound -eq "INFO VM $client is found in $vcenterserver") {
    if ($vm.Name -eq "$client") {
        $pretask = get-task -Server $vcenterserver | where-object { $_.ObjectId -eq $vmid }
        $pregueststate = $vm.Guest.State
        $pretoolstate = $vm.ExtensionData.Guest.ToolsRunningStatus
        if ($pretask.State -ccontains "Queued" -or $pretask.State -ccontains "Running") {  
            $pretaskdesc = $pretask.Description
            $precheck = "Tasks in progress are " + $pretaskdesc
        }
        else {
            $precheck = $Null
        }
        if ($pregueststate -ne 'Running') {
            $precheck = "$vm is in $pregueststate state"
        }
        else {
            $precheck = $Null
        }
        if ($pretoolstate -eq 'guestToolsRunning') {
            $precheck = $Null
        }
        else {
            $precheck = "$vm vmware tools are in $pretoolstate State"
        }

        if ($precheck) {
            if ($tabaobj.ContainsKey("Prechecks")) {
                $tabaobj["Prechecks"] = $precheck
            }
            else {
                $tabaobj.Add("Prechecks", $precheck)
            }
        }
        else {
            if ($tabaobj.ContainsKey("Prechecks")) {
                $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
            }
            else {
                $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
            }
        }
        if (!$precheck) {
    
            try {
                function Get-OptimalvCPU {
                    [cmdletbinding()]
                    Param
                    (
                        [Parameter(Mandatory = $false)]$vmName,
                        [Parameter(Mandatory = $false)]$excpu,
                        [Parameter(Mandatory = $false)]$exsocket,
                        [Parameter(Mandatory = $false)]$exmem,
                        [Parameter(Mandatory = $false)][switch]$simple
                    )

                    $nameFilter = ""
                    $vmFilter = @{'RunTime.ConnectionState' = '^(?!disconnected|inaccessible|invalid|orphaned).*$'; 'Runtime.PowerState' = 'poweredOn'; 'Config.Template' = 'False' }
                    $hostFilter = @{'Runtime.ConnectionState' = 'connected'; 'Runtime.PowerState' = 'poweredOn' }
                    $results = @()
                    $vms = @()
                    Write-Verbose "Retrieving VMs information - Skipping Disconnected, Powered Off, or Template VMs"

                    Try {
                        If ($VMName -ne $null) {
                            foreach ($name in $VMName) {
                                $nameFilter += "$name|"
                            }
                            $nameFilter = $nameFilter.TrimEnd("|")
                            $vmFilter += @{"Name" = $nameFilter }
                        }
                        #gets VM information
                        if ($excpu -and $exsocket) {
                            $vms = get-view -ViewType VirtualMachine -Filter $vmFilter -Property Name, Config.Hardware.MemoryMB, Config.Hardware.NumCPU, Config.Hardware.NumCoresPerSocket, Config.CpuHotAddEnabled, Config.MemoryHotAddEnabled, Config.Version, Config.ExtraConfig, Runtime.Host | 
                            select-object Name, @{n = 'MemoryGB'; e = { [math]::Round(($_.Config.Hardware.MemoryMB / 1024), 2) } }, 
                            @{n = 'Sockets'; e = { ( $exsocket ) } },
                            @{n = 'CoresPerSocket'; e = { $excpu / $exsocket } }, 
                            @{n = 'NumCPU'; e = { $excpu } },
                            @{n = 'CpuHotAdd'; e = { $_.Config.CpuHotAddEnabled } },
                            @{n = 'MemHotAdd'; e = { $_.Config.MemoryHotAddEnabled } },
                            @{n = 'HWVersion'; e = { $_.Config.Version } }, @{n = 'HostId'; e = { $_.Runtime.Host.Value } },
                            @{n = 'vCenter'; e = { ([uri]$_.client.ServiceUrl).Host } }, 
                            @{n = 'NumaVcpuMin'; e = { ($_.Config.ExtraConfig | where-object { $_.Key -eq "numa.vcpu.min" }).Value } }
                        }
                        else {

                            $vms = get-view -ViewType VirtualMachine -Filter $vmFilter -Property Name, Config.Hardware.MemoryMB, Config.Hardware.NumCPU, Config.Hardware.NumCoresPerSocket, Config.CpuHotAddEnabled, Config.Version, Config.ExtraConfig, Runtime.Host | 
                            select-object Name, @{n = 'MemoryGB'; e = { [math]::Round(($_.Config.Hardware.MemoryMB / 1024), 2) } }, @{n = 'Sockets'; e = { ($_.Config.Hardware.NumCPU) / ($_.Config.Hardware.NumCoresPerSocket) } }, @{n = 'CoresPerSocket'; 
                                e                                                                                                                                                                                                 = { $_.Config.Hardware.NumCoresPerSocket }
                            }, @{n = 'NumCPU'; e = { $_.Config.Hardware.NumCPU } }, @{n = 'CpuHotAdd'; e = { $_.Config.CpuHotAddEnabled } }, @{n = 'MemHotAdd'; e = { $_.Config.MemoryHotAddEnabled } }, @{n = 'HWVersion'; e = { $_.Config.Version } }, @{n = 'HostId';
                                e                                                                                                                                                                = { $_.Runtime.Host.Value }
                            }, @{n = 'vCenter'; e = { ([uri]$_.client.ServiceUrl).Host } }, @{n = 'NumaVcpuMin'; e = { ($_.Config.ExtraConfig | where-object { $_.Key -eq "numa.vcpu.min" }).Value } } 
                        }
                        If ($vms -eq $null) {
                            Throw "No VMs found, or VMs are not powered on, or connected"
                        }
                    }
                    Catch {
                        Write-Error -Message "Error retrieving VM information: $($_.Exception.Message) at line $($_.InvocationInfo.ScriptLineNumber)"
                        break
                    }
    
                    Try {
                        Write-Verbose "Retrieving Host information. Skipping Disconnected or Powered Off Hosts"
                        If ($VMName -ne $null) {
                            $hostsUnique = $vms | Select @{n = "Id"; e = { "HostSystem-" + "$($_.HostId)" } }, vCenter | Sort-Object -Property @{e = "Id" }, @{e = "vCenter" } -Unique
                            $hostCommand = { get-view -Id $($hostsUnique.Id) -Property Name, Parent, Config.Product.Version, Config.HyperThread, Hardware.MemorySize, Hardware.CpuInfo, Config.PowerSystemInfo.CurrentPolicy.Key, Config.Option }
                        }
                        Else {
                            $hostCommand = { get-view -ViewType HostSystem -Filter $hostFilter -Property Name, Parent, Config.Product.Version, Config.HyperThread, Hardware.MemorySize, Hardware.CpuInfo, Config.PowerSystemInfo.CurrentPolicy.Key, Config.Option }
                        }
    
                        $vmHosts = Invoke-Command $hostCommand | select-object Name, @{n = 'Id'; e = { $_.MoRef.Value } }, @{n = 'Version'; e = { $_.Config.Product.Version } }, @{n = 'vCenter'; e = { ([uri]$_.Client.serviceurl).Host } }, @{n = "ClusterId";
                            e                                                                                                                                                                                                              = { $_.Parent | where-object { $_.Type -eq "ClusterComputeResource" } | select-object -expand Value }
                        }, @{n = 'MemoryGB'; e = { [int](($_.Hardware.MemorySize) / 1073741824) } }, @{n = "MemPerChannel";
                            e                                                                            = { [int](($_.Hardware.MemorySize) / 1073741824) / ($_.Hardware.CpuInfo.NumCpuPackages) }
                        }, @{n = 'Sockets'; e = { ($_.Hardware.CpuInfo.NumCpuPackages) } }, @{n = 'CoresPerSocket';
                            e                                                                   = { ($_.Hardware.CpuInfo.NumCPUCores) / $($_.Hardware.CpuInfo.NumCpuPackages) }
                        }, @{n = 'CPUs'; e = { $_.Hardware.CpuInfo.NumCPUCores } }, @{n = 'CpuThreads'; e = { ($_.Hardware.CpuInfo.NumCpuThreads) } }, @{n = 'HTActive';
                            e                                                                                                                              = { $_.Config.HyperThread.Active }
                        }, @{n = 'NumaVcpuMin'; e = { $_.Config.Option | where-object { $_.Key -eq "numa.vcpu.min" } } }, @{n = 'PowerPolicy'; 
                            e                                                                                          = {
                                switch ($_.Config.PowerSystemInfo.CurrentPolicy.Key) {
                                    "1" { "HighPerformance" }
                                    "2" { "Balanced" }
                                    "3" { "LowPower" }
                                    "4" { "Custom" }
                                }
                            }
                        }
                    }
                    Catch {
                        Write-Error -Message "Error retrieving Host information: $($_.Exception.Message) at line $($_.InvocationInfo.ScriptLineNumber)"
                        break
                    }

                    Try {
                        Write-Verbose "Retrieving Cluster information" 
                        $clustersUnique = $vmHosts | where-object { $_.ClusterId -ne $null } | Select @{n = "Id"; e = { "ClusterComputeResource-" + "$($_.ClusterId)" } }, vCenter | Sort-Object -Property @{e = "Id" }, @{e = "vCenter" } -Unique
                        #accounts for hosts with no cluster
                        If ($clustersUnique -ne $Null) {
                            $clusters = get-view -Id $($clustersUnique.Id) -Property Name | Select Name, @{n = "Id"; e = { $_.MoRef.Value } }, @{n = "vCenter";
                                e                                                                                                                  = { ([uri]$_.Client.serviceurl).Host }
                            }, MinMemoryGB, MinSockets, MinCoresPerSocket -ErrorAction Stop
 
                            foreach ($cluster in $clusters) {
                                $clusterHosts = $vmHosts | where-object { ($_.vCenter -eq $cluster.vCenter) -and $_.clusterID -eq $cluster.Id } | select-object Name, Id, MemoryGB, Sockets, CoresperSocket
                                $cluster.MinMemoryGB = ($clusterHosts.MemoryGB | measure-object -Minimum).Minimum
                                $cluster.MinSockets = ($clusterHosts.Sockets | measure-object -Minimum).Minimum
                                $cluster.MinCoresPerSocket = ($clusterHosts.CoresPerSocket | measure-object -Minimum).Minimum
                            }
                        }
                    }
                    Catch {
                        Write-Error -Message "Error retrieving Cluster information: $($_.Exception.Message) at line $($_.InvocationInfo.ScriptLineNumber)"
                        break
                    }

                    #process VM calculations
                    $vmCount = ($vms | Measure-Object).Count
                    Write-Verbose "Calculating Optimal vCPU settings for $vmCount VMs"
                    $n = 1
                    foreach ($vm in $vms) {
                        $vmsPercent = [math]::Round(($n / $vmCount) * 100)
                        Write-Progress -Activity "Calculating Optimum vCPU Config for VMs" -Status "$vmsPercent% Complete:" -PercentComplete $vmsPercent -CurrentOperation "Current VM: $($vm.Name)"
            
                        $priorities = @() 
                        $priorities += 0   
                        $details = ""
                        $pNumaNotExpDetails = ""

                        $vmHost = $vmHosts | where-object { $($_.vCenter) -eq $($vm.vCenter) -and $($_.Id) -eq $($vm.HostId) } | select-object -first 1

                        If ($vmHost.ClusterId -eq $null) {
                            $cluster = "" | Select Name, MinMemoryGB, MinSockets, MinCoresPerSocket
                        }
                        Else {
                            $cluster = $clusters | where-object { ($($_.Id) -eq $($vmHost.ClusterId)) -and ($($_.vCenter) -eq $($vmHost.vCenter)) } | Select Name, MinMemoryGB, MinSockets, MinCoresPerSocket | select-object -first 1
                        }
                        Try {
                            #flags if vmMemory spans pNUMA node
                            If ($vm.MemoryGB -gt $vmHost.MemPerChannel) {
                                $memWide = $true
                                $memWideDetail = "memory"
                            }
                            Else {
                                $memWide = $false
                                $memWideDetail = ""
                            } 
                            #flags if vCPUs span pNUMA node
                            If ($vm.NumCPU -gt $vmHost.CoresPerSocket) {
                                $cpuWide = $true
                                $cpuWideDetail = "CPU"
                            }
                            Else {
                                $cpuWide = $false
                                $cpuWideDetail = ""
                            }
        
                            #if #vCPUs is odd and crosses pNUMA nodes
                            If (($memWide -or $cpuWide) -and (($vm.NumCPU % 2) -ne 0)) {
                                $calcVmCPUs = $vm.NumCPU + 1
                                $cpuOdd = $true
                            }
                            Else {
                                $calcVmCPUs = $vm.NumCPU
                                $cpuOdd = $false
                            }
                            #calculations for optimal vCPU
                            $i = 0
                            Do {
                                $i++
                            }
                            Until (
                                (($vm.MemoryGB / $i -le $vmHost.MemPerChannel) -or ($calcVmCPUs / $i -eq 1)) `
                                    -and (($calcVmCPUs / $i -le $vmHost.CoresPerSocket) -or ($calcVmCPUs / $i -eq 1) -or ($calcVmCPUs -eq $vmHost.CPUs)) `
                                    -and (($calcVmCPUs / $i) % 2 -eq 0 -or ($calcVmCPUs / $i) % 2 -eq 1)
                            )
                            $optSockets = $i
                            $optCoresPerSocket = $calcVmCPUs / $optSockets
                            #flags if adjustments had to be made to the vCPUs
                            If (($optSockets -ne $vm.Sockets) -or ($optCoresPerSocket -ne $vm.CoresPerSocket) -or $cpuOdd) {
                                $cpuOpt = $false
                            }
                            Else {
                                $cpuOpt = $true
                            }
                            #vCPUs are not optimal, but VM is not wide
                            If (-not ($memWide -or $cpuWide) -and (-not $cpuOpt)) {
                                $details += "VM does not span pNUMA nodes, but consider configuring it to match pNUMA architecture | "
                                $priorities += 1
                            }

                            ######################################################
                            #if crossing pNUMA node(s), additional flags
                            If (($memWide -or $cpuWide) -and (-not $cpuOpt)) {
                                If ($memWideDetail -ne "" -and $cpuWideDetail -ne "") {
                                    $wideDetails = "$memWideDetail and $cpuWideDetail"
                                }
                                Else {
                                    $wideDetails = ("$memWideDetail $cpuWideDetail").Trim()
                                }
                                $details += "VM $wideDetails spans pNUMA nodes and should be distributed evenly across as few as possible | "
            
                                #flags if VM is crossing pNUMA nodes, and vHW version is less than 8 (pNUMA not exposed to guest) 
                                $vmHWVerNo = [int]$vm.HWVersion.Split("-")[1]
                                If ($vmHWVerNo -lt 8) {
                                    $pNumaNotExp = $true
                                    $pNumaNotExpDetails = "(vHW < 8) "
                                }
                                #flags if VM is crossing pNUMA nodes, and CPUHotAdd is enabled (pNUMA not exposed to guest) 
                                If ($vm.CpuHotAdd -eq $true) {
                                    $pNumaNotExp = $true
                                    $pNumaNotExpDetails = $pNumaNotExpDetails + " (CpuHotAddEnabled = TRUE)"
                                }
                                #flags if VM is crossing pNUMA nodes, and vCPUs is less than 9 (pNUMA not exposed to guest)
                                If ($vm.NumCPU -lt 9 -and $vm.NumaVcpuMin -eq $null -and $vmHost.NumaVcpuMin -eq $null) {
                                    $pNumaNotExp = $true
                                    $pNumaNotExpDetails = $pNumaNotExpDetails + " (vCPUs < 9). Consider modifying advanced setting ""Numa.Vcpu.Min"" to $($vm.NumCPU) or lower. "
 
                                }
                                #if NumaVcpuMin has been modified
                                Elseif ($vm.NumaVcpuMin -ne $null -or $vmHost.NumaVcpuMin -ne $null) {
                                    If ($vm.NumaVcpuMin -ne $null) {
                                        $modVM = "VMValue: $($vm.NumaVcpuMin) "
                                    }
                                    ElseIf ($vmHost.NumaVcpuMin -ne $null) {
                                        $modHost = "HostValue: $($vmHost.NumaVcpuMin)"
                                    }
                                    $modDetail = ("$modVM, $modHost").Trim(", ")

                                    switch ($vm.NumaVcpuMin -le $vm.NumCPU -or $vmHost.NumaVcpuMin -le $vm.NumCPU) {
                                        $true { $details += "vCPUs < 9, but advanced setting ""Numa.Vcpu.Min"" has been modified ($modDetail) to expose pNUMA to guest OS | " }
                                        $false {
                                            $pNumaNotExp = $true
                                            $pNumaNotExpDetails = $pNumaNotExpDetails + " (Advanced setting ""Numa.Vcpu.Min"" is > VM vCPUs). The setting has been modified ($modDetail), but is still higher than VM vCPUs. Change the value to $($vm.NumCPU) or lower to expose pNUMA to the guest OS"
                                        }
                                    }
                                }
                                If ($pNumaNotExp) {
                                    $pNumaNotExpDetails = $pNumaNotExpDetails.Trim() 
                                    $details += "VM spans pNUMA nodes, but pNUMA is not exposed to the guest OS: $pNumaNotExpDetails | "
                                }
             
                                #flags if VM has odd # of vCPUs and spans pNUMA nodes
                                If ($cpuOdd) {
                                    $details += "VM has an odd number of vCPUs and spans pNUMA nodes | "
                                }
                                $priorities += 3
                            }#end if (($memWide -or $cpuWide) -and (-not $cpuOpt))

                            #flags if hosts in a cluster are of different size memory or CPU
                            If (($vmHost.MemoryGB -ne $cluster.MinMemoryGB -or $vmHost.Sockets -ne $cluster.MinSockets -or $vmHost.CoresPerSocket -ne $cluster.MinCoresPerSocket) -and $cluster.MinMemoryGB -ne "") {
                                $details += "Host hardware in the cluster is inconsistent. Consider sizing VMs based on the minimums for the cluster | "
                                $priorities += 2
                            }
                            #flags VMs with CPU count higher than physical cores
                            If ($vm.NumCPU -gt ($vmHost.Sockets * $vmHost.CoresPerSocket)) {
                                $optSockets = $hostSockets
                                $optCoresPerSocket = $vmHost.CoresPerSocket
                                $priorities += 2
                                $details += "VM vCPUs exceed the host's physical cores. Consider reducing the number of vCPUs | "
                            }
                            #flags if vCPU count is > 8 and Host PowerPolicy is not "HighPerformance"
                            If ($vm.NumCPU -gt 8 -and $vmHost.PowerPolicy -ne "HighPerformance" -and $vmHost.PowerPolicy -ne "N/A") {
                                #$priorities += 2
                                $details += 'Consider changing the host Power Policy to "High Performance" for clusters with VMs larger than 8 vCPUs | '
                            } 
  
                            #gets highest priority
                            $highestPriority = ($priorities | measure-object -Maximum).Maximum
                            Switch ($highestPriority) {
                                0 { $priority = "N/A" }
                                1 { $priority = "LOW" }
                                2 { $priority = "MEDIUM" }
                                3 { $priority = "HIGH" }
                            }

                            #flags whether the VM is configured optimally or not
                            If ($priority -eq "N/A") {
                                $vmOptimized = "YES"
                            }
                            Else {
                                $vmOptimized = "NO"
                            }
                            #creates object with data to return from function
                            If ($simple -eq $true) {
                                $objInfo = [pscustomobject]@{
                                    VMName                = $($vm.Name);
                                    VMSockets             = $($vm.Sockets);
                                    VMCoresPerSocket      = $($vm.CoresPerSocket);
                                    vCPUs                 = $($vm.NumCPU);
                                    VMOptimized           = $vmOptimized;
                                    OptimalSockets        = $optSockets;
                                    OptimalCoresPerSocket = $optCoresPerSocket;
                                    Priority              = $priority;
                                    Details               = $details.Trim("| ")
                                } #end pscustomobject
                            }
                            Else {
                                $objInfo = [pscustomobject]@{
                                    vCenter                  = $($vmHost.vCenter);
                                    Cluster                  = $($cluster.Name);
                                    ClusterMinMemoryGB       = $($cluster.MinMemoryGB);
                                    ClusterMinSockets        = $($cluster.MinSockets);
                                    ClusterMinCoresPerSocket = $($cluster.MinCoresPerSocket);
                                    HostName                 = $($vmHost.Name);
                                    ESXi_Version             = $($vmHost.Version);
                                    HostMemoryGB             = $($vmHost.MemoryGB);
                                    HostSockets              = $($vmHost.Sockets);
                                    HostCoresPerSocket       = $($vmHost.CoresPerSocket);
                                    HostCpuThreads           = $($vmHost.CpuThreads);
                                    HostHTActive             = $($vmHost.HTActive);
                                    HostPowerPolicy          = $($vmHost.PowerPolicy);
                                    VMName                   = $($vm.Name);
                                    VMHWVersion              = $($vm.HWVersion);
                                    VMCpuHotAddEnabled       = $($vm.CpuHotAdd).ToString();
                                    VMMemHotAddEnabled       = $($vm.MemHotAdd).ToString();               
                                    VMMemoryGB               = $($vm.MemoryGB);
                                    VMSockets                = $($vm.Sockets);
                                    VMCoresPerSocket         = $($vm.CoresPerSocket);
                                    vCPUs                    = $($vm.NumCPU);
                                    VMOptimized              = $vmOptimized;
                                    OptimalSockets           = $optSockets;
                                    OptimalCoresPerSocket    = $optCoresPerSocket; ;
                                    Priority                 = $priority;
                                    Details                  = $details.Trim("| ")
                                } #end pscustomobject
                            }
                            $results += $objInfo
                        }
                        Catch {
                            Write-Error "Error calculationing optimal CPU for $($vm.Name): $($_.Exception.Message) at line $($_.InvocationInfo.ScriptLineNumber)"
                        }
                        $n++
                    }#end foreach ($vm in $vms)
                    Write-Progress -Activity "Calculating Optimum vCPU Config for VMs" -Completed
                    $global:optimal = $results
                }
                if ($vm.Guest.VmName -eq $client) {
                    if (($expectedcpu -is [int]) -and ($expectedcpu -ne 0)) { $expectedcpu = $expectedcpu }else { $expectedcpu = $vm.NumCpu }
                    if ($expectedsocket -is [int] -and ($expectedsocket -ne 0)) { $expectedsocket = $expectedsocket }else { $expectedsocket = ($vm.NumCpu / $vm.CoresPerSocket) }
                    if ($expectedmemgb -is [int] -and ($expectedmemgb -ne 0)) { $expectedmemgb = $expectedmemgb }else { $expectedmemgb = ($vm.MemoryGB) }
                    try
                    {
                      Get-OptimalvCPU -vmName $vm -excpu $expectedcpu -exsocket $expectedsocket -exmem $expectedmemgb
                    }
                    catch{
                    	$msg=$_.Exception.Message
                    	$tabaobj.Add("VMData", "$msg")	
                    }
                    if ($global:optimal) {
                    	#write-host "Optimal values"
    					#$global:optimal.VMOptimized
    					#$global:optimal.OptimalSockets
    					#$global:optimal.OptimalCoresPerSocket
                        $tabaobj.Add("VMData", $global:optimal)
                        
                    }
                    else {
                        $tabaobj.Add("VMData", "ERROR Failed to Evaluate")
                    }
                }
                else {
                    $opitmalmsg = "ERROR The VM $client not found in vCenter $vcenterserver"
                    if ($global:optimal) {
                        $results.GetType()
                        $tabaobj.Add("VMData", $global:optimal)
                    }
                    else {
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                }
            }
            catch {
                $opitmalmsg = $_.Exception.Message
                if ($global:optimal) {
                    $results.GetType()
                    $tabaobj.Add("VMData", $global:optimal)
                }
                else {
                    $tabaobj.Add("VMData", $opitmalmsg)
                }
            }

        }
        else {
            $precheck = "ERROR The VM $client has failed due to prechecks $precheck"
            if ($precheck) {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = $precheck
                }
                else {
                    $tabaobj.Add("Prechecks", $precheck)
                }
            }
            else {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                }
                else {
                    $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                }
            }
        }

    }
    else {
        $vmfound = "ERROR The VM $client not found in vCenter $vcenterserver"
        if ($vmfound) {
            if ($tabaobj.ContainsKey("VmStatus")) {
                $tabaobj["VmStatus"] = $vmfound
            }
            else {
                $tabaobj.Add("VmStatus", $vmfound)
            }
        }
    }
   
}
else {
    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }
}
$tabaobj | ConvertTo-Json


#####################################################

###############CAPACITY SHUTDOWN###########


#$ErrorActionPreference = "silentlycontinue"

[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{VALID_PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{VALID_USER}'


[ValidateNotNullOrEmpty()]
[string] $vcenterserver = '$INPUT{VALID_SERVER_FQDN}'

[ValidateNotNullOrEmpty()]
[string]$client = '$INPUT{VMSDATA}'

[ValidateNotNullOrEmpty()]
[int]$expectedcpu = '$INPUT{EXCPU}'

[ValidateNotNullOrEmpty()]
[int]$expectedsocket = '$INPUT{EXSOCKET}'

[ValidateNotNullOrEmpty()]
[int]$expectedmemgb = '$INPUT{EXMEM}'


$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()

$tabaobj.Add("ActionTask", "VM SHUTDOWN")

#if ($client -eq 'EXAMPLESERVER') {
   
    if ($vcenterserver -eq 'EXAMPLEVC1' -or $vcenterserver -eq 'EXAMPLEVC2') {
        try {
            Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false -ErrorAction Stop | Out-Null
            $configset = "INFO No proxy has been set "
        }
        catch { $configset = "ERROR Setting Proxy has failed" }  
    }
    else {
        $configset = "INFO No proxy has been set "
    }
	
	
    if ($configset) {
        $tabaobj.Add("Proxy", $configset)
    }
   

    if (!(Get-Module -Name VMware.VimAutomation.Core)) {
        try {
            Import-Module -Name VMware.VimAutomation.Core -ErrorAction stop
            $moduleset = "INFOVmware module has been imported"
        }
        catch { $moduleset = "ERRORVmware module has not been imported" }

        if ($moduleset) {
            $tabaobj.Add("Modules", $moduleset)
        }
    	
        if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
        else {
            try {
                $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
                $cnvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
                $connected = "INFO Connected to vcenter Server $vcenterserver"
            
            }
            catch {
                $connectmsg = $_.Exception.Message
                $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
            }
            if ($connected) {
                $tabaobj.Add("Connection", $connected)
            }
        
        }
    }
    else {
        try {
            $CREDENTIALS = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD
            $connectvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
            $connected = "INFO Connected to vcenter Server $vcenterserver"
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
        }


        if ($connected) {
            if ($tabaobj.ContainsKey("Connection")) {
                $tabaobj["Connection"] = $connected
            }
            else {
                $tabaobj.Add("Connection", $connected)
            }
        }
     
    }


    if ($connected) {
        if ($connected -notlike "ERROR Could not connect to vCenter*") {
            try {
                $vm = get-vm -Name $client -ErrorAction Stop 
                $vmid = $vm.Id
                $vmfound = "INFO VM $client is found in $vcenterserver"
            }
            catch {
                $clientmsg = $_.Exception.Message
                if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                    try {
                        $decomclient = "$client-DECOM*"
                        $vm = get-vm -Name $decomclient -ErrorAction Stop 
                        $vmid = $vm.Id
                        #write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                        $vmfound = "ERROR :  VM $client in $vcenterserver is renamed for Decomission"
                    }
                    catch {
                        $clientmsg = $_.Exception.Message
                        #write-host "ERROR Unable to find VM $client in $vcenterserver $clientmsg"
                        $vmfound = "ERROR $clientmsg"
                    }
                }
            }
        }
        else {
            $vmfound = "ERROR VM $client is not found in $vcenterserver"
        }

    }


    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }


    if ($vmfound -eq "INFO VM $client is found in $vcenterserver") {
        if ($vm.Name -eq "$client") {
            $pretask = get-task -Server $vcenterserver | where-object { $_.ObjectId -eq $vmid }
            $pregueststate = $vm.Guest.State
            $pretoolstate = $vm.ExtensionData.Guest.ToolsRunningStatus
            if ($pretask.State -ccontains "Queued" -or $pretask.State -ccontains "Running") {  
                $pretaskdesc = $pretask.Description
                $precheck = "Tasks in progress are " + $pretaskdesc
            }
            else {
                $precheck = $Null
            }
            if ($pregueststate -ne 'Running') {
                $precheck = "$vm is in $pregueststate state"
            }
            else {
                $precheck = $Null
            }
            if ($pretoolstate -eq 'guestToolsRunning') {
                $precheck = $Null
            }
            else {
                $precheck = "$vm vmware tools are in $pretoolstate State"
            }

            if ($precheck) {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = $precheck
                }
                else {
                    $tabaobj.Add("Prechecks", $precheck)
                }
            }
            else {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                }
                else {
                    $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                }
            }
            if (!$precheck) {
    
                try {
				#Initiate Shutdown                    
                    if ($vm.Guest.VmName -eq $client) {

                    try { 
                        if ($vm.PowerState -eq "PoweredOn") {
                        $job = Get-VM -Name $vm.Guest.VmName | Shutdown-VMGuest -Confirm:$false -ErrorAction Stop 
                        # Wait for Shutdown to complete
                        do {
                            #Wait 5 seconds
                            Start-Sleep -s 5
  							$pstatus = Get-VM -Name $vm.Guest.VmName | Select -ExpandProperty PowerState
 						}until($pstatus -eq "PoweredOff")
                            $vmstring = $vm.Guest.VmName
                            if ($pstatus -eq "Poweredoff") {
                                
                                [string]$successshutdownstr = "Shutdown Successfully performed in server $vmstring for reconfiguration"
                            } 
                            else {
                                [string]$successshutdownstr = "Shutdown Unsuccessfull in server $vmstring for reconfiguration"
                               
                            }
                            if ($tabaobj.ContainsKey("VMData")) {
                                $tabaobj["VMData"] = $successshutdownstr
                            }
                            else {
                                $tabaobj.Add("VMData", $successshutdownstr)
                            }

                           }
                        elseif ($vm.PowerState -eq "PoweredOff") {
							#start
                            $wd = "PowerOff already occured in server $($vm.Guest.VmName)"
                            if ($tabaobj.ContainsKey("VMData")) {
                                $tabaobj["VMData"] = $wd
                            }
                            else {
                                $tabaobj.Add("VMData", $wd)
                            }
						}
}
                    
                     Catch {
                                $global:configmsg = $_.Exception.Message
                                #cut
                                if ($global:configmsg ) {
		                            if ($tabaobj.ContainsKey("VMData")) {
                                    $tabaobj["VMData"] = $global:configmsg
                                    }
                                    else {
                                    $tabaobj.Add("VMData", $global:configmsg)
                                    }
                                    }
                                #cut
                            }
                    }
                     else {
                            $global:configmsg = "Shutdown action unable to perform in $client"
                            if ($global:configmsg) {
		                        if ($tabaobj.ContainsKey("VMData")) {
                                    $tabaobj["VMData"] = $global:configmsg
                                }
                                else {
                                      $tabaobj.Add("VMData", $global:configmsg)
                                }
                            }
                        }
                 
                }
                
   								
                catch {
                    $opitmalmsg = $_.Exception.Message
                    if ($opitmalmsg) {
                    	if ($tabaobj.ContainsKey("VMData")) {
                        $tabaobj["VMData"] = $opitmalmsg
                    	}
                    else {
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                	}
                    
                }

            }
            
            else {
                $precheck = "ERROR The VM $client has failed due to prechecks $precheck"
                if ($precheck) {
                    if ($tabaobj.ContainsKey("Prechecks")) {
                        $tabaobj["Prechecks"] = $precheck
                    }
                    else {
                        $tabaobj.Add("Prechecks", $precheck)
                    }
                }
                else {
                    if ($tabaobj.ContainsKey("Prechecks")) {
                        $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                    }
                    else {
                        $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                    }
                }
            }

        }
        else {
            $vmfound = "ERROR The VM $client not found in vCenter $vcenterserver"
            if ($vmfound) {
                if ($tabaobj.ContainsKey("VmStatus")) {
                    $tabaobj["VmStatus"] = $vmfound
                }
                else {
                    $tabaobj.Add("VmStatus", $vmfound)
                }
            }
        }
   
    }
    $tabaobj | ConvertTo-Json
    DisConnect-VIServer $vcenterserver -Confirm:$false  -Force  -ErrorAction Stop
#}


####################

##########CAPACITY ADD(NON HOT ADD)###########


#$ErrorActionPreference = "silentlycontinue"

[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{VALID_PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{VALID_USER}'


[ValidateNotNullOrEmpty()]
[string] $vcenterserver = '$INPUT{VALID_SERVER_FQDN}'

[ValidateNotNullOrEmpty()]
[string]$client = '$INPUT{VMSDATA}'

[ValidateNotNullOrEmpty()]
$expectedcpu = '$INPUT{EXCPU}'

[ValidateNotNullOrEmpty()]
$expectedsocket = '$INPUT{EXSOCKET}'

[ValidateNotNullOrEmpty()]
[int]$expectedmemgb = '$INPUT{EXMEM}'


$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()

[int]$expectedcpu    = $expectedcpu.Replace('[','').Replace(']','').Trim()

[int]$expectedsocket = $expectedsocket.Replace('[','').Replace(']','').Trim()


$tabaobj.Add("ActionTask", "VM RECONFIG")

#if ($client -eq 'sampleserver') {
   
    if ($vcenterserver -eq 'samplevc' ) {
        try {
            Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false -ErrorAction Stop | Out-Null
            $configset = "INFO No proxy has been set "
        }
        catch { $configset = "ERROR Setting Proxy has failed" }  
    }
    else {
        $configset = "INFO No proxy has been set "
    }


    if ($configset) {
        $tabaobj.Add("Proxy", $configset)
    }
   

    if (!(Get-Module -Name VMware.VimAutomation.Core)) {
        try {
            Import-Module -Name VMware.VimAutomation.Core -ErrorAction stop
            $moduleset = "INFOVmware module has been imported"
        }
        catch { $moduleset = "ERRORVmware module has not been imported" }

        if ($moduleset) {
            $tabaobj.Add("Modules", $moduleset)
        }
    	
        if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
        else {
            try {
                $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
                $cnvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
                $connected = "INFO Connected to vcenter Server $vcenterserver"
            
            }
            catch {
                $connectmsg = $_.Exception.Message
                $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
            }
            if ($connected) {
                $tabaobj.Add("Connection", $connected)
            }
        
        }
    }
    else {
        try {
            $CREDENTIALS = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD
            $connectvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
            $connected = "INFO Connected to vcenter Server $vcenterserver"
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
        }


        if ($connected) {
            if ($tabaobj.ContainsKey("Connection")) {
                $tabaobj["Connection"] = $connected
            }
            else {
                $tabaobj.Add("Connection", $connected)
            }
        }
     
    }


    if ($connected) {
        if ($connected -notlike "ERROR Could not connect to vCenter*") {
            try {
                $vm = get-vm -Name $client -ErrorAction Stop 
                $vmid = $vm.Id
                $vmfound = "INFO VM $client is found in $vcenterserver"
            }
            catch {
                $clientmsg = $_.Exception.Message
                if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                    try {
                        $decomclient = "$client-DECOM*"
                        $vm = get-vm -Name $decomclient -ErrorAction Stop 
                        $vmid = $vm.Id
                        #write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                        $vmfound = "ERROR :  VM $client in $vcenterserver is renamed for Decomission"
                    }
                    catch {
                        $clientmsg = $_.Exception.Message
                        #write-host "ERROR Unable to find VM $client in $vcenterserver $clientmsg"
                        $vmfound = "ERROR $clientmsg"
                    }
                }
            }
        }
        else {
            $vmfound = "ERROR VM $client is not found in $vcenterserver"
        }

    }


    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }


    if ($vmfound -eq "INFO VM $client is found in $vcenterserver") {
        if ($vm.Name -eq "$client") {
            if ($vm.PowerState -eq "PoweredOn") {  
                $precheck = "VM still Poweron"
            }
            else {
                $precheck = $Null
            }
            if ($precheck) {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = $precheck
                }
                else {
                    $tabaobj.Add("Prechecks", $precheck)
                }
            }
            else {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                }
                else {
                    $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                }
            }
            if (!$precheck) {
    
                try {
                    if ($vm.Guest.VmName -eq $client) {
                        if (($expectedcpu -is [int]) -and ($expectedcpu -ne 0)) { $expectedcpu = $expectedcpu }else { $expectedcpu = $vm.NumCpu }
                        if ($expectedsocket -is [int] -and ($expectedsocket -ne 0)) { $expectedsocket = $expectedsocket }else { $expectedsocket = ($vm.NumCpu / $vm.CoresPerSocket) }
                        if ($expectedmemgb -is [int] -and ($expectedmemgb -ne 0)) { $expectedmemgb = $expectedmemgb }else { $expectedmemgb = ($vm.MemoryGB) }
                        If (($expectedcpu -gt $vm.NumCpu) -or ($expectedmemgb -gt $vm.MemoryGB) -or ($expectedsocket -gt $vm.CoresPerSocket)) {
                        
                            try {
                                If (($expectedcpu -gt $vm.NumCpu) -and ($expectedmemgb -gt $vm.MemoryGB) -and ($expectedsocket -gt $vm.CoresPerSocket)) {
                                    $VMSpec = New-Object -Type VMware.Vim.VirtualMAchineConfigSpec
                                    $VMSpec.NumCoresPerSocket   = $expectedsocket
                                    $VMSpec.CpuHotAddEnabled    = "True"
                                    $VMSpec.MemoryHotAddEnabled = "True"
                                    $specout = $vm.ExtensionData.ReconfigVM_Task($VMSpec)
                                    $out = get-vm -name $vm.Guest.VmName | set-vm -NumCpu $expectedcpu -Confirm:$false -ErrorAction Stop 
                                    if (($out.NumCpu -eq $expectedcpu) -and ($specout)) {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [int]$successoutcpu = $out.NumCpu.ToString()
                                        [string]$successcpustr = "Successful Configurations Old CPU Config $successcpu New CPU Config $expectedcpu"
                                    }
                                    else {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [string]$successcpustr = "UnSuccessful Configurations Old CPU Config $successcpu New CPU Config $successoutcpu"
                                  
                                    }
                                    $out = get-vm -name $vm.Guest.VmName | set-vm -MemoryGB  $expectedmemgb -Confirm:$false -ErrorAction Stop 
                                    if (($out.MemoryGB -eq $expectedmemgb) -and ($specout)) {
                                        [int]$successmemgb = $vm.MemoryGB.ToString()
                                        [int]$successoutmemgb = $out.MemoryGB.ToString()
                                        [string]$successmemstr = "Successful Configurations Old Memory Config $successmemgb New Memory Config $successoutmemgb"
                                  
                                    }
                                    else {
                                        [int]$successmemgb = $vm.MemoryGB.ToString()
                                        [int]$successoutmemgb = $out.MemoryGB.ToString()
                                        [string]$successmemstr = "UnSuccessful Configurations Old Memory Config $successmemgb New Memory Config $successoutmemgb"
                               
                                    } 
                                    [string]$finstring = $successcpustr + ' ' + $successmemstr
                                    $tabaobj.Add("VMData", $finstring)
                                }
                                elseIf (($expectedcpu -gt $vm.NumCpu) -and ($expectedsocket -gt $vm.CoresPerSocket)) {
                                    $VMSpec = New-Object -Type VMware.Vim.VirtualMAchineConfigSpec
                                    $VMSpec.NumCoresPerSocket   = $expectedsocket
                                    $VMSpec.CpuHotAddEnabled    = "True"
                                    $VMSpec.MemoryHotAddEnabled = "True"
                                    $specout = $vm.ExtensionData.ReconfigVM_Task($VMSpec)
                                     $out = get-vm -name $vm.Guest.VmName | set-vm -NumCpu $expectedcpu -Confirm:$false -ErrorAction Stop 
                                    if (($out.NumCpu -eq $expectedcpu) -and ($specout)) {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [int]$successoutcpu = $out.NumCpu.ToString()
                                        [string]$successcpustr = "Successful Configurations Old Config $successcpu New Config $expectedcpu"
                                        $tabaobj.Add("VMData", $successcpustr)
                                    }
                                    else {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [string]$unsuccesscpustr = "UnSuccessful Configurations Old Config $successcpu New Config $successoutcpu"
                                        $tabaobj.Add("VMData", $unsuccesscpustr)
                                    }
                                }
                                elseIf (($expectedcpu -gt $vm.NumCpu) -and ($expectedmemgb -gt $vm.MemoryGB)) {
                                    $VMSpec = New-Object -Type VMware.Vim.VirtualMAchineConfigSpec
                                    $VMSpec.CpuHotAddEnabled    = "True"
                                    $VMSpec.MemoryHotAddEnabled = "True"
                                    $specout = $vm.ExtensionData.ReconfigVM_Task($VMSpec)
                                    $out = get-vm -name $vm.Guest.VmName | set-vm -NumCpu $expectedcpu -Confirm:$false -ErrorAction Stop 
                                    if (($out.NumCpu -eq $expectedcpu) -and ($specout)) {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [int]$successoutcpu = $out.NumCpu.ToString()
                                        [string]$successcpustr = "Successful Configurations Old CPU Config $successcpu New CPU Config $expectedcpu"
                                    }
                                    else {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [string]$successcpustr = "UnSuccessful Configurations Old CPU Config $successcpu New CPU Config $successoutcpu"
                                  
                                    }
                                    $out = get-vm -name $vm.Guest.VmName | set-vm -MemoryGB  $expectedmemgb -Confirm:$false -ErrorAction Stop 
                                    if (($out.MemoryGB -eq $expectedmemgb) -and ($specout)) {
                                        [int]$successmemgb = $vm.MemoryGB.ToString()
                                        [int]$successoutmemgb = $out.MemoryGB.ToString()
                                        [string]$successmemstr = "Successful Configurations Old Memory Config $successmemgb New Memory Config $successoutmemgb"
                                  
                                    }
                                    else {
                                        [int]$successmemgb = $vm.MemoryGB.ToString()
                                        [int]$successoutmemgb = $out.MemoryGB.ToString()
                                        [string]$successmemstr = "UnSuccessful Configurations Old Memory Config $successmemgb New Memory Config $successoutmemgb"
                               
                                    } 
                                    [string]$finstring = $successcpustr + ' ' + $successmemstr
                                    $tabaobj.Add("VMData", $finstring)
                                }
                                elseIf ($expectedcpu -gt $vm.NumCpu) {
                                    $VMSpec = New-Object -Type VMware.Vim.VirtualMAchineConfigSpec
                                    $VMSpec.CpuHotAddEnabled    = "True"
                                    $VMSpec.MemoryHotAddEnabled = "True"
                                    $specout = $vm.ExtensionData.ReconfigVM_Task($VMSpec)
                                    $out = get-vm -name $vm.Guest.VmName | set-vm -NumCpu $expectedcpu -Confirm:$false -ErrorAction Stop 
                                    if (($out.NumCpu -eq $expectedcpu) -and ($specout))  {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [int]$successoutcpu = $out.NumCpu.ToString()
                                        [string]$successcpustr = "Successful Configurations Old Config $successcpu New Config $expectedcpu"
                                        $tabaobj.Add("VMData", $successcpustr)
                                    }
                                    else {
                                        [int]$successcpu = $vm.NumCpu.ToString()
                                        [string]$unsuccesscpustr = "UnSuccessful Configurations Old Config $successcpu New Config $successoutcpu"
                                        $tabaobj.Add("VMData", $unsuccesscpustr)
                                    }
                                }
                                elseIf ($expectedmemgb -gt $vm.MemoryGB) {
                                    $VMSpec = New-Object -Type VMware.Vim.VirtualMAchineConfigSpec
                                    $VMSpec.CpuHotAddEnabled    = "True"
                                    $VMSpec.MemoryHotAddEnabled = "True"
                                    $specout = $vm.ExtensionData.ReconfigVM_Task($VMSpec)
                                    $out = get-vm -name $vm.Guest.VmName | set-vm -MemoryGB  $expectedmemgb -Confirm:$false -ErrorAction Stop
                                    if (($out.MemoryGB -eq $expectedmemgb) -and ($specout))  {
                                        [int]$successmemgb = $vm.MemoryGB.ToString()
                                        [int]$successoutmemgb = $out.MemoryGB.ToString()
                                        [string]$successmemstr = "Successful Configurations Old Config $successmemgb New Config $successoutmemgb"
                                        $tabaobj.Add("VMData", $successmemstr)
                                    }
                                    else {
                                        [int]$successmemgb = $vm.MemoryGB.ToString()
                                        [int]$successoutmemgb = $out.MemoryGB.ToString()
                                        [string]$unsuccessmemstr = "UnSuccessful Configurations Old Config $successmemgb New Config $successoutmemgb"
                                        $tabaobj.Add("VMData", $unsuccessmemstr)
                                    } 
                                }
                                else {
                                    [int]$elsememgb = $vm.MemoryGB.ToString()
                                    [int]$elsenumcpu = $vm.NumCpu.ToString()
                                    [string]$elsememstr = "The values provided are not greater than existing configuarations Memory Existing $elsememgb Memory where Inputs $expectedcpu and CPU Existing $elsenumcpu where CPU Inputs $expectedcpu"
                                    $tabaobj.Add("VMData", $elsememstr)
                                }
  
                            }
                            Catch {
                                $global:configmsg = $_.Exception.Message
                                if ($global:configmsg ) {
                  
                                    $tabaobj.Add("VMData", $global:configmsg)
                                }
                                else {
                                    $tabaobj.Add("VMData", $global:configmsg)
                                }

                            }
                        }
                        else {
                            $global:configmsg = "The values provided are not greater than existing configuarations"
                            if ($global:configmsg) {
                  
                                $tabaobj.Add("VMData", $global:configmsg)
                            }
                            else {
                                $tabaobj.Add("VMData", $global:configmsg)
                            }
                        }
                    }
                }
                catch {
                    $opitmalmsg = $_.Exception.Message
                    if ($opitmalmsg) {
                        $results.GetType()
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                    else {
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                }

            }
            else {
                $precheck = "ERROR The VM $client has failed due to prechecks $precheck"
                if ($precheck) {
                    if ($tabaobj.ContainsKey("Prechecks")) {
                        $tabaobj["Prechecks"] = $precheck
                    }
                    else {
                        $tabaobj.Add("Prechecks", $precheck)
                    }
                }
                else {
                    if ($tabaobj.ContainsKey("Prechecks")) {
                        $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                    }
                    else {
                        $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                    }
                }
            }

        }
        else {
            $vmfound = "ERROR The VM $client not found in vCenter $vcenterserver"
            if ($vmfound) {
                if ($tabaobj.ContainsKey("VmStatus")) {
                    $tabaobj["VmStatus"] = $vmfound
                }
                else {
                    $tabaobj.Add("VmStatus", $vmfound)
                }
            }
        }
   
    }
    else {
        if ($vmfound) {
            if ($tabaobj.ContainsKey("VmStatus")) {
                $tabaobj["VmStatus"] = $vmfound
            }
            else {
                $tabaobj.Add("VmStatus", $vmfound)
            }
        }
    }
    $tabaobj | ConvertTo-Json
    DisConnect-VIServer $vcenterserver -Confirm:$false  -Force  -ErrorAction Stop
#}


##############################################


#################CAPACITY POWERON AFTER non HOT ADD#############



#$ErrorActionPreference = "silentlycontinue"

[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{VALID_PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{VALID_USER}'


[ValidateNotNullOrEmpty()]
[string] $vcenterserver = '$INPUT{VALID_SERVER_FQDN}'

[ValidateNotNullOrEmpty()]
[string]$client = '$INPUT{VMSDATA}'



$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()

$tabaobj.Add("ActionTask", "VM POWERON AND VALIDATION")

#if ($client -eq 'sampleserver') {
   
    if ($vcenterserver -eq 'samplevc') {
        try {
            Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false -ErrorAction Stop | Out-Null
            $configset = "INFO No proxy has been set "
        }
        catch { $configset = "ERROR Setting Proxy has failed" }  
    }
    else {
        $configset = "INFO No proxy has been set "
    }


    if ($configset) {
        $tabaobj.Add("Proxy", $configset)
    }
   

    if (!(Get-Module -Name VMware.VimAutomation.Core)) {
        try {
            Import-Module -Name VMware.VimAutomation.Core -ErrorAction stop
            $moduleset = "INFOVmware module has been imported"
        }
        catch { $moduleset = "ERRORVmware module has not been imported" }

        if ($moduleset) {
            $tabaobj.Add("Modules", $moduleset)
        }
    	
        if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
        else {
            try {
                $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
                $cnvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
                $connected = "INFO Connected to vcenter Server $vcenterserver"
            
            }
            catch {
                $connectmsg = $_.Exception.Message
                $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
            }
            if ($connected) {
                $tabaobj.Add("Connection", $connected)
            }
        
        }
    }
    else {
        try {
            $CREDENTIALS = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD
            $connectvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
            $connected = "INFO Connected to vcenter Server $vcenterserver"
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
        }


        if ($connected) {
            if ($tabaobj.ContainsKey("Connection")) {
                $tabaobj["Connection"] = $connected
            }
            else {
                $tabaobj.Add("Connection", $connected)
            }
        }
     
    }


    if ($connected) {
        if ($connected -notlike "ERROR Could not connect to vCenter*") {
            try {
                $vm = get-vm -Name $client -ErrorAction Stop 
                $vmid = $vm.Id
                $vmfound = "INFO VM $client is found in $vcenterserver"
            }
            catch {
                $clientmsg = $_.Exception.Message
                if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                    try {
                        $decomclient = "$client-DECOM*"
                        $vm = get-vm -Name $decomclient -ErrorAction Stop 
                        $vmid = $vm.Id
                        #write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                        $vmfound = "ERROR :  VM $client in $vcenterserver is renamed for Decomission"
                    }
                    catch {
                        $clientmsg = $_.Exception.Message
                        #write-host "ERROR Unable to find VM $client in $vcenterserver $clientmsg"
                        $vmfound = "ERROR $clientmsg"
                    }
                }
            }
        }
        else {
            $vmfound = "ERROR VM $client is not found in $vcenterserver"
        }

    }


    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }


    if ($vmfound -eq "INFO VM $client is found in $vcenterserver") {
        if ($vm.Name -eq "$client") {
            if ($vm.PowerState -eq "PoweredOn") {  
                $precheck = "VM still Poweron"
            }
            else {
                $precheck = $Null
            }
            if ($precheck) {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = $precheck
                }
                else {
                    $tabaobj.Add("Prechecks", $precheck)
                }
            }
            else {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                }
                else {
                    $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                }
            }
            if (!$precheck) {
    
                try {
				#Initiate Poweron                  
                    if ($vm.Guest.VmName -eq $client) {

                    try { 
                        if ($vm.PowerState -eq "PoweredOff") {
                        $job = Get-VM -Name $vm.Guest.VmName | Start-VM -Confirm:$false -ErrorAction Stop 
                        # Wait for PowerOn to complete to complete
                        do {
                            #Wait 5 seconds
                            Start-Sleep -s 5
  							$pstatus = Get-VM -Name $vm.Guest.VmName | Select -ExpandProperty PowerState
 						}until($pstatus -eq "PoweredOn")
 						do {
                            #Wait 10 seconds
                            Start-Sleep -s 10
  							$currentstatus = Get-VM -Name $vm.Guest.VmName
                            $runningstatus = $currentstatus.ExtensionData.Guest.GuestOperationsReady
 						}until($runningstatus -eq "True")
                            $vmstring = $vm.Guest.VmName
                        
                            if (($pstatus -eq "PoweredOn") -and ($runningstatus -eq "True")) {
                                
                                [string]$successshutdownstr = "PowerOn Successfully performed in $vmstring after reconfig and GuestOperationsReady is $runningstatus"
                            } 
                            else {
                                [string]$successshutdownstr = "PowerOn Unsuccessfull in server $vmstring for reconfiguration"
                               
                            }
                            if ($tabaobj.ContainsKey("VMData")) {
                                $tabaobj["VMData"] = $successshutdownstr
                            }
                            else {
                                $tabaobj.Add("VMData", $successshutdownstr)
                            }

                           }
                        elseif ($vm.PowerState -eq "PoweredOn") {
							#start
                            $wd = "PowerOn already occured in server $($vm.Guest.VmName)"
                            if ($tabaobj.ContainsKey("VMData")) {
                                $tabaobj["VMData"] = $wd
                            }
                            else {
                                $tabaobj.Add("VMData", $wd)
                            }
						}
}
                    
                     Catch {
                                $global:configmsg = $_.Exception.Message
                                #cut
                                if ($global:configmsg ) {
		                            if ($tabaobj.ContainsKey("VMData")) {
                                    $tabaobj["VMData"] = $global:configmsg
                                    }
                                    else {
                                    $tabaobj.Add("VMData", $global:configmsg)
                                    }
                                    }
                                #cut
                            }
                    }
                     else {
                            $global:configmsg = "PowerOn action unable to perform in $client"
                            if ($global:configmsg) {
		                        if ($tabaobj.ContainsKey("VMData")) {
                                    $tabaobj["VMData"] = $global:configmsg
                                }
                                else {
                                      $tabaobj.Add("VMData", $global:configmsg)
                                }
                            }
                        }
                 
                }
                
   								
                catch {
                    $opitmalmsg = $_.Exception.Message
                    if ($opitmalmsg) {
                    	if ($tabaobj.ContainsKey("VMData")) {
                        $tabaobj["VMData"] = $opitmalmsg
                    	}
                    else {
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                	}
                    
                }

            }
            
            else {
                $precheck = "ERROR The VM $client has failed due to prechecks $precheck"
                if ($precheck) {
                    if ($tabaobj.ContainsKey("Prechecks")) {
                        $tabaobj["Prechecks"] = $precheck
                    }
                    else {
                        $tabaobj.Add("Prechecks", $precheck)
                    }
                }
                else {
                    if ($tabaobj.ContainsKey("Prechecks")) {
                        $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                    }
                    else {
                        $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                    }
                }
            }

        }
        else {
            $vmfound = "ERROR The VM $client not found in vCenter $vcenterserver"
            if ($vmfound) {
                if ($tabaobj.ContainsKey("VmStatus")) {
                    $tabaobj["VmStatus"] = $vmfound
                }
                else {
                    $tabaobj.Add("VmStatus", $vmfound)
                }
            }
        }
        $disconnect = DisConnect-VIServer $vcenterserver -Confirm:$false  -Force  -ErrorAction Stop
   
    }
    $tabaobj | ConvertTo-Json
#}


####################################


########################CAPACITY RESER EXISTING SC##########


variable=$(curl --insecure -s -X GET https://'$INPUT{SITENAME}'/CIRBA/api/v2/existing-systems/?name='$INPUT{SERVERNAME}' \
  -H 'authorization: Basic $INPUT{GETTOKEN}' \
  -H 'cache-control: no-cache')
for i in $(echo $variable | sed "s/,/ /g")
do
    if [[ "$i" == *"existing-systems"* ]]; then
        completeurl=$(echo $i | awk -F':' '{print $2}')
    	finalurl=$(echo "$completeurl" | sed 's/\"//g' )
    	curl --insecure -s -X GET https://'$INPUT{SITENAME}'/CIRBA/api/v2"$finalurl" \
  		-H 'authorization: Basic $INPUT{GETTOKEN}' \
  		-H 'cache-control: no-cache'
    fi
done

####################################


########################CAPACITY RESER MAIN SC CURL##########


declare -i cpu='$INPUT{CPU}'
declare -i mem='$INPUT{MEM}'
os='$INPUT{OS}'
cluster='$INPUT{CLUSTER}'
vc='$INPUT{VC}'
client='$INPUT{SERVERNAME}'


if [[ "$cpu" > 0  &&  "$mem" > 0 ]]; then
	reservecomp="CPUMEM"
elif [ "$cpu" > 0 ]; then
  	reservecomp="CPU"
elif [ "$mem" > 0 ]; then
  	reservecomp="MEM"
else
  	reservecomp= "invalid"
fi   

if [[ $os == *"RHEL"* ]]; then
	os="Linux"
else
	os="Windows"
fi

if [[ -z "$reservecomp" && "$reservecomp" != 'invalid' ]]; then
	reservationname="invalid"
else
	reservationname="TOOL_${client}_${reservecomp}"
fi



if [[ $reservationname == *"invalid"* ]]; then
   echo "Reservation prechecks are invalid"
else
  newvar=$(curl --insecure -s -X POST https://'$INPUT{SITENAME}'/CIRBA/api/v2/workloads \
  -H 'authorization: Basic XXXXXXXXXXXXXXXXXXXXXXX=' \
  -H 'cache-control: no-cache' \
  -H 'content-type: application/json' \
  -d '{
    "name": "'"$reservationname"'",
    "owner": "tool",
    "catalog_spec": "winsmall",
    "workload_profile": "Medium_Utilization",
    "project": "tool",
    "late_days": 1,
    "vcpu": "'"$cpu"'",
    "memory": "'"$mem"'",
    "os": "'"$os"'",
    "disks": [
        {
            "name": "SYSTEM",
            "provisioned_space": 0,
            "used_space": 0,
            "attributes": [
                { "name": "Datastore tier", "value": "" }
            ]
        }
    ],
    "attributes": [
        { "name": "Ticket Number", "value": "125678" },
        { "name": "Project Team", "value": "BAU" },
        { "name": "Role", "value": "Unknown" },
        { "name": "Environment", "value": "f3" }, 
        { "name": "vCenter Location", "value": "chennai" },
        { "name": "Supported Cluster Group", "value": "'"$os"'" },
        { "name": "Allow Bookings", "value": "yes" } 
    ]
}
' 2>&1)

	if [ $? -ne 0 ] ; then
   		echo "Error: ""$newvar"
	else
   		for i in $(echo $newvar | sed "s/,/ /g")
		do
		    if [[ "$i" == *"/workloads/"* ]]; then
		        completeurl=$(echo $i | awk -F':' '{print $2}' | awk -F'/' '{print $3}')
		    	finalurl=$(echo "$completeurl" | sed 's/\"//g' )
		    fi
		done
		if [ -z "$finalurl" ]; then
			echo 'No valid workload id found'
		else
			route=$(curl --insecure -s -X POST https://'$INPUT{SITENAME}'/CIRBA/api/v2/routing-requests/ \
			  -H 'authorization: Basic xxxxxxxxxxxxxxxxx' \
			  -H 'cache-control: no-cache' \
			  -H 'content-type: application/json' \
			  -d '{
				"scopes": [{
					"control_environment": "'"$vc"'",
					"infrastructure_groups": ["'"$cluster"'"]
				}],
				"workloads": [{
					"id": "'"$finalurl"'"
				}]
			}')
		fi
		
	fi

fi

if [ -z "$route" ]; then
	echo "Routing failed"
else
   for i in $(echo $route | sed "s/,/ /g")
		do
		    if [[ "$i" == *"/routing-requests/"* ]]; then
		        routeurl=$(echo $i | awk -F':' '{print $2}' | awk -F'/' '{print $3}')
		    	finalrouteurl=$(echo "$routeurl" | sed 's/\"//g' )
		    fi
		done
fi


if [ -z "$finalrouteurl" ]; then
	echo "$route"
else
	z=0
	finalstate='ANALYZING'
	while [[ $z -le 6 && "$finalstate" == "ANALYZING" ]]
	do
	  fetch=$(curl --insecure -s -X GET https://'$INPUT{SITENAME}'/CIRBA/api/v2/routing-requests/"$finalrouteurl" \
	  -H 'authorization: Basic xxxxxxxxxxxxxxxxxxxxxxxxxxx' \
	  -H 'cache-control: no-cache' \
	  -H 'content-type: application/json')
	  for y in $(echo $fetch | sed "s/,/ /g")
	  do
	  	if [[ "$y" ==  *"\"status\""* ]]; then
			finsstatus=$(echo $y | awk -F':' '{print $2}')
			finalstate=$(echo "$finsstatus" | sed 's/\"//g' )
	    fi
	  done
	  sleep 2
	  ((z++))
	done
fi

if [ "$finalstate" != "PLACED" ]; then
   echo "$fetch"
else
   echo "$fetch"
fi


########################CAPACITY RESER FORCED SC CURL##########


declare -i cpu='$INPUT{CPU}'
declare -i mem='$INPUT{MEM}'
os='$INPUT{OS}'
cluster='$INPUT{CLUSTER}'
vc='$INPUT{VC}'
client='$INPUT{SERVERNAME}'


if [[ "$cpu" > 0  &&  "$mem" > 0 ]]; then
	reservecomp="CPUMEM"
elif [ "$cpu" > 0 ]; then
  	reservecomp="CPU"
elif [ "$mem" > 0 ]; then
  	reservecomp="MEM"
else
  	reservecomp= "invalid"
fi   

if [[ -z "$reservecomp" && "$reservecomp" != 'invalid' ]]; then
	reservationname="invalid"
else
	reservationname="RESOLVE_${client}_${reservecomp}"
fi

if [[ $os == *"RHEL"* ]]; then
	os="Linux"
else
	os="Windows"
fi

if [[ $reservationname == *"invalid"* ]]; then
   echo "Reservation prechecks are invalid"
else
  newvar=$(curl --insecure -s -X POST https://'$INPUT{SITENAME}'/CIRBA/api/v2/workloads \
  -H 'authorization: Basic xxxxxxxxxxxxxxxxxx' \
  -H 'cache-control: no-cache' \
  -H 'content-type: application/json' \
  -d '{
    "name": "'"$reservationname"'",
    "owner": "tool",
    "catalog_spec": "win-small-1gb",
    "workload_profile": "Medium_Utilization",
    "project": "tool",
    "late_days": 1,
    "vcpu": "'"$cpu"'",
    "memory": "'"$mem"'",
    "os": "'"$os"'",
    "disks": [
        {
            "name": "SYSTEM",
            "provisioned_space": 0,
            "used_space": 0,
            "attributes": [
                { "name": "Datastore Tier", "value": "" }
            ]
        }
    ],
    "attributes": [
        { "name": "Ticket Number", "value": "125678" },
        { "name": "Project Team", "value": "BAU" },
        { "name": "Role", "value": "Unknown" },
        { "name": "Environment", "value": "f3" }, 
        { "name": "vCenter Location", "value": "chennai" },
        { "name": "Supported Cluster Group", "value": "'"$os"'" },
        { "name": "Allow Bookings", "value": "yes" } 
    ]
}
' 2>&1)

	if [ $? -ne 0 ] ; then
   		echo "Error: ""$newvar"
	else
   		for i in $(echo $newvar | sed "s/,/ /g")
		do
		    if [[ "$i" == *"/workloads/"* ]]; then
		        completeurl=$(echo $i | awk -F':' '{print $2}' | awk -F'/' '{print $3}')
		    	finalurl=$(echo "$completeurl" | sed 's/\"//g' )
		    fi
		done
		
		if [ -z "$finalurl" ]; then
			echo 'No valid worload id found'
		else
			route=$(curl --insecure -s -X POST https://'$INPUT{SITENAME}'/CIRBA/api/v2/routing-requests?force=true \
			  -H 'authorization: Basic xxxxxxxxxxxxxxx' \
			  -H 'cache-control: no-cache' \
			  -H 'content-type: application/json' \
			  -d '{
				"scopes": [{
					"control_environment": "'"$vc"'",
					"infrastructure_groups": ["'"$cluster"'"]
				}],
				"workloads": [{
					"id": "'"$finalurl"'"
				}]
			}')
		fi
		
	fi

fi

if [ -z "$route" ]; then
	echo "Routing failed"
else
   for i in $(echo $route | sed "s/,/ /g")
		do
		    if [[ "$i" == *"/routing-requests/"* ]]; then
		        routeurl=$(echo $i | awk -F':' '{print $2}' | awk -F'/' '{print $3}')
		    	finalrouteurl=$(echo "$routeurl" | sed 's/\"//g' )
		    fi
		done
fi


if [ -z "$finalrouteurl" ]; then
	echo "$route"
else
	z=0
	finalstate='ANALYZING'
	while [[ $z -le 6 && "$finalstate" == "ANALYZING" ]]
	do
	  fetch=$(curl --insecure -s -X GET https://'$INPUT{SITENAME}'/CIRBA/api/v2/routing-requests/"$finalrouteurl" \
	  -H 'authorization: Basic xxxxxxxxxxxxxxxxxxxxxxxxxxxxx' \
	  -H 'cache-control: no-cache' \
	  -H 'content-type: application/json')
	  for y in $(echo $fetch | sed "s/,/ /g")
	  do
	  	if [[ "$y" ==  *"\"status\""* ]]; then
			finsstatus=$(echo $y | awk -F':' '{print $2}')
			finalstate=$(echo "$finsstatus" | sed 's/\"//g' )
	    fi
	  done
	  sleep 2
	  ((z++))
	done
fi

if [ "$finalstate" != "PLACED" ]; then
   echo "$fetch"
else
   echo "$fetch"
fi

####################################

##############DIKS PREVERIFY##############


[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{VALID_PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{VALID_USER}'


[ValidateNotNullOrEmpty()]
[string] $vcenterserver = '$INPUT{VALID_SERVER_FQDN}'

[ValidateNotNullOrEmpty()]
[string]$client = '$INPUT{VMSDATA}'

[ValidateNotNullOrEmpty()]
[int]$expectedcpu = '$INPUT{EXCPU}'

[ValidateNotNullOrEmpty()]
[int]$expectedsocket = '$INPUT{EXSOCKET}'

[ValidateNotNullOrEmpty()]
[int]$expectedmemgb = '$INPUT{EXMEM}'

[ValidateNotNullOrEmpty()]
$reqdrive = '$INPUT{EX_DRIVE_LETTER}'

[ValidateNotNullOrEmpty()]
$dtype = '$INPUT{DRIVETYPE}'

[ValidateNotNullOrEmpty()]
[int]$reqsize = '$INPUT{EX_SIZE}'

$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()


if($reqdrive -cnotmatch '/') {

   $reqdrive = $reqdrive.replace('\\','').Trim()
}
    
$objInfo =@{}
$ostype=@()
$vresults=@()

[int]$threshold = "20"

Function Percentcal {
    param(
    [parameter(Mandatory = $true)]
    [int]$InputNum1,
    [parameter(Mandatory = $true)]
    [int]$InputNum2)
    $InputNum1 / $InputNum2*100
}
   
   
if ($vcenterserver -eq 'SAMPLEVC1' ) {
    try {
        Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false -ErrorAction Stop | Out-Null
        $configset = "INFO No proxy has been set "
    }
    catch { $configset = "ERROR Setting Proxy has failed" }  
}
else {
    $configset = "INFO No proxy has been set "
}


if ($configset) {
    $tabaobj.Add("Proxy", $configset)
}
   

if (!(Get-Module -Name VMware.VimAutomation.Core)) {
    try {
        Import-Module -Name VMware.VimAutomation.Core -ErrorAction stop
        $moduleset = "INFOVmware module has been imported"
    }
    catch { $moduleset = "ERRORVmware module has not been imported" }

    if ($moduleset) {
        $tabaobj.Add("Modules", $moduleset)
    }
    	
    if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
    else {
        try {
            $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
            $cnvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
            $connected = "INFO Connected to vcenter Server $vcenterserver"
            
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
        }
        if ($connected) {
            $tabaobj.Add("Connection", $connected)
        }
        
    }
}
else {
    try {
        $CREDENTIALS = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD
        $connectvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
        $connected = "INFO Connected to vcenter Server $vcenterserver"
    }
    catch {
        $connectmsg = $_.Exception.Message
        $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
    }


    if ($connected) {
        if ($tabaobj.ContainsKey("Connection")) {
            $tabaobj["Connection"] = $connected
        }
        else {
            $tabaobj.Add("Connection", $connected)
        }
    }
     
}


if ($connected) {
    if ($connected -notlike "ERROR Could not connect to vCenter*") {
        try {
            $vm = get-vm -Name $client -ErrorAction Stop 
            $vmid = $vm.Id
            $vmfound = "INFO VM $client is found in $vcenterserver"
        }
        catch {
            $clientmsg = $_.Exception.Message
            if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                try {
                    $decomclient = "$client-DECOM*"
                    $vm = get-vm -Name $decomclient -ErrorAction Stop 
                    $vmid = $vm.Id
                    #write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                    $vmfound = "ERROR :  VM $client in $vcenterserver is renamed for Decomission"
                }
                catch {
                    $clientmsg = $_.Exception.Message
                    #write-host "ERROR Unable to find VM $client in $vcenterserver $clientmsg"
                    $vmfound = "ERROR $clientmsg"
                }
            }
        }
    }
    else {
        $vmfound = "ERROR VM $client is not found in $vcenterserver"
    }

}

if ($vmfound) {
    if ($tabaobj.ContainsKey("VmStatus")) {
        $tabaobj["VmStatus"] = $vmfound
    }
    else {
        $tabaobj.Add("VmStatus", $vmfound)
    }
}


if ($vmfound -eq "INFO VM $client is found in $vcenterserver") {
    if ($vm.Name -eq "$client") {
        $pretask = get-task -Server $vcenterserver | where-object { $_.ObjectId -eq $vmid }
        $pregueststate = $vm.Guest.State
        $pretoolstate = $vm.ExtensionData.Guest.ToolsRunningStatus
        if ($pretask.State -ccontains "Queued" -or $pretask.State -ccontains "Running") {  
            $pretaskdesc = $pretask.Description
            $precheck = "Tasks in progress are " + $pretaskdesc
        }
        else {
            $precheck = $Null
        }
        if ($pregueststate -ne 'Running') {
            $precheck = "$vm is in $pregueststate state"
        }
        else {
            $precheck = $Null
        }
        if ($pretoolstate -eq 'guestToolsRunning') {
            $precheck = $Null
        }
        else {
            $precheck = "$vm vmware tools are in $pretoolstate State"
        }

        if ($precheck) {
            if ($tabaobj.ContainsKey("Prechecks")) {
                $tabaobj["Prechecks"] = $precheck
            }
            else {
                $tabaobj.Add("Prechecks", $precheck)
            }
        }
        else {
            if ($tabaobj.ContainsKey("Prechecks")) {
                $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
            }
            else {
                $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
            }
        }
        if (!$precheck) {
    
            try {
                if ($vm.Guest.VmName -eq $client) {
                    try
                    {
                     #start
                    $VMview = get-vm $vm | get-view
					$osname = $vm.ExtensionData.Guest.GuestFullName
					
					Function WinVerify($vm,$ostype) {                     
						$rDisk = $VMview.guest.disk| where{$_.DiskPath -match "^$reqdrive"}
						
						$username1 = '$INPUT{WINUSER}'
                        $password1 = ConvertTo-SecureString '$INPUT{WINPASSWORD}' -AsPlainText -Force
                        $credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username1, $password1
						#$source = '$INPUT{WINSERVER}'
                        $Windrive = Invoke-Command -ComputerName '$INPUT{WINSERVER}' -Credential $credential -Scriptblock {
                        $compname = $env:COMPUTERNAME
                        $compname
                        $getdrives = (((Get-WmiObject -ComputerName $compname -ClassName 'Win32_LogicalDisk') | WHERE {$_.DeviceID -eq $using:reqdrive}).GetRelated('Win32_DiskPartition')).GetRelated('Win32_DiskDrive') | Select *
                        $SCSIBus =$getdrives.SCSIBus
						$SCSITargetId =$getdrives.SCSITargetId
						$DiskSNfromWMI = $getdrives.SerialNumber
                        $SCSIBus
                        $SCSITargetId
                        $DiskSNfromWMI
                        } -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck -ProxyAccessType NoProxyServer) -EA Stop
                       $Windrive
                       #$Windrive = (((Get-WmiObject -ComputerName $vm.Name -ClassName 'Win32_LogicalDisk') | WHERE {$_.DeviceID -eq $reqdrive}).GetRelated('Win32_DiskPartition')).GetRelated('Win32_DiskDrive') | Select *
						$SCSIBusout = $Windrive[0]
                        $SCSITargetIdout = $Windrive[1]
                        $DiskSNfromWMIout = $Windrive[2]
						
							foreach($ctrl in Get-ScsiController -VM $vm) {

								foreach($disk in (Get-HardDisk -VM $vm | where{$_.ExtensionData.ControllerKey -eq $ctrl.Key})) {

									If (($disk.ExtensionData.UnitNumber -eq $SCSITargetIdout )-and (($disk.ExtensionData.Backing.Uuid).Replace('-','') -eq $DiskSNfromWMIout) ) {

										$VMDiskName = $disk.Name
										$VMDiskFilename = $disk.Filename
										$DiskUID = $disk.Uid
										$DiskCapacityGB = $disk.CapacityGB
										$DiskFreeSpaceGB = ( $vmview.Guest.Disk | where {$_.DiskPath -cmatch $reqdrive}).FreeSpaceGB
										$DiskFreeSpaceGB = "{0:N3}" -f ([math]::Round($DiskFreeSpaceGB,3))
									}

								}
							}

						$LUN = Get-HardDisk -vm $vm | Where {$_.Uid -eq $DiskUID} | Get-Datastore
						$LUNName = $LUN.Name
						$FreespaceGB = "{0:N3}" -f ([math]::Round($LUN.FreeSpaceGB,3))
						$CapacityGB = "{0:N3}" -f ([math]::Round($LUN.CapacityGB,3))
						$includereqsizePercentFree = [int]$reqsize + [int]$LUN.CapacityGB
						$bPercentFree = Percentcal $LUN.FreeSpaceGB $LUN.CapacityGB
						$bPercentFree = [Math]::Round($bPercentFree)
						$includereqsizePercentFree = [int]$LUN.FreeSpaceGB - [int]$reqsize
						$aPercentFree = Percentcal $includereqsizePercentFree $LUN.CapacityGB
						$aPercentFree = [Math]::Round($aPercentFree)
							if ($aPercentFree -ge $threshold) {
        						$result  = "success"             
        						$message = "Enough space. Current Datastore Freespace is $aPercentFree%"
    						}
        					else {
            					$result = "fail"
            					$message = "Size exceeds 80%"
        					}

						$objresults=@()

						$objInfo = [pscustomobject]@{
                                    VMOSType                         = $ostype;
                                    VMDatastore                      = $LUNName;
                                    VMDiskCapacity                   = $DiskCapacityGB;
                                    DriveType						 = $dtype;
                                    RequestedDriveforExpand          = $reqdrive;
                                    RequestSizeforExpand             = $reqsize;
                                    DSTotalCapacity                  = $([Math]::Round($LUN.CapacityGB));
                                    DSFreePercentBeforeExpansion     = $bPercentFree;
                                    DSFreePercentAfterExpansion      = $aPercentFree;
                                    result                           = $result;
                                    message                          = $message                 
                                	}
                           
                    	$objresults += $objInfo
						$global:vresults = $objresults
                     #end 
					}

					Function UnixVerify($vm,$ostype) {                     
						$LUN = Get-HardDisk -vm $vm | Get-Datastore
						$LUNName = $LUN.Name
						$FreespaceGB = "{0:N3}" -f ([math]::Round($LUN.FreeSpaceGB,3))
						$CapacityGB = "{0:N3}" -f ([math]::Round($LUN.CapacityGB,3))
						$includereqsizePercentFree = [int]$reqsize + [int]$LUN.CapacityGB
						$bPercentFree = Percentcal $LUN.FreeSpaceGB $LUN.CapacityGB
						$bPercentFree = [Math]::Round($bPercentFree)
						$includereqsizePercentFree = [int]$LUN.FreeSpaceGB - [int]$reqsize
						$aPercentFree = Percentcal $includereqsizePercentFree $LUN.CapacityGB
						$aPercentFree = [Math]::Round($aPercentFree)
							if ($aPercentFree -ge $threshold) {
        						$result  = "success"             
        						$message = "Enough space. Current Datastore Freespace is $aPercentFree%"
    						}
        					else {
            					$result = "fail"
            					$message = "Size exceeds 80%"
        					}
        					if ($ostype = 'Windows') {
        						$reqdriveexpand = $global:reqdrive
        					}
        					else {
        						$reqdriveexpand = "NotApplicable"
        					}
						$objresults=@()
						$objInfo = [pscustomobject]@{
                                    VMOSType                         = $global:ostype;
                                    VMDatastore                      = $LUNName;
                                    VMDiskCapacity                   = "NotApplicable";
                                    DriveType						 = $dtype;
                                    RequestedDriveforExpand          = $reqdrive;
                                    RequestSizeforExpand             = $reqsize;
                                    DSTotalCapacity                  = $([Math]::Round($LUN.CapacityGB));
                                    DSFreePercentBeforeExpansion     = $bPercentFree;
                                    DSFreePercentAfterExpansion      = $aPercentFree;
                                    result                           = $result;
                                    message                          = $message                 
                                	}
                           
                    	$objresults += $objInfo
						$global:vresults = $objresults
                     	#end 
					}
					
					If(($osname -like "Microsoft*") -and ($dtype -like "existing")) {
						$ostype = "Windows"
						WinVerify -vm $vm -ostype $ostype
					}
					elseif (($osname -like "Red*") -or ($osname -like "linux")) {
					$ostype = "Unix"
					UnixVerify -vm $vm -ostype $ostype
					}
					elseif (($osname -like "Microsoft*") -and ($dtype -like "new")) {
					$ostype = "Windows"
					UnixVerify -vm $vm -ostype $ostype
					}
                     #end 
                    }
                    catch{
                    	$msg=$_.Exception.Message
                    	$tabaobj.Add("VMData", "$msg")	
                    }
                    if ($global:vresults) {
    
                        $tabaobj.Add("VMData", $global:vresults)
                        
                    }
                    else {
                        $tabaobj.Add("VMData", "ERROR Failed to Evaluate")
                    }
                }
                else {
                    $opitmalmsg = "ERROR The VM $client not found in vCenter $vcenterserver"
                    if ($global:vresults) {
                        $tabaobj.Add("VMData", $global:vresults)
                    }
                    else {
                        $tabaobj.Add("VMData", $opitmalmsg)
                    }
                }
            }
            catch {
                $opitmalmsg = $_.Exception.Message
                if ($global:vresults) {
                    $results.GetType()
                    $tabaobj.Add("VMData", $global:vresults)
                }
                else {
                    $tabaobj.Add("VMData", $opitmalmsg)
                }
            }

        }
        else {
            $precheck = "ERROR The VM $client has failed due to prechecks $precheck"
            if ($precheck) {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = $precheck
                }
                else {
                    $tabaobj.Add("Prechecks", $precheck)
                }
            }
            else {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                }
                else {
                    $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                }
            }
        }

    }
    else {
        $vmfound = "ERROR The VM $client not found in vCenter $vcenterserver"
        if ($vmfound) {
            if ($tabaobj.ContainsKey("VmStatus")) {
                $tabaobj["VmStatus"] = $vmfound
            }
            else {
                $tabaobj.Add("VmStatus", $vmfound)
            }
        }
    }
   
}
else {
    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
            $result = "fail"
			$message = "VM $client not Found in VCenter $vcenterserver"
			$objresultserr=@()
			$objInfoerror =@{}
			$objInfoerror = [pscustomobject]@{
                                    result                           = $result;
                                    message                          = $message                 
                               	}
			$objresultserr += $objInfoerror 
			$tabaobj.Add("VMData", $objresultserr)
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }
}
$tabaobj | ConvertTo-Json


######################################


#################CAPACITY ADD DISK(vm SC)########


[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{VALID_PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{VALID_USER}'


[ValidateNotNullOrEmpty()]
[string] $vcenterserver = '$INPUT{VALID_SERVER_FQDN}'

[ValidateNotNullOrEmpty()]
[string]$client = '$INPUT{VMSDATA}'

[ValidateNotNullOrEmpty()]
[int]$expectedcpu = '$INPUT{EXCPU}'

[ValidateNotNullOrEmpty()]
[int]$expectedsocket = '$INPUT{EXSOCKET}'

[ValidateNotNullOrEmpty()]
[int]$expectedmemgb = '$INPUT{EXMEM}'

[ValidateNotNullOrEmpty()]
$reqdrive = '$INPUT{EX_DRIVE_LETTER}'

[ValidateNotNullOrEmpty()]
[int]$reqsize = '$INPUT{EX_SIZE}'

[ValidateNotNullOrEmpty()]
$dtype = '$INPUT{DRIVETYPE}'

$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()


if($reqdrive -cnotmatch '/') {

   $reqdrive = $reqdrive.replace('\\','').Trim()
}
    
$objInfo =@{}

[int]$threshold = "20"

Function Percentcal {
    param(
    [parameter(Mandatory = $true)]
    [int]$InputNum1,
    [parameter(Mandatory = $true)]
    [int]$InputNum2)
    $InputNum1 / $InputNum2*100
}
   

if (($client -eq 'sampleserver1') -or ($client -eq 'sampleserver2')) {
   
    if ($vcenterserver -eq 'samplevc1' ) {
        try {
            Set-PowerCLIConfiguration -ProxyPolicy NoProxy -Scope Session -Confirm:$false -ErrorAction Stop | Out-Null
            $configset = "INFO No proxy has been set "
        }
        catch { $configset = "ERROR Setting Proxy has failed" }  
    }
    else {
        $configset = "INFO No proxy has been set "
    }


    if ($configset) {
        $tabaobj.Add("Proxy", $configset)
    }
   

    if (!(Get-Module -Name VMware.VimAutomation.Core)) {
        try {
            Import-Module -Name VMware.VimAutomation.Core -ErrorAction stop
            $moduleset = "INFOVmware module has been imported"
        }
        catch { $moduleset = "ERRORVmware module has not been imported" }

        if ($moduleset) {
            $tabaobj.Add("Modules", $moduleset)
        }
    	
        if (!$?) { throw "Could not load VMware.VimAutomation.Core" }
        else {
            try {
                $CREDENTIALS = New-Object System.Management.Automation.PSCredential($USERNAME, $USER_PASSWORD )
                $cnvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
                $connected = "INFO Connected to vcenter Server $vcenterserver"
            
            }
            catch {
                $connectmsg = $_.Exception.Message
                $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
            }
            if ($connected) {
                $tabaobj.Add("Connection", $connected)
            }
        
        }
    }
    else {
        try {
            $CREDENTIALS = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD
            $connectvar = connect-viserver $vcenterserver -Credential $CREDENTIALS -ErrorAction Stop
            $connected = "INFO Connected to vcenter Server $vcenterserver"
        }
        catch {
            $connectmsg = $_.Exception.Message
            $connected = "ERROR Could not connect to vCenter $vcenterserver $connectmsg"
        }


        if ($connected) {
            if ($tabaobj.ContainsKey("Connection")) {
                $tabaobj["Connection"] = $connected
            }
            else {
                $tabaobj.Add("Connection", $connected)
            }
        }
     
    }


    if ($connected) {
        if ($connected -notlike "ERROR Could not connect to vCenter*") {
            try {
                $vm = get-vm -Name $client -ErrorAction Stop 
                $vmid = $vm.Id
                $vmfound = "INFO VM $client is found in $vcenterserver"
            }
            catch {
                $clientmsg = $_.Exception.Message
                if ($clientmsg -like "*VM with name '$client' was not found using the specified filter*") {
                    try {
                        $decomclient = "$client-DECOM*"
                        $vm = get-vm -Name $decomclient -ErrorAction Stop 
                        $vmid = $vm.Id
                        #write-host "ACCOMPLISHED >  VM $client in $vcenterserver is renamed for Decomission"
                        $vmfound = "ERROR :  VM $client in $vcenterserver is renamed for Decomission"
                    }
                    catch {
                        $clientmsg = $_.Exception.Message
                        #write-host "ERROR Unable to find VM $client in $vcenterserver $clientmsg"
                        $vmfound = "ERROR $clientmsg"
                    }
                }
            }
        }
        else {
            $vmfound = "ERROR VM $client is not found in $vcenterserver"
        }

    }


    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }


    if ($vmfound -eq "INFO VM $client is found in $vcenterserver") {
        if ($vm.Name -eq "$client") {
            $pretask = get-task -Server $vcenterserver | where-object { $_.ObjectId -eq $vmid }
            $pregueststate = $vm.Guest.State
            $pretoolstate = $vm.ExtensionData.Guest.ToolsRunningStatus
            if ($pretask.State -ccontains "Queued" -or $pretask.State -ccontains "Running") {  
                $pretaskdesc = $pretask.Description
                $precheck = "Tasks in progress are " + $pretaskdesc
            }
            else {
                $precheck = $Null
            }
            if ($pregueststate -ne 'Running') {
                $precheck = "$vm is in $pregueststate state"
            }
            else {
                $precheck = $Null
            }
            if ($pretoolstate -eq 'guestToolsRunning') {
                $precheck = $Null
            }
            else {
                $precheck = "$vm vmware tools are in $pretoolstate State"
            }

            if ($precheck) {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = $precheck
                }
                else {
                    $tabaobj.Add("Prechecks", $precheck)
                }
            }
            else {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                }
                else {
                    $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                }
            }
if (!$precheck) {
    
        try {
           	if ($vm.Guest.VmName -eq $client) {
                	
                If (($global:reqsize -is [int]) -and ($global:reqsize -ne 0)) {
                    try
                    {
                     #start
					$VMview = get-vm $vm | get-view
					$osname = $vm.ExtensionData.Guest.GuestFullName
					$dS = Get-HardDisk -vm $vm | Get-Datastore
					$dSName = $dS.Name

  					#start
					Function AddDiskExisting($vm,$ostype) {                     
						$rDisk = $VMview.guest.disk| where{$_.DiskPath -match "^$reqdrive"}
						$Windrive = (((Get-WmiObject -ComputerName $vm.Name -ClassName 'Win32_LogicalDisk') | WHERE {$_.DeviceID -eq $reqdrive}).GetRelated('Win32_DiskPartition')).GetRelated('Win32_DiskDrive') | Select *
						$SCSIBus =$Windrive.SCSIBus
						$SCSITargetId =$Windrive.SCSITargetId
						$DiskSNfromWMI = $Windrive.SerialNumber

							foreach($ctrl in Get-ScsiController -VM $vm) {

								foreach($disk in (Get-HardDisk -VM $vm | where{$_.ExtensionData.ControllerKey -eq $ctrl.Key})) {

									If (($disk.ExtensionData.UnitNumber -eq $SCSITargetId )-and (($disk.ExtensionData.Backing.Uuid).Replace('-','') -eq $DiskSNfromWMI) ) {

										$VMDiskName = $disk.Name
										$VMDiskFilename = $disk.Filename
										$DiskUID = $disk.Uid
										$DiskCapacityGB = $disk.CapacityGB
										$DiskFreeSpaceGB = ( $vmview.Guest.Disk | where {$_.DiskPath -eq "$Drive\"}).FreeSpaceGB
										$DiskFreeSpaceGB = "{0:N3}" -f ([math]::Round($DiskFreeSpaceGB,3))
									}

								}
							}

						$selectdisk = Get-HardDisk -vm $vm | Where {$_.Uid -eq $DiskUID}
                        $diskname = $selectdisk.Name
                        if (($global:reqsize -is [int]) -and ($global:reqsize -ne 0)) { 
                            $Totalsize = [int]$selectdisk.CapacityGB + $global:reqsize
                        }
                        else {
                            $Totalsize = $selectdisk.CapacityGB 
                        }
                        
                        try{
                            $VMdiskexpand = Get-HardDisk -VM $vm | where {$_.Name -eq $diskname}|Set-HardDisk -CapacityGB $Totalsize  -Confirm:$false -ErrorAction Stop
                        
                        }
                        catch{
                            $ErrorMessage = $_.Exception.Message
                            $FailedItem = $_.Exception.ItemName
                            write-host "Disk expansion Error,$ErrorMessage"
                        }	
                        
                        		
						$objresults=@()


                        if ($VMdiskexpand.CapacityGB -eq $Totalsize) {
        						$result  = "success"             
        						$message = "$global:reqdrive Drive expanded Successfully with $global:reqsize GB. Current Total size is $($VMdiskexpand.CapacityGB) GB"
    						}
        					else {
            					$result = "fail"
            					$message = "failure to increase due to $ErrorMessage"
        					}

						$objInfo = [pscustomobject]@{
                                    VMOSType                         = $ostype;
                                    VMDatastore                      = $global:dSName;
                                    RequestedDriveforExpand          = $global:reqdrive;
                                    RequestSizeforExpand             = $global:reqsize;
                                    VMDiskSizeBeforeExpand           = $($selectdisk.CapacityGB);
                                    VMDiskSizeAfterExpand            = $($VMdiskexpand.CapacityGB);
                                    result                           = $result;
                                    message                          = $message                 
                                	}
                           
                    	$objresults += $objInfo
						$global:vresults = $objresults
                     
					}

					Function AddDiskNew($vm,$ostype) {                     

						$selectdisk = Get-HardDisk -vm $vm
                        $precount = $selectdisk.count
                        if (($global:reqsize -is [int]) -and ($global:reqsize -ne 0)) {
                            try{
                                $VMdiskexpand = $vm | New-HardDisk -Persistence $selectdisk[0].Persistence -CapacityGB $global:reqsize -StorageFormat Thick -Confirm:$false -ErrorAction Stop
                                $postdisk = Get-HardDisk -vm $vm
                                $postcount = $postdisk.count
                                If ($postcount -gt $precount) {
        						$result  = "success"             
        						$message = "New Drive created Successfully with $global:reqsize GB for expansion."
    						}
        					else {
            					$result = "fail"
            					$message = "failure to create New Drive for expansion"
        					}
                            }
                            catch{
                            $ErrorMessage = $_.Exception.Message
                            $FailedItem = $_.Exception.ItemName
                            write-host "Disk expansion Error,$ErrorMessage"
                            }	
                        }
                        else {
                            $result  = "fail"             
        					$message = "The values provided are not greater than existing configuarations"
                        }
                                               		
						$objresults=@()
                        

						$objInfo = [pscustomobject]@{
                                    VMOSType                         = $ostype;
                                    VMDatastore                      = $global:dSName;
                                    RequestedDriveforExpand          = "Not Applicable";
                                    RequestSizeforExpand             = $global:reqsize;
                                    VMNewDiskSize                    = $global:reqsize;
                                    result                           = $result;
                                    message                          = $message                 
                                	}
                           
                    	$objresults += $objInfo
						$global:vresults = $objresults
                     
					}

					If($osname -like "Microsoft*" -and $dtype -like "*existing*") {
						$ostype = "Windows"
						AddDiskExisting -vm $vm -ostype $ostype
					}
					elseif ($osname -like "Red*") {
						$ostype = "Unix"
						AddDiskNew -vm $vm -ostype $ostype
					}
					elseif ($osname -like "Microsoft*" -and $dtype -like "*new*") {
						$ostype = "Windows"
						AddDiskNew -vm $vm -ostype $ostype
					}
                     #end 
                    }
                    catch{
                    	$msg=$_.Exception.Message
                    	$tabaobj.Add("VMData", "$msg")	
                    }
                    if ($global:vresults) {
    
                        $tabaobj.Add("VMData", $global:vresults)
                        
                    }
                    else {
                        $tabaobj.Add("VMData", "ERROR Failed to Evaluate")
                    }
                }
                
                else {
                            $global:configmsg = "The values provided are not greater than existing configuarations"
                            if ($global:configmsg) {
                  
                                $tabaobj.Add("VMData", $global:configmsg)
                            }
                            else {
                                $tabaobj.Add("VMData", $global:configmsg)
                            }
                        }
                #endfive
                
                }
            }
            catch {
                $opitmalmsg = $_.Exception.Message
                if ($global:vresults) {
                    $tabaobj.Add("VMData", $global:vresults)
                }
                else {
                    $tabaobj.Add("VMData", $opitmalmsg)
                }
            }

        }
        else {
            $precheck = "ERROR The VM $client has failed due to prechecks $precheck"
            if ($precheck) {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = $precheck
                }
                else {
                    $tabaobj.Add("Prechecks", $precheck)
                }
            }
            else {
                if ($tabaobj.ContainsKey("Prechecks")) {
                    $tabaobj["Prechecks"] = "INFO No issue observed with the VM"
                }
                else {
                    $tabaobj.Add("Prechecks", "INFO No issue observed with the VM")
                }
            }
        }

    }
    else {
        $vmfound = "ERROR The VM $client not found in vCenter $vcenterserver"
        if ($vmfound) {
            if ($tabaobj.ContainsKey("VmStatus")) {
                $tabaobj["VmStatus"] = $vmfound
            }
            else {
                $tabaobj.Add("VmStatus", $vmfound)
            }
        }
    }
   
}
else {
    if ($vmfound) {
        if ($tabaobj.ContainsKey("VmStatus")) {
            $tabaobj["VmStatus"] = $vmfound
        }
        else {
            $tabaobj.Add("VmStatus", $vmfound)
        }
    }
}
$tabaobj | ConvertTo-Json
}


####################################################


#################unix PREVERIFY#########

#!/bin/bash

function inputdata()
{
    ATYPE='$INPUT{DRIVETYPE}';
    FSNAME='$INPUT{DRIVELETTER}';
    FSSIZE='$INPUT{DRIVESIZE}';  
    #ATYPE='VERIFICATION';
    #FSNAME='/fix';
    #FSSIZE='25';
    FSSIZEMB="$((FSSIZE * 1024))";
}

function getdata()
{
VGNAME=`df -mPh | grep $FSNAME | awk '{print $1}'|cut -f 4 -d "/" | cut -f 1 -d "-"`
LVNAME=`df -mPh | grep $FSNAME | awk '{print $1}'|cut -f 4 -d "/" | cut -f 2 -d "-"`
CFSSIZE=`df -mP | grep $FSNAME | awk '{print $2}'`
CVGSIZE=`/usr/boksm/bin/suexec /sbin/vgs | grep $VGNAME | awk '{print $7}' | cut -f 1 -d "." | cut -f 2 -d "<" | awk '{$1=$1*1024; print $1}'`
FSTYPE=`df -Th | grep -w $FSNAME | awk '{print $2}'`
LASTDRIVE=`lsblk |awk '{print $1}'|grep sd[a-z]$ | tail -1` 

echo "ServerName="$INPUT{ServerName}"";
echo "VGName=$VGNAME";
echo "LVName=$LVNAME";
echo "CurrentFSSize=$CFSSIZE";
echo "VGFreeSpace=$CVGSIZE";
#echo "RequestsizeGB="$((FSSIZE * 1024))"";
echo "RequestsizeMB=$FSSIZEMB";
echo "FSTYPE=$FSTYPE";
echo "LastDiskName=$LASTDRIVE"

if [ "$CFSSIZE" -gt "$FSSIZEMB" ];
then
echo "Status=INCREASE";
else
echo "Status=NEWDISK";
fi

}
## Main funtion
inputdata
getdata


############################

############uNIX OS TASK FOR DISK EXPAND#########


#!/bin/bash

 

function inputdata()
{
ATYPE='$INPUT{VRESULT}';
FSNAME='$INPUT{DRIVELETTER}';
FSSIZE='$INPUT{DRIVESIZE}';

 

#ATYPE='NEWDISK';
#FSNAME='/home';
#FSSIZE='1';
FSSIZEMB="$((FSSIZE * 1024))";
}

 

 

function getdata()
{
VGNAME=`df -mPh | grep $FSNAME | awk '{print $1}'|cut -f 4 -d "/" | cut -f 1 -d "-"`
LVNAME=`df -mPh | grep $FSNAME | awk '{print $1}'|cut -f 4 -d "/" | cut -f 2 -d "-"`
CFSSIZE=`df -mP | grep $FSNAME | awk '{print $2}'`
#CVGSIZE=`/usr/boksm/bin/suexec /sbin/vgs | grep $VGNAME | awk '{print $7}' | cut -f 1 -d "." | cut -f 2 -d "<" | awk '{$1=$1*1024; print $1}'`
CVGSIZE=`/usr/boksm/bin/suexec /sbin/vgs | grep $VGNAME | awk '{print $7}' | cut -f 1 -d "." | cut -f 2 -d "<" | awk '{$1=$1*1024; print $1}'`
FSTYPE=`df -Th | grep -w $FSNAME | awk '{print $2}'`
LASTDRIVE=`lsblk |awk '{print $1}'|grep sd[a-z]$ | tail -1`

 

 

echo "VGName=$VGNAME";
echo "LVName=$LVNAME";
echo "CurrentFSSize=$CFSSIZE";
echo "VGFreeSpace=$CVGSIZE";
#echo "RequestsizeGB="$((FSSIZE * 1024))"";
echo "RequestsizeMB=$FSSIZEMB";
echo "FSTYPE=$FSTYPE";
echo "LastDiskName=$LASTDRIVE"
if [ "$CFSSIZE" -gt "$FSSIZEMB" ];
then
echo "Status=INCREASE";
else
echo "Status=NEWDISK";
fi
 

 

 


}

 
function extent()
{

 

if [ "$CVGSIZE" -gt "$FSSIZEMB" ]; then

 

    if [ "$FSTYPE" = "xfs" ]; then
    ##RHEL 7 & 8
    #/usr/boksm/bin/suexec /usr/sbin/lvextend -L +${FSSIZE}G /dev/mapper/$VGNAME-$LVNAME > /dev/null 2>&1
    #/usr/boksm/bin/suexec /usr/sbin/xfs_growfs /dev/mapper/$VGNAME-$LVNAME > /dev/null 2>&1
        
        /usr/boksm/bin/suexec /usr/sbin/lvextend -L +${FSSIZE}G /dev/mapper/$VGNAME-$LVNAME > /dev/null 2>&1
        /usr/boksm/bin/suexec /usr/sbin/xfs_growfs /dev/mapper/$VGNAME-$LVNAME > /dev/null 2>&1
        UFSSIZE=`df -mP | grep $FSNAME | awk '{print $2}'`
        SIZESTATUS="The file system space hase been extended to $UFSSIZE"
    
    elif [ "$FSTYPE" = "ext4" ] || [ "$FSTYPE" = "ext3" ];then
    ##RHEL 5 & 6
    #/usr/boksm/bin/suexec /sbin/lvextend -L +${FSSIZE}G /dev/mapper/$VGNAME-$LVNAME > /dev/null 2>&1
    #/usr/boksm/bin/suexec /sbin/resize2fs /dev/mapper/$VGNAME-$LVNAME > /dev/null 2>&1
        
            /usr/boksm/bin/suexec /sbin/lvextend -L +${FSSIZE}G /dev/mapper/$VGNAME-$LVNAME > /dev/null 2>&1
            /usr/boksm/bin/suexec /sbin/resize2fs /dev/mapper/$VGNAME-$LVNAME > /dev/null 2>&1
            UFSSIZE=`df -mP | grep $FSNAME | awk '{print $2}'`;
            SIZESTATUS="The file system space hase been extended to $UFSSIZE"
    else
    
    SIZESTATUS="ERROR: Filesystem not correct"
    
    fi
    echo $SIZESTATUS;
else
    echo "Status=NO FREE SPACE IN VG";
fi
}

 
 

function newdiskfs()
{
    ## Get last drive name and do alphabet increment for next drive name
    
    #OLDDISK_LL=`lsblk |awk '{print $1}'|grep sd[a-z]$ | tail -1 | cut -c 3`
    #NEWDISK_LL=$(echo "$OLDDISK_LL" | tr "0-9a-z" "1-9a-z_")
    #NEWDISK_DIRVE="/dev/sd$NEWDISK_LL"
    #/sbin/fdisk -l /dev/$NEWDISK_DIRVE > /dev/null 2>&1

 

OLDDISK_LL=`lsblk |awk '{print $1}'|grep sd[a-z]$ | tail -1`
NEWDISK_DIRVE="/dev/$OLDDISK_LL"

 

/usr/boksm/bin/suexec usr/sbin/fdisk -l $NEWDISK_DIRVE > /dev/null 2>&1
if [ $? -eq 0 ];then

 

#/usr/boksm/bin/suexec /usr/sbin/fdisk /dev/$NEWDISK_DIRVE <<EOF
/usr/boksm/bin/suexec usr/sbin/fdisk $NEWDISK_DIRVE <<EOF
n
p
1

 

 


t
8e
w
EOF

 

## Add paration name into the drive name
NEWDISK_DRIVE_PART=$NEWDISK_DIRVE"1"
echo $NEWDISK_DRIVE_PART

 

## Add new partaion into Physical Volumn group
#/usr/boksm/bin/suexec /sbin/pvcreate $NEWDISK_DRIVE_PART > /dev/null 2>&1
/usr/boksm/bin/suexec /sbin/pvcreate $NEWDISK_DRIVE_PART > /dev/null 2>&1
if [ $? -eq 0 ];then
PVADD_STATUS="true";
else
PVADD_STATUS="false";
fi

 


## Add/Extent new partaion into Volumn group
#/usr/boksm/bin/suexec /usr/sbin/vgextend $VGNAME $NEWDISK_DRIVE_PART > /dev/null 2>&1
/usr/boksm/bin/suexec /usr/sbin/vgextend $VGNAME $NEWDISK_DRIVE_PART > /dev/null 2>&1
if [ $? -eq 0 ];then
VGEXTN_STATUS="true";
#call disk extent function
extent
else
VGEXTN_STATUS="false";
fi

 

else
echo "NO NEW DISK FOUND";
fi

 

}

 

 


## Main funtion
inputdata
getdata
if [ "$ATYPE" = "INCREASE" ]; then
extent
elif [ "$ATYPE" = "NEWDISK" ]; then
newdiskfs
else
echo "IVALID FUNCTIONS !"
fi

##############################################

###############WIN DISK EXTEND OS LEVEL#############

[ValidateNotNullOrEmpty()]
$USER_PASSWORD = ConvertTo-SecureString '$INPUT{VALID_PASSWORD}' -AsPlainText -Force

[ValidateNotNullOrEmpty()]
[string]$USERNAME = '$INPUT{VALID_USER}'


[ValidateNotNullOrEmpty()]
[string] $vmserver = '$INPUT{VALID_SERVER_FQDN}'

[ValidateNotNullOrEmpty()]
[string]$client = '$INPUT{VMSDATA}'

[ValidateNotNullOrEmpty()]
$reqdrive = '$INPUT{EX_DRIVE_LETTER}'

[ValidateNotNullOrEmpty()]
[int]$reqsize = '$INPUT{EX_SIZE}'

[ValidateNotNullOrEmpty()]
$dtype = '$INPUT{DRIVETYPE}'

$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $USERNAME, $USER_PASSWORD

$tabaobj = @{}
   
if ($client -like "*.*") {
    $client = $client.split('.')[0].trim()
}
   
   
$client = $client.ToUpper()


if($reqdrive -cnotmatch '/') {

   $reqdrive = $reqdrive.replace('\\','').Trim()
}
    
$objInfo =@{}

  

if (($client -eq 'SAMPLESERVER1') -or ($client -eq 'SAMPLESERVER2')) {
	try{
        try {
            If($dtype -like "*existing*") {
            # Windows part Disk expansion :
            Invoke-Command  -computername $vmserver -Credential $credential  -scriptblock { & echo "rescan" | diskpart | out-null }-argumentlist $file -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)
            Start-Sleep -Seconds 30
	 
			Function Resize-DiskPartition
			{
	    
	
	        [CmdletBinding()]
	        Param(
	        [Parameter(Mandatory,Position=1)]
	            [string]$ComputerName,
	        [Parameter(Mandatory,Position=2)]
	            [string]$DriveLetter
	        )
	
	        Begin{
	            Write-Verbose "Expanding drive $DriveLetter on $ComputerName"
	            $Session = New-CimSession -ComputerName $ComputerName
	        }
	
	        Process{
	            Write-Verbose "Retrieving maximum partition size"
	            $Drive = Get-PartitionSupportedSize -CimSession $Session -DriveLetter $driveletter
	            $SetSize = [int64]$Drive.sizeMax
	        
	            Write-Verbose "Expanding partition to $($SetSize/1GB) GB"
	            Resize-Partition -DriveLetter $DriveLetter -Size $SetSize -CimSession $Session
	        }
	
	        End {
	            Remove-CimSession $Session
	            Write-Verbose "Disk expansion complete"
	        }
	        }
	
			    $reqdrivenocolon = $reqdrive.Split(":")[0]
	
			    Resize-DiskPartition -ComputerName $vmserver -DriveLetter $reqdrivenocolon
                $Winsizedisk = Get-WMIObject Win32_Logicaldisk -filter "deviceid='$reqdrive'" -ComputerName $vmserver |
                Select PSComputername,DeviceID,
                @{Name="SizeGB";Expression={$_.Size/1GB -as [int]}},
                @{Name="FreeGB";Expression={[math]::Round($_.Freespace/1GB,2)}}
                $Outputresult = [ordered] @{ 
                vmname          		    	= $vmserver
                "Drive Letter"     				= $reqdrive
                "Space to be added in GB"		= $reqsize
                "Windows diskexpand size in GB"	= $Winsizedisk.SizeGB
                "result"						= "success"
                "message"						= "Disk expanded in OS"
                }
   
                #$global:report = [pscustomobject]$Outputresult
 
                #$global:report | ConvertTo-Json
            }
            elseif ($dtype -like "*new*") {
		            	$diskresult = Invoke-Command -ComputerName $vmserver -Credential $credential -Scriptblock {
		           			[int]$reqsize  = '$INPUT{EX_SIZE}'
							$reqdrive      = '$INPUT{EX_DRIVE_LETTER}'
							$reqdrivenocolon = $reqdrive.Split(":")[0]
							& echo "rescan" | diskpart | out-null
							$selectdisk = get-disk | where partitionstyle -eq 'raw'
							#$selectdisk = get-disk | where OperationalStatus -eq 'Offline'
							If ($selectdisk.OperationalStatus -eq "Offline") {
        						$indisk = $selectdisk | Initialize-Disk -PartitionStyle MBR -PassThru -Confirm:$false
    							}
    							Start-Sleep -Seconds 10
        						if($indisk) {
        						$disknum = $indisk.Number
            					Stop-Service -Name ShellHWDetection
            					Start-Sleep -Seconds 15
            					$createdisk = New-Partition -DiskNumber $disknum -DriveLetter $reqdrivenocolon -UseMaximumSize | Format-Volume -Confirm:$false -FileSystem NTFS -Force
            					Start-Sleep -Seconds 20
            					Start-Service -Name ShellHWDetection
        						}
        						$csize = [math]::round($createdisk.Size /1Gb)
        						$Outputresult = @{}
        						
        						        						
    							if($createdisk){
        						$Outputresult = [ordered] @{
                            		vmname          		    	= $using:client
		                    		"Drive Letter"     				= $reqdrive 
		                    		"Space to be added in GB"		= $reqsize
		                    		"Disk Number"           		= $($indisk.Number)
		                    		"New Disk size in GB"	        = "$csize GB"
		                    		"result"						= "success"
		                    		"message"						= "New Disk Created with size $reqsize and Drive letter is $reqdrive"
        						}
        						}
        						else {
         						$Outputresult = [ordered] @{
                            		vmname          		    	= $using:client
		                    		"Drive Letter"     				= $reqdrive 
		                    		"Space to be added in GB"		= $reqsize
		                    		"Disk Number"           		= $($indisk.Number)
		                    		"New Disk size in GB"	        = "$csize GB"
		                    		"result"						= "fail"
		                    		"message"						= "New Disk Creation Failed "
        						}
        }
        				return [pscustomobject]$Outputresult
						} -argumentlist $file -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)
		      			$global:report = $diskresult | select vmname, "Drive Letter","Space to be added in GB","Disk Number","New Disk size in GB", result, message
		      			
		      }
            else {
                $tabaobj.Add("VMData", "Disktype is invalid. Either it accepts New or Existing")
            }
 
                    
        }

        catch{
                    	$msg=$_.Exception.Message
                    	$tabaobj.Add("VMData", "$msg")	
        }
        if ($global:report) {
            $tabaobj.Add("VMData", $global:report)
        }
        else {
            $tabaobj.Add("VMData", "ERROR Failed to Connect Server $client")
        }
              
    }
    catch {
    	$opitmalmsg = $_.Exception.Message
    	if ($global:report) {
                    $tabaobj.Add("VMData", $global:report)
                }
            else {
                    $tabaobj.Add("VMData", $opitmalmsg)
            }
    }
$tabaobj | ConvertTo-Json
}

#################################

############DB acc*ss provisioning#######

#########fetch attachdata#######


$ritmno = '$INPUT{RITM_NUMBER}'
$SysID = '$INPUT{RITM_SYSID}'
$suser = "user1"
$spass = '$INPUT{SPASS}' | ConvertTo-SecureString -AsPlainText -Force
$snowURL = '$INPUT{SNOWLINK}'
$outPath = "C:\Temp"


[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12


$Credential = New-Object pscredential -ArgumentList ($suser,$spass)

$ritmAttachments = Invoke-RestMethod -Uri "$snowURL/api/now/attachment?table_sys_id=$($SysID)" -Method Get -Credential $Credential
$results = $ritmAttachments.result | Select file_name , download_link

 

foreach($result in $results)
{
Invoke-RestMethod -Uri $($result.download_link) -Method Get -Credential $Credential -OutFile $outPath\$($result.file_name)
}

$xlfile = "c:\temp\$($result.file_name)"
$InFile = Get-Item $xlfile
$OutFile= $InFile.FullName.replace($InFile.Extension,".csv")

Import-Excel $Infile.FullName | Export-Csv $OutFile -Delimiter "#" -NoTypeInformation

$htmlvar  = get-content $OutFile | select -Skip 1


$htmlvar = $htmlvar.Replace('"','')

if($htmlvar)
{
foreach ($t in $htmlvar)
{
$t = $t.Split("#")
		

	if($t -ne "")
	{
	$t[2] = $t[2] -replace '\W', ''
	$t[4] = $t[4] -replace '\W', ''
		
    [STRING]$copy_clientname                       	  =   				    $t[0]
	[STRING]$copy_userfullname	                      =   					$t[1]
	[STRING]$copy_userid                              =   					$t[2]
	[STRING]$copy_Env                                 =   					$t[3]
	[STRING]$copy_Requesttype                         =                     $t[4]
	[STRING]$copy_sr                                  =                     $t[5]
	[STRING]$copy_lm                                  =                     $t[6]
	[STRING]$copy_version                             =                     $t[7]

[string]$value = ":"+$copy_clientname+"#"+$copy_userfullname+"#"+$copy_userid+"#"+$copy_Env+"#"+$copy_Requesttype+"#"+$copy_sr+"#"+$copy_lm+"#"+$copy_version;
#[string]$value += ":"
$final += $value;
    }
}
}
else {write-host "File not Found"}
$final
Remove-Item -Path $xlfile -Force
Remove-Item -Path $OutFile -Force

#####################################

################fetch userid snow#######



$incident = '$INPUT{INC}'
$msg = '$INPUT{SLINK}'
$spass = '$INPUT{SPASS}'

[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
	$caseid=$incident.trim()
$ErrorActionPreference = "SilentlyContinue"

$changestate=@{}

$changestate.Add("-5","New")
$changestate.Add("-4","Assess")
$changestate.Add("-3","Authorize")
$changestate.Add("-2","Scheduled")
$changestate.Add("-1","Implement")
$changestate.Add("0","Review")
$changestate.Add("3","closed")
$changestate.Add("4","Canceled")



$taskstate=@{}

$taskstate.Add("1","Open")
$taskstate.Add("3","Closed Complete")
$taskstate.Add("4","Closed InComplete")
$taskstate.Add("7","Cancelled")
$taskstate.Add("-5","None")


$result = New-Object System.Object


$uri="$msg/api/now/table/sc_req_item?number=$caseid&sysparm_display_value=true"

$user = 'resolve'
$password = ConvertTo-SecureString $spass -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $user,$password
$Requests = Invoke-RestMethod -Uri $URI -Credential $credential -Method GET -ContentType "application/json"

$msysid=$Requests.result.sys_id
$changetaskfor=($Requests.result.task_for.link).Split("/")[-1]

if($Requests.result.number){$changenumber=$Requests.result.number}else{$changenumber="No Value found"}
if($Requests.result.state){$changestates=$Requests.result.state}else{$changestates="No Value found"}


$result | Add-Member -MemberType NoteProperty -Name  "RNumber" -Value $changenumber
$result | Add-Member -MemberType NoteProperty -Name  "RState" -Value $changestates
$result | Add-Member -MemberType NoteProperty -Name  "RTaskfor" -Value $changetaskfor
#$result | Add-Member -MemberType NoteProperty -Name  "Configitems" -Value $serverlists

$result | ConvertTo-Json

#############################

##########SQL process check#############

#assign input Variables
	$datain = "$INPUT{DATAIN}"
	$datain =  $datain.Split(":")
	$versplit = $datain.split("#")
	$Global:VERS = $versplit[8]
	$prduat=0
	$prd=0
	$uat=0
	$Global:VERS
Function RUNPRD {

    write-host "Prod RUN"
    #credentials
    $username = '$INPUT{USERNAME}'
    $password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
    $credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password
    $version  = $Global:VERS
    $version=$version.Trim().Replace(' ','')

$info=@"
Version,servername,sqlinstance,port
versionus,serverus,serverus\asdf01,0000,
versionuk2,serverus1,serverus\asdf01,0000,
versionuk1,serverus2,serverus\asdf01,0000,
versionus1,serverus3,serverus\asdf01,0000,
versionus2,serverus4,serverus\asdf01,0000,
versionus3,serverus5,serverus\asdf01,0000,
"@

    $values=$info.Split([Environment]::NewLine)
    $finalcontent=@()
    foreach($cv in $values) {
        if($cv -like '*,*,*,*') {
            $taskobj = New-Object -TypeName PSObject
            $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[0] -Value $cv.split(',')[0] -Force
            $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[1] -Value $cv.split(',')[1] -Force
            $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[2] -Value $cv.split(',')[2] -Force
            $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[3] -Value $cv.split(',')[3] -Force
            $finalcontent += $taskobj
        }
    
    }


    if($version -like "*version*") {
        $sqlversion=($finalcontent | where{($_.Version -eq $version)}).Version
        $sqlserver=($finalcontent | where{($_.Version -eq $version)}).servername
        $sqlinstance=($finalcontent | where{($_.Version -eq $version)}).sqlinstance
        write-host "Server Version  	: $sqlversion"
        write-host "Server to connect 	: $sqlserver"
        write-host "Instance to connect : $sqlinstance"
    }
    else {
        write-host "No version found"
    }

    Try {
        $html = Invoke-Command -ComputerName $sqlserver -Credential $credential -Scriptblock {

            $env:COMPUTERNAME
            $DB_HOST          = $using:sqlinstance
            #input parameters
            $ritm = "$INPUT{RNUMBER}"
            $ritm = $ritm.Trim()

	        If ($USERFULLNAME -cmatch "'") {

		        $USERFULLNAME = $USERFULLNAME.Replace("'","''")
            }


$procuser = @'
USE ADBA

DECLARE @CNT INT = 0, @Message1 VARCHAR(1000) , @RitmNo VARCHAR (30) 

SET @RNo =N'{0}' -- Set value from tool side

WHILE @CNT<10 AND EXISTS (SELECT 1 FROM [Sc_Mat_tk] WHERE [StartedAt]>GETDATE()-1 AND [State] <>'Closed')
BEGIN
         WAITFOR DELAY '00:01:00'
                             SET @CNT =@CNT+1
END

IF @CNT =10 AND EXISTS (SELECT 1 FROM [Sc_Mat_tk] WHERE [StartedAt]>GETDATE()-1 AND [State] <>'Closed')
BEGIN
              SET @Message1 ='There is another security matrix in progress for same sever. Please try after sometime with same sc mat sheet.'
              SELECT @Message1 
              RETURN
END
ELSE

INSERT INTO [dbo].[Sc_Mat_tk] ([RNo],[State],[StartedAt]) VALUES (@RitmNo,'Open',GETDATE())
'@


            $insertSQLCMD = $procuser -f $ritm

            #write-host $insertSQLCMD

            $resultsql = Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -ErrorAction Stop		
            $resultsql #| Format-Table
            if ($resultsql) {
                write-host "Success"
            }
            else{
                write-host "failed"
            }

        }-argumentlist $file -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)

        #$html
        $result = $html.column1
        write-host "resultprd=$result"
	}
    catch {
        $html = Invoke-Command -ComputerName $sqlserver -Credential $credential -Scriptblock {

           	$env:COMPUTERNAME
            $DB_HOST          = $using:sqlinstance
            #input parameters
            $ritm = "$INPUT{RNUMBER}"
            $ritm = $ritm.Trim()

	        If ($USERFULLNAME -cmatch "'") {

		        $USERFULLNAME = $USERFULLNAME.Replace("'","''")
            }


            $insertSQLCMD = $procuser -f $ritm

            #write-host $insertSQLCMD

            $resultsql = Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -ErrorAction Stop	
            $resultsql #| Format-Table
            if ($resultsql) {
                write-host "Success"
            }
            else{
                write-host "failed"
            }

        }-argumentlist $file -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)

        #$html
        $result = $html.column1
        write-host "resultprd=$result"
	}
}

Function RUNUAT {
    write-host "UAT RUN"
    #credentials
    $username = '$INPUT{USERNAME}'
    $password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
    $credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password
    $version  = $Global:VERS
    $version=$version.Trim().Replace(' ','')

$info=@"
Version,servername,sqlinstance,port
versionus,serverus,serverus\asdf01,0000,
versionuk2,serverus1,serverus\asdf01,0000,
versionuk1,serverus2,serverus\asdf01,0000,
versionus1,serverus3,serverus\asdf01,0000,
versionus2,serverus4,serverus\asdf01,0000,
versionus3,serverus5,serverus\asdf01,0000,
"@

    $values=$info.Split([Environment]::NewLine)
    $finalcontent=@()
    foreach($cv in $values) {
        if($cv -like '*,*,*,*') {
            $taskobj = New-Object -TypeName PSObject
            $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[0] -Value $cv.split(',')[0] -Force
            $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[1] -Value $cv.split(',')[1] -Force
            $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[2] -Value $cv.split(',')[2] -Force
            $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[3] -Value $cv.split(',')[3] -Force
            $finalcontent += $taskobj
        }
    
    }


    if($version -like "*versioni*") {
        $sqlversion=($finalcontent | where{($_.Version -eq $version)}).Version
        $sqlserver=($finalcontent | where{($_.Version -eq $version)}).servername
        $sqlinstance=($finalcontent | where{($_.Version -eq $version)}).sqlinstance
        write-host "Server Version  	: $sqlversion"
        write-host "Server to connect 	: $sqlserver"
        write-host "Instance to connect : $sqlinstance"
    }
    else {
        write-host "No version found"
    }



        Try {
            $html = Invoke-Command -ComputerName $sqlserver -Credential $credential -Scriptblock {
            	$env:COMPUTERNAME
            	$DB_HOST          = $using:sqlinstance
            	#input parameters
            	$ritm = "$INPUT{RITMNUMBER}"
            	$ritm = $ritm.Trim()


	        If ($USERFULLNAME -cmatch "'") {
                $USERFULLNAME = $USERFULLNAME.Replace("'","''")

	        }


$procuser = @'
USE ADBA

DECLARE @CNT INT = 0, @Message1 VARCHAR(1000) , @RitmNo VARCHAR (30) 

SET @RNo =N'{0}' -- Set value from tool side

WHILE @CNT<10 AND EXISTS (SELECT 1 FROM [Sc_Mat_tk] WHERE [StartedAt]>GETDATE()-1 AND [State] <>'Closed')
BEGIN
         WAITFOR DELAY '00:01:00'
                             SET @CNT =@CNT+1
END

IF @CNT =10 AND EXISTS (SELECT 1 FROM [Sc_Mat_tk] WHERE [StartedAt]>GETDATE()-1 AND [State] <>'Closed')
BEGIN
              SET @Message1 ='There is another security matrix in progress for same sever. Please try after sometime with same sc mat sheet.'
              SELECT @Message1 
              RETURN
END
ELSE

INSERT INTO [dbo].[Sc_Mat_tk] ([RNo],[State],[StartedAt]) VALUES (@RitmNo,'Open',GETDATE())
'@


            $insertSQLCMD = $procuser -f $ritm

            #write-host $insertSQLCMD

            $resultsql = Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -ErrorAction Stop		
            $resultsql #| Format-Table
            if ($resultsql) {
                write-host "Success"
            }
            else {
                write-host "failed"
            }
        }-argumentlist $file -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)

        #$html
        $result = $html.column1
        write-host "resultuat=$result"
	    }
}

Function RUNPRDUAT{
#Call PROD
RUNPRD
#Call UAT
RUNUAT 
}


foreach($U in $datain) {
    $U = $U.split("#")
    if (($U[3] -eq 'PRD / UAT') -or ($U[3] -eq 'PR/UT') -or ($U[3] -eq 'PD, UT') -or ($U[3] -eq 'PR,UT') -or ($U[3] -eq 'PR ,UT')) {
    $prduat = $prduat + 1
	}
    elseif (($U[3] -eq 'PD')) {
    $pd = $pd + 1
    }
    elseif (($U[3] -eq 'UT')) {
    $ut = $ut + 1
    }
       
}

#Identify Run Environment

    if (($prduat -gt 0) -or (($pd -gt 0) -and ($ut -gt 0))) {
        #write-host "RUNPRDUAT"
        RUNPRDUAT
   	}
    else{
        if(($pd -gt 0) -and ($ut -eq 0)) {
        #write-host "RUNPRD"
        RUNPRD
        }
        elseif(($ut -gt 0) -and ($pd -eq 0)) {
        #write-host "RUNUAT"
        RUNUAT
        }
        else {
        Write-Host "NO Version Found"
        }
    }

##########################

#########fetch user details snow#######



$incident = '$INPUT{INC}'
$spass = '$INPUT{SPASS}'
$taskfor ='$INPUT{RTASKINFO}'
$slink = '$INPUT{SLINK}'
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
try
{
	

	        $final=@()
	    	$user = 'tool'
            $password = ConvertTo-SecureString $spass -AsPlainText -Force
            $credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $user,$password
            $URI = "$slink/api/now/v1/table/sys_user/$INPUT{RTASKINFO}"
            $Requests = Invoke-RestMethod -Uri $URI -Credential $credential -Method GET -ContentType "application/json"
            $Requests.result
            $final=$requests.result -join(',')
	}
catch [Exception]
{   
    $result += "<==FAIL==>: " + $_.Exception.GetType().FullName + $_.Exception.Message + "`n";
    $result += ($_.Exception|format-list -force).toString();
}
finally
{
    echo $result
}

if($mfinal)
{
$final=$mfinal.split(",");

write-host "########################"
write-host "MYFINAL=$final"
write-host "########################"
}



#####################


###############ACC GRANT SC###########


$USERENV  = '$INPUT{USERENV}'
$USERENV = $USERENV.Trim()

$version  = '$INPUT{VERSION}'

$version

Function RUNPRD {

write-host "Prod RUN"
#credentials
$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password

$version  = '$INPUT{VERSION}'

$version=$version.Trim().Replace(' ','')

$info=@"
Version,servername,sqlinstance,port
versionus,serverus,serverus\asdf01,0000,
versionuk2,serverus1,serverus\asdf01,0000,
versionuk1,serverus2,serverus\asdf01,0000,
versionus1,serverus3,serverus\asdf01,0000,
versionus2,serverus4,serverus\asdf01,0000,
versionus3,serverus5,serverus\asdf01,0000,
"@

$values=$info.Split([Environment]::NewLine)
$finalcontent=@()
foreach($cv in $values)
{
    if($cv -like '*,*,*,*')
    {
        $taskobj = New-Object -TypeName PSObject
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[0] -Value $cv.split(',')[0] -Force
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[1] -Value $cv.split(',')[1] -Force
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[2] -Value $cv.split(',')[2] -Force
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[3] -Value $cv.split(',')[3] -Force
        $finalcontent += $taskobj
    }
    
}


if($version -like "*version*")
{
$sqlversion=($finalcontent | where{($_.Version -eq $version)}).Version
$sqlserver=($finalcontent | where{($_.Version -eq $version)}).servername
$sqlinstance=($finalcontent | where{($_.Version -eq $version)}).sqlinstance
write-host "Server Version  	: $sqlversion"
write-host "Server to connect 	: $sqlserver"
write-host "Instance to connect : $sqlinstance"
}
else
{
write-host "No version found"
}

Try
	{
$html = Invoke-Command -ComputerName $sqlserver -Credential $credential -Scriptblock {

$env:COMPUTERNAME

#Prepared statement for the insert

[string]$dbwrite = '$INPUT{DATAIN}'

$DB_HOST          = $using:sqlinstance

#input parameters
$cNAME = '$INPUT{cNAME}'
$USERFULLNAME    = "$INPUT{USERFULLNAME}"
$USERID = '$INPUT{USERID}'
$DBENV  = 'PRD'
$REQUESTTYPE = '$INPUT{REQUESTTYPE}'
$SM = '$INPUT{secmr}'
$LM      = '$INPUT{LICENSEmr}'
$version  = '$INPUT{VERSION}'

$USERID = $USERID.Trim()
$cNAME = $cNAME.Trim()
$USERFULLNAME = $USERFULLNAME.Trim()
$DBENV = $DBENV.Trim()
$SM = $SM.Trim()
$LM = $LM.Trim()

	If ($USERFULLNAME -cmatch "'") {

		$USERFULLNAME = $USERFULLNAME.Replace("'","''")

	}

#$SM
#$LM
#$REGLANG
#$USERENV
#$secRole 

$adduser = @'
USE ADBA
SET NOCOUNT ON

DECLARE @Name VARCHAR(100),@UserId VARCHAR(40), @DefLang VARCHAR(30),@cID INT,
@DBEnv VARCHAR(10), @FullName VARCHAR(50),@Secmr VARCHAR(10),@Licmr VARCHAR(10) ,@Message VARCHAR(1000)

SET @cName =N'{0}'
SET @UserId = N'{1}'
SET @DBEnv = N'{2}'
SET @FullName = N'{5}'
SET @Secmr = N'{3}'
SET @Licmr = N'{4}'

SELECT @cID = cId FROM c WHERE cName=@cName

DECLARE @DBName sysname
SELECT @DBName = DBNAME FROM INF_cDB
WHERE cID =@cID AND DBEnv = @DBEnv

IF GETDATE()=DATEADD(HOUR,-5,GETUTCDATE()) OR GETDATE()=DATEADD(HOUR,-4,GETUTCDATE()) 
SET @DefLang='English'
ELSE 
SET @DefLang='British English'

IF NOT EXISTS (SELECT 1 FROM c WHERE cId = @cID )
BEGIN
              SET @Message ='Provided c name doesnot exist on selected environment. Please check latest c names list and try again.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

IF NOT EXISTS (SELECT 1 FROM ADUser WHERE saccName = @UserId ) OR EXISTS (SELECT 1 FROM ADUser WHERE saccName = @UserId AND ADStatus IN (514 ,546) )
BEGIN
              SET @Message ='This user doesnot exist Or is in disabled/deleted status  in AD so no action was taken.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1)
AND NOT EXISTS (SELECT 1 FROM sys.server_principals WHERE name = 'inty\'+@UserId)
DELETE FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1

IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1)
BEGIN
              SET @Message ='User is already having access as per sec mat so no action was taken.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

ELSE IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=9)

DELETE FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=9

              EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='N/A',
                             @DefLanguage=@DefLang  

              IF @Secmr='Y'
              BEGIN
                      EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='ADMINISM',
                             @DefLanguage=@DefLang  
              END

              IF @Licmr='Y'
              BEGIN
                      EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='LicenseManager',
                             @DefLanguage=@DefLang  
              END

                        IF EXISTS(SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=0)
                        BEGIN
                               SET @Message ='User mdat inserted successfully.'
                               SELECT @Message, @DBName --- Resolve can print this error message for user process status
                        END

'@


$insertSQLCMD = $adduser -f $cNAME, $USERID, $DBENV, $SM, $LM , $USERFULLNAME

#write-host $insertSQLCMD

$resultsql = Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -ErrorAction Stop	
$resultsql #| Format-Table
if ($resultsql)
{
write-host "Success"
}
else
{
write-host "failed"
}

}-argumentlist $file -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)

#$html

$result = $html.column1
$dbname = $html.column2
write-host "resultprd=$result#$dbname"
	}
catch
	{
$html = Invoke-Command -ComputerName $sqlserver -Credential $credential -Scriptblock {

$env:COMPUTERNAME

#Prepared statement for the insert

[string]$dbwrite = '$INPUT{DATAIN}'

$DB_HOST          = $using:sqlinstance

#input parameters
$cNAME = '$INPUT{cNAME}'
$USERFULLNAME    = "$INPUT{USERFULLNAME}"
$USERID = '$INPUT{USERID}'
$DBENV  = 'PRD'
$REQUESTTYPE = '$INPUT{REQUESTTYPE}'
$SM = '$INPUT{secmr}'
$LM      = '$INPUT{LICENSEmr}'
$version  = '$INPUT{VERSION}'

$USERID = $USERID.Trim()
$cNAME = $cNAME.Trim()
$USERFULLNAME = $USERFULLNAME.Trim()
$DBENV = $DBENV.Trim()
$SM = $SM.Trim()
$LM = $LM.Trim()

	If ($USERFULLNAME -cmatch "'") {

		$USERFULLNAME = $USERFULLNAME.Replace("'","''")

	}
	
#$SM
#$LM
#$REGLANG
#$USERENV
#$secRole 

$adduser = @'
USE ADMINDBA
SET NOCOUNT ON

DECLARE @cName VARCHAR(100),@UserId VARCHAR(40), @DefLang VARCHAR(30),@cID INT,
@DBEnv VARCHAR(10), @FullName VARCHAR(50),@Secmr VARCHAR(10),@Licmr VARCHAR(10) ,@Message VARCHAR(1000)

SET @cName =N'{0}'
SET @UserId = N'{1}'
SET @DBEnv = N'{2}'
SET @FullName = N'{5}'
SET @Secmr = N'{3}'
SET @Licmr = N'{4}'

SELECT @cID = cId FROM c WHERE cName=@cName

DECLARE @DBName sysname
SELECT @DBName = DBNAME FROM INF_cDB
WHERE cID =@cID AND DBEnv = @DBEnv

IF GETDATE()=DATEADD(HOUR,-5,GETUTCDATE()) OR GETDATE()=DATEADD(HOUR,-4,GETUTCDATE()) 
SET @DefLang='English'
ELSE 
SET @DefLang='British English'

IF NOT EXISTS (SELECT 1 FROM c WHERE cId = @cID )
BEGIN
              SET @Message ='Provided c name doesnot exist on selected environment. Please check latest c names list and try again.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

IF NOT EXISTS (SELECT 1 FROM ADUser WHERE saccName = @UserId ) OR EXISTS (SELECT 1 FROM ADUser WHERE saccName = @UserId AND ADStatus IN (514 ,546) )
BEGIN
              SET @Message ='This user doesnot exist Or is in disabled/deleted status  in AD so no action was taken.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1)
AND NOT EXISTS (SELECT 1 FROM sys.server_principals WHERE name = 'Infinity\'+@UserId)
DELETE FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1

IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1)
BEGIN
              SET @Message ='User is already having access as per sec mat so no action was taken.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

ELSE IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=9)

DELETE FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=9

              EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='N/A',
                             @DefLanguage=@DefLang  

              IF @Secmr='Y'
              BEGIN
                      EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='ADMINISM',
                             @DefLanguage=@DefLang  
              END

              IF @Licmr='Y'
              BEGIN
                      EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='LicenseManager',
                             @DefLanguage=@DefLang  
              END

                        IF EXISTS(SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=0)
                        BEGIN
                               SET @Message ='User mdat inserted successfully.'
                               SELECT @Message, @DBName --- Resolve can print this error message for user process status
                        END

'@


$insertSQLCMD = $adduser -f $cNAME, $USERID, $DBENV, $SM, $LM , $USERFULLNAME

#write-host $insertSQLCMD

$resultsql = Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -ErrorAction Stop	
$resultsql #| Format-Table
if ($resultsql)
{
write-host "Success"
}
else
{
write-host "failed"
}

}-argumentlist $file -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)

#$html
#$html.column2
$result = $html.column1
$dbname = $html.column2
write-host "resultprd=$result#$dbname"
	}
}

Function RUNUAT {
write-host "UAT RUN"
#credentials
$username = '$INPUT{USERNAME}'
$password = ConvertTo-SecureString '$INPUT{PASSWORD}' -AsPlainText -Force
$credential = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password

$version  = '$INPUT{VERSION}'

$version=$version.Trim().Replace(' ','')

$info=@"
Version,servername,sqlinstance,port
versionus,serverus,serverus\asdf01,0000,
versionuk2,serverus1,serverus\asdf01,0000,
versionuk1,serverus2,serverus\asdf01,0000,
versionus1,serverus3,serverus\asdf01,0000,
versionus2,serverus4,serverus\asdf01,0000,
versionus3,serverus5,serverus\asdf01,0000,
"@

$values=$info.Split([Environment]::NewLine)
$finalcontent=@()
foreach($cv in $values)
{
    if($cv -like '*,*,*,*')
    {
        $taskobj = New-Object -TypeName PSObject
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[0] -Value $cv.split(',')[0] -Force
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[1] -Value $cv.split(',')[1] -Force
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[2] -Value $cv.split(',')[2] -Force
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[3] -Value $cv.split(',')[3] -Force
        $finalcontent += $taskobj
    }
    
}


if($version -like "*version*")
{
$sqlversion=($finalcontent | where{($_.Version -eq $version)}).Version
$sqlserver=($finalcontent | where{($_.Version -eq $version)}).servername
$sqlinstance=($finalcontent | where{($_.Version -eq $version)}).sqlinstance
write-host "Server Version  	: $sqlversion"
write-host "Server to connect 	: $sqlserver"
write-host "Instance to connect : $sqlinstance"
}
else
{
write-host "No version found"
}



Try
	{
$html = Invoke-Command -ComputerName $sqlserver -Credential $credential -Scriptblock {

$env:COMPUTERNAME

#Prepared statement for the insert

[string]$dbwrite = '$INPUT{DATAIN}'

$DB_HOST          = $using:sqlinstance

#input parameters
$cNAME = '$INPUT{cNAME}'
$USERFULLNAME    = "$INPUT{USERFULLNAME}"
$USERID = '$INPUT{USERID}'
$DBENV  = 'UAT'
$REQUESTTYPE = '$INPUT{REQUESTTYPE}'
$SM = '$INPUT{secmr}'
$LM      = '$INPUT{LICENSEmr}'
$version  = '$INPUT{VERSION}'

$USERID = $USERID.Trim()
$cNAME = $cNAME.Trim()
$USERFULLNAME = $USERFULLNAME.Trim()
$DBENV = $DBENV.Trim()
$SM = $SM.Trim()
$LM = $LM.Trim()

	If ($USERFULLNAME -cmatch "'") {

		$USERFULLNAME = $USERFULLNAME.Replace("'","''")

	}


$adduser = @'
USE ADMINDBA
SET NOCOUNT ON

DECLARE @cName VARCHAR(100),@UserId VARCHAR(40), @DefLang VARCHAR(30),@cID INT,
@DBEnv VARCHAR(10), @FullName VARCHAR(50),@Secmr VARCHAR(10),@Licmr VARCHAR(10) ,@Message VARCHAR(1000)

SET @cName =N'{0}'
SET @UserId = N'{1}'
SET @DBEnv = N'{2}'
SET @FullName = N'{5}'
SET @Secmr = N'{3}'
SET @Licmr = N'{4}'

SELECT @cID = cId FROM c WHERE cName=@cName

DECLARE @DBName sysname
SELECT @DBName = DBNAME FROM INF_cDB
WHERE cID =@cID AND DBEnv = @DBEnv

IF GETDATE()=DATEADD(HOUR,-5,GETUTCDATE()) OR GETDATE()=DATEADD(HOUR,-4,GETUTCDATE()) 
SET @DefLang='English'
ELSE 
SET @DefLang='British English'

IF NOT EXISTS (SELECT 1 FROM c WHERE cId = @cID )
BEGIN
              SET @Message ='Provided c name doesnot exist on selected environment. Please check latest c names list and try again.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

IF NOT EXISTS (SELECT 1 FROM ADUser WHERE saccName = @UserId ) OR EXISTS (SELECT 1 FROM ADUser WHERE saccName = @UserId AND ADStatus IN (514 ,546) )
BEGIN
              SET @Message ='This user doesnot exist Or is in disabled/deleted status  in AD so no action was taken.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1)
AND NOT EXISTS (SELECT 1 FROM sys.server_principals WHERE name = 'Infinity\'+@UserId)
DELETE FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1

IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1)
BEGIN
              SET @Message ='User is already having access as per sec mat so no action was taken.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

ELSE IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=9)

DELETE FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=9

              EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='N/A',
                             @DefLanguage=@DefLang  

              IF @Secmr='Y'
              BEGIN
                      EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='ADMINISM',
                             @DefLanguage=@DefLang  
              END

              IF @Licmr='Y'
              BEGIN
                      EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='LicenseManager',
                             @DefLanguage=@DefLang  
              END

                        IF EXISTS(SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=0)
                        BEGIN
                               SET @Message ='User mdat inserted successfully.'
                               SELECT @Message, @DBName --- Resolve can print this error message for user process status
                        END

'@


$insertSQLCMD = $adduser -f $cNAME, $USERID, $DBENV, $SM, $LM , $USERFULLNAME

#write-host $insertSQLCMD

$resultsql = Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -ErrorAction Stop	
$resultsql #| Format-Table
if ($resultsql)
{
write-host "Success"
}
else
{
write-host "failed"
}

}-argumentlist $file -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)

#$html
$result = $html.column1
$dbname = $html.column2
write-host "resultuat=$result#$dbname"
	}
catch
	{
$html = Invoke-Command -ComputerName $sqlserver -Credential $credential -Scriptblock {

$env:COMPUTERNAME

#Prepared statement for the insert

[string]$dbwrite = '$INPUT{DATAIN}'

$DB_HOST          = $using:sqlinstance

#input parameters
$cNAME = '$INPUT{cNAME}'
$USERFULLNAME    = "$INPUT{USERFULLNAME}"
$USERID = '$INPUT{USERID}'
$DBENV  = 'UAT'
$REQUESTTYPE = '$INPUT{REQUESTTYPE}'
$SM = '$INPUT{secmr}'
$LM      = '$INPUT{LICENSEmr}'
$version  = '$INPUT{VERSION}'

$USERID = $USERID.Trim()
$cNAME = $cNAME.Trim()
$USERFULLNAME = $USERFULLNAME.Trim()
$DBENV = $DBENV.Trim()
$SM = $SM.Trim()
$LM = $LM.Trim()

	If ($USERFULLNAME -cmatch "'") {

		$USERFULLNAME = $USERFULLNAME.Replace("'","''")

	}

#$SM
#$LM
#$REGLANG
#$USERENV
#$secRole 

$adduser = @'
USE ADMINDBA
SET NOCOUNT ON

DECLARE @cName VARCHAR(100),@UserId VARCHAR(40), @DefLang VARCHAR(30),@cID INT,
@DBEnv VARCHAR(10), @FullName VARCHAR(50),@Secmr VARCHAR(10),@Licmr VARCHAR(10) ,@Message VARCHAR(1000)

SET @cName =N'{0}'
SET @UserId = N'{1}'
SET @DBEnv = N'{2}'
SET @FullName = N'{5}'
SET @Secmr = N'{3}'
SET @Licmr = N'{4}'

SELECT @cID = cId FROM c WHERE cName=@cName

DECLARE @DBName sysname
SELECT @DBName = DBNAME FROM INF_cDB
WHERE cID =@cID AND DBEnv = @DBEnv

IF GETDATE()=DATEADD(HOUR,-5,GETUTCDATE()) OR GETDATE()=DATEADD(HOUR,-4,GETUTCDATE()) 
SET @DefLang='English'
ELSE 
SET @DefLang='British English'

IF NOT EXISTS (SELECT 1 FROM c WHERE cId = @cID )
BEGIN
              SET @Message ='Provided c name doesnot exist on selected environment. Please check latest c names list and try again.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

IF NOT EXISTS (SELECT 1 FROM ADUser WHERE saccName = @UserId ) OR EXISTS (SELECT 1 FROM ADUser WHERE saccName = @UserId AND ADStatus IN (514 ,546) )
BEGIN
              SET @Message ='This user doesnot exist Or is in disabled/deleted status  in AD so no action was taken.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1)
AND NOT EXISTS (SELECT 1 FROM sys.server_principals WHERE name = 'Infinity\'+@UserId)
DELETE FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1

IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=1)
BEGIN
              SET @Message ='User is already having access as per sec mat so no action was taken.'
              SELECT @Message, @DBName --- Resolve can print this error message for user process status
              RETURN
END

ELSE IF EXISTS (SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=9)

DELETE FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=9

              EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='N/A',
                             @DefLanguage=@DefLang  

              IF @Secmr='Y'
              BEGIN
                      EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='ADMINISM',
                             @DefLanguage=@DefLang  
              END

              IF @Licmr='Y'
              BEGIN
                      EXEC adduser_manual
                             @cName=@cName, 
                             @DBEnv =@DBEnv,
                             @UserId =@UserId,
                             @fullname=@FullName,
                             @InvSecRole='LicenseManager',
                             @DefLanguage=@DefLang  
              END

                        IF EXISTS(SELECT 1 FROM UserProcess WHERE cId = @cID AND SQL_ENV = @DBEnv AND UserId=@UserId AND UserProcessStatus=0)
                        BEGIN
                               SET @Message ='User mdat inserted successfully.'
                               SELECT @Message, @DBName --- Resolve can print this error message for user process status
                        END
                        SELECT @DBName

'@


$insertSQLCMD = $adduser -f $cNAME, $USERID, $DBENV, $SM, $LM , $USERFULLNAME

#write-host $insertSQLCMD

$resultsql = Invoke-Sqlcmd -Query $insertSQLCMD -ServerInstance $DB_HOST -ErrorAction Stop	
$resultsql #| Format-Table
if ($resultsql)
{
write-host "Success"
}
else
{
write-host "failed"
}

}-argumentlist $file -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck)

$html
$result = $html.column1
$dbname = $html.column2
write-host "resultuat=$result#$dbname"
	}
}

Function RUNPRDUAT{
#Call PROD
RUNPRD
#Call UAT
RUNUAT 
}

#Identify Run Environment

    if (($USERENV -cmatch '/') -or ($USERENV -cmatch ',')){
        RUNPRDUAT
    }
    else{
        if($USERENV -like 'PRD'){
        RUNPRD
            }
        elseif ($USERENV -like 'UAT'){
        RUNUAT
            }
        else{
        Write-Host "NO Version Found"
    	}
    }


############################

###############Update rit#########

$baseURL = '$INPUT{SURL}'
$ritmsysid = '$INPUT{RSYSID}'
$spass = '$INPUT{SNOWPD}'
$flag = '$INPUT{FLAG}'
$workNotes = '$INPUT{WORKNOTES}'

[string]$closenotes=@"
$INPUT{CLOSENOTES}
"@

$consStatus=@"
$INPUT{WORKNOTES}
"@

$consStatus = $consStatus -replace 'null'

$svalues = $consStatus.Split('#')
#$svalues 
$modchtml=@()

$csvout1 = "c:\temp\invtemp1.csv"

"USERID,ENVIRONMENT,STATUS" >> $csvout1

$a = "<style>table {font-size: 10pt; font-family: calibri;}"
$a = $a + "BODY{background-color:#ffffff;}"
$a = $a + "TABLE{align: cernter; border-width: 1px;border-style: solid;border-color: black;border-collapse: collapse;}"
$a = $a + "TH{font-size:1em; border-width: 1px;padding: 2px;border-style: solid;border-color: white;background-color:#BDB76B}"
$a = $a + "TD{font-size:0.8em; border-width: 1px;padding: 2px;border-style: solid;border-color: white;}"
$a = $a + "</style>"

foreach($s in $svalues){

    if ($s -ne "")
    {
    $s.split("-").trim() -join(",") >> $csvout1
    
    }
    }

$chtml = Get-Content $csvout1 | ConvertFrom-Csv | ConvertTo-Html -Head $a

foreach($lines in $chtml)
{
if($lines -like "*<td>This user doesnot exist in AD so no action was taken.</td>*" -or $lines -like "*<td>USER DELETION FAILED</td>*" -or $lines -like "*<td>USER UPDATE FAILED</td>*" )
{
$newline=$lines.Replace('<td>','<td style="background-color:#FFA07A">')
$modchtml += $newline  
}
elseif($lines -like "*<td>User metadata inserted successfully.</td>*" -or $lines -like "*<td>User metadata marked as DELETED successfully.</td>*" -or $lines -like "*<td>User metadata Updated successfully.</td>*") 
{
$newline1=$lines.Replace('<td>','<td style="background-color:GreenYellow">')
$modchtml += $newline1 
}
elseif($lines -like "*<td>Provided client name doesnot exist on selected environment. Please check latest client names list and try again.</td>*")
{
$newline=$lines.Replace('<td>','<td style="background-color:#FFDAB9">')
$modchtml += $newline  
}
elseif($lines -like "*<td>User is already having access as per security matrix so no action was taken.</td>*" -or $lines -like "*<td>User is already not having access on database. No action was taken..</td>*") 
{
$newline1=$lines.Replace('<td>','<td style="background-color:#B0E0E6">')
$modchtml += $newline1 
}
else
{
$newline1=$lines.Replace('<td>','<td style="background-color:#AFEEEE">')
$modchtml += $newline1 
}
}

write-host "HTML Output:"
$modchtml
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

try
{
    if($ritmsysid)
    {
        $muser = 'resolve'
        $mpassword = ConvertTo-SecureString $spass -AsPlainText -Force
        $mcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $muser, $mpassword
        
     
      	$body = @{
            'work_notes' = "[code]"+ $modchtml +"[/code]"
            	}
        $bodyJsonm = $body | ConvertTo-Json
        $bodyJsonm
        $URIm = "$baseURL/api/now/table/sc_req_item/$ritmsysid"
        "URL : $URIm" 
       
        $Requestsm = Invoke-WebRequest -Uri $URIm  -Method PUT -Credential $mcredential -Body $bodyJsonm -TimeoutSec 100 -ContentType "application/json"
        if($Requestsm.StatusDescription -eq "OK")
        {
        	"The RITM sysID $ritmsysid has been updated"
 		}
 		else
 		{	
 			"RITM not updated due to API error, Please check RITM sysID $ritmsysid "
 		}
 	}
 	else
 	{
 		write-host "Sys_id Not valid"
 	}

}
catch [Exception]
{   
	$result += "ERRORCODEUNIQUE : "
    $result += "<==FAIL==>: " + $_.Exception.GetType().FullName + $_.Exception.Message + "`n";
    $result += ($_.Exception|format-list -force).toString();
}
finally
{
    echo $result
}

Remove-Item -Path $csvout1 -recurse -Force -ea SilentlyContinue


##############################

############# CLOSE RIT##########


$baseURL = '$INPUT{SNOWURL}'
$ritmsysid = '$INPUT{RITMSYSID}'
$spass = '$INPUT{SNOWPASSWORD}'
$flag = '$INPUT{FLAG}'
$workNotes = '$INPUT{WORKNOTES}'

$PROD_STATUS = '$INPUT{PROCSTATUS}'
$UAT_STATUS = '$INPUT{UATSTATUS}'

Start-Sleep -Seconds 5

$closenotes = @{}



    if ($PROD_STATUS -cmatch "successfully" -or $UAT_STATUS -cmatch "successfully"){
    	$closenotes["message"] = "access is granted"
    	$closenotes["result"] = "success"
       }
    else{
    	$closenotes["message"] = "access is not granted"
    	$closenotes["result"] = "fail"
        }

$closenotes = $closenotes | ConvertTo-Json

[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

try
{
    if($ritmsysid)
    {
        $muser = 'resolve'
        $mpassword = ConvertTo-SecureString $spass -AsPlainText -Force
        $mcredential = new-object -typename System.Management.Automation.PSCredential -argumentlist $muser, $mpassword
        
        #Check to make the status Closed-Complete or Closed-Incomplete
        if($flag -eq "Success")
        {
        	$state = "3"
        }
        else
        {
        	$state = "4"
        }
        
      	$body = @{
            'close_notes' = $closenotes
            'work_notes' = $closenotes
            'state' = $state
            'stage' = "complete"
		}
        $bodyJsonm = $body | ConvertTo-Json
        $bodyJsonm
        $URIm = "$baseURL/api/now/table/sc_task/$ritmsysid"
        "URL : $URIm" 
        
        $Requestsm = Invoke-WebRequest -Uri $URIm  -Method PUT -Credential $mcredential -Body $bodyJsonm -TimeoutSec 100 -ContentType "application/json"
        if($Requestsm.StatusDescription -eq "OK")
        {
        	"The RITM sysID $ritmsysid has been Resolved"
 		}
 		else
 		{	
 			"RITM not resolved due to API error, Please check RITM sysID $ritmsysid "
 		}
 	}
 	else
 	{
 		write-host "Sys_id Not valid"
 	}

}
catch [Exception]
{   
	$result += "ERRORCODEUNIQUE : "
    $result += "<==FAIL==>: " + $_.Exception.GetType().FullName + $_.Exception.Message + "`n";
    $result += ($_.Exception|format-list -force).toString();
}
finally
{
    echo $result
}



###############################

##############send mail acc**s prov###########


$consprocStatus		  =  '$INPUT{proc_STATUS}'
	$consuatStatus		  =  '$INPUT{UAT_STATUS}'
	$procprocStatus		  =  '$INPUT{PROCproc_STATUS}'
	$procuatStatus		  =  '$INPUT{PROCUAT_STATUS}'
	$emailto          	  =  '$INPUT{EMAIL}'
	$R                 =  '$INPUT{RNUMBER}'
	$wsheet               =  '$INPUT{WORKSHEET}'
	$sticket              =  '$INPUT{SUPPORTTICKET}'
	$version  			  =  '$INPUT{VERSION}'
	$failtkt  			  =  '$INPUT{FAILURETICKET}'
# Setting Variables
	$date= get-date -format "yyyy_MM_dd"
	$titledate=(Get-Date).ToUniversalTime()

	$timestamp=get-date -Format "MMddyyyymmhhss"
	
	$version=$version.Trim().Replace(' ','')

$info=@"
Version,servername,sqlinstance,port
versionus,serverus,serverus\asdf01,0000,
versionuk2,serverus1,serverus\asdf01,0000,
versionuk1,serverus2,serverus\asdf01,0000,
versionus1,serverus3,serverus\asdf01,0000,
versionus2,serverus4,serverus\asdf01,0000,
versionus3,serverus5,serverus\asdf01,0000,
"@

$valuesprd=$infoprd.Split([Environment]::NewLine)
$finalcontentprd=@()
foreach($cvprd in $valuesprd)
{
    if($cvprd -like '*,*,*,*')
    {
        $taskobj1 = New-Object -TypeName PSObject
        $taskobj1 | Add-Member -MemberType NoteProperty -Name $valuesprd[0].split(',')[0] -Value $cvprd.split(',')[0] -Force
        $taskobj1 | Add-Member -MemberType NoteProperty -Name $valuesprd[0].split(',')[1] -Value $cvprd.split(',')[1] -Force
        $taskobj1 | Add-Member -MemberType NoteProperty -Name $valuesprd[0].split(',')[2] -Value $cvprd.split(',')[2] -Force
        $taskobj1 | Add-Member -MemberType NoteProperty -Name $valuesprd[0].split(',')[3] -Value $cvprd.split(',')[3] -Force
        $finalcontentprd += $taskobj1
    }
    
}


if($version -like "*version*")
{
$sqlserverprd=($finalcontentprd | where{($_.Version -eq $version)}).servername
}
else
{
write-host "No version found"
}

$info=@"
Version,servername,sqlinstance,port
versionus,serverus,serverus\asdf01,0000,
versionuk2,serverus1,serverus\asdf01,0000,
versionuk1,serverus2,serverus\asdf01,0000,
versionus1,serverus3,serverus\asdf01,0000,
versionus2,serverus4,serverus\asdf01,0000,
versionus3,serverus5,serverus\asdf01,0000,
"@

$values=$info.Split([Environment]::NewLine)
$finalcontent=@()
foreach($cv in $values)
{
    if($cv -like '*,*,*,*')
    {
        $taskobj = New-Object -TypeName PSObject
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[0] -Value $cv.split(',')[0] -Force
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[1] -Value $cv.split(',')[1] -Force
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[2] -Value $cv.split(',')[2] -Force
        $taskobj | Add-Member -MemberType NoteProperty -Name $values[0].split(',')[3] -Value $cv.split(',')[3] -Force
        $finalcontent += $taskobj
    }
    
}


if($version -like "*invest*")
{
$sqlserver=($finalcontent | where{($_.Version -eq $version)}).servername
}
else
{
write-host "No version found"
}

$consprocStatus = $consprocStatus -replace 'null'
$consuatStatus = $consuatStatus -replace 'null'
$svalues = $consprocStatus.Split('#')
$uvalues = $consuatStatus.Split('#')
$svalues
$uvalues
$modchtml=@()
$modchtml2=@()
$csvout1 = "c:\temp\invtemp1_$timestamp.csv"
$csvout2 = "c:\temp\invtemp2_$timestamp.csv"
$htmlout = "c:\temp\invtemp_$timestamp.html"

#content One

"ClientName:Version:USERID:DBNAME:REQUESTTYPE:sec RIGHTS:LICENSEMANAGER:ERRORDETAILS" >> $csvout1

$a = "<H1><font face='roboto' color='#000000' size='4'><strong><span style='background-color: #00FF00'>proc </span>-DETAILED LIST OF USER PROCESSING</strong></font></H1>" 
$a = $a + "<H4><font face='roboto' color='#000000' size='2'><strong>Server Name: $sqlserverprd</strong></font></H4>" 
$a = $a + "<style>table {font-size: 10pt; font-family: calibri;}"
$a = $a + "BODY{background-color:#ffffff;}"
$a = $a + "TABLE{align: cernter; border-width: 1px;border-style: solid;border-color: black;border-collapse: collapse;}"
$a = $a + "TH{font-size:1em; border-width: 1px;padding: 2px;border-style: solid;border-color: white;background-color:#BDB76B}"
$a = $a + "TD{font-size:0.9em; border-width: 1px;padding: 2px;border-style: solid;border-color: white;background-color:PaleGoldenRod}"
$a = $a + "</style>"

foreach($s in $svalues){
    if ($s -ne "")
    {
    $s.split("|").trim() -join(":") >> $csvout1
    }
    }

if (Test-Path $csvout1)
{
$chtml = Get-Content $csvout1 | ConvertFrom-Csv -Delimiter ":" | ConvertTo-Html -Head $a
}
#$chtml
#FFDAB9
foreach($lines in $chtml)
{
if($lines -like "*<td>This user doesnot exist in AD so no action was taken.</td>*" -or $lines -like "*<td>USER DELETION FAILED</td>*" -or $lines -like "*<td>USER UPDATE FAILED</td>*" )
{
$newline=$lines.Replace('<td>','<td style="background-color:#FFA07A">')
$modchtml += $newline  
}
elseif($lines -like "*<td>User metadata inserted successfully.</td>*" -or $lines -like "*<td>User metadata marked as DELETED successfully.</td>*" -or $lines -like "*<td>User metadata Updated successfully.</td>*") 
{
$newline1=$lines.Replace('<td>','<td style="background-color:GreenYellow">')
$modchtml += $newline1 
}
elseif($lines -like "*<td>Provided client name doesnot exist on selected environment. Please check latest client names list and try again.</td>*")
{
$newline=$lines.Replace('<td>','<td style="background-color:#FFDAB9">')
$modchtml += $newline  
}
elseif($lines -like "*<td>User is already having access as per security matrix so no action was taken.</td>*" -or $lines -like "*<td>User is already not having access on database. No action was taken..</td>*") 
{
$newline1=$lines.Replace('<td>','<td style="background-color:#B0E0E6">')
$modchtml += $newline1 
}
else
{
$newline1=$lines.Replace('<td>','<td style="background-color:#AFEEEE">')
$modchtml += $newline1 
}
}

$modchtml | out-file $htmlout


#content Two
$content2 = @"
<html> 
<body> 
<H1><font face='roboto' color='#000000' size='4'><strong><span style='background-color: #00FF00'>proc </span>-PROCESS EXECUTION STATUS</strong></font></H1>
<table style="align: cernter; border-width: 1px;border-style: solid;border-color: black;border-collapse: collapse;">
    <tr>
    <td style="font-size:1.3em; border-width: 1px;padding: 2px;border-style: groove;border-color: #228B22;background-color:GreenYellow;">$procprocStatus</td>
    </tr>
 </table>
 </body> 
</html>
"@

$content2  | out-file -Append $htmlout

###############

#content Three

"ClientName:Version:USERID:DBNAME:REQUESTTYPE:SECURITY RIGHTS:LICENSEMANAGER:ERRORDETAILS" >> $csvout2

$b = "<H1><font face='roboto' color='#000000' size='4'><strong><span style='background-color: #FFFF00'>UAT </span>-DETAILED LIST OF USER PROCESSING</strong></font></H1>" 
$b = $b + "<H4><font face='roboto' color='#000000' size='2'><strong>Server Name: $sqlserver</strong></font></H4>" 
$b = $b + "<style>table {font-size: 10pt; font-family: calibri;}"
$b = $b + "BODY{background-color:#ffffff;}"
$b = $b + "TABLE{align: cernter; border-width: 1px;border-style: solid;border-color: black;border-collapse: collapse;}"
$b = $b + "TH{font-size:1em; border-width: 1px;padding: 2px;border-style: solid;border-color: white;background-color:#BDB76B}"
$b = $b + "TD{font-size:0.9em; border-width: 1px;padding: 2px;border-style: solid;border-color: white;background-color:PaleGoldenRod}"
$b = $b + "</style>"

foreach($u in $uvalues){
    if ($u -ne "")
    {
    $u.split("|").trim() -join(":") >> $csvout2
    }
    }

if (Test-Path $csvout2)
{
$uhtml = Get-Content $csvout2 | ConvertFrom-Csv -Delimiter ":" | ConvertTo-Html -Head $b
}
#$chtml
foreach($lines1 in $uhtml)
{
if($lines1 -like "*<td>This user doesnot exist in AD so no action was taken.</td>*" -or $lines1 -like "*<td>USER DELETION FAILED</td>*" -or $lines1 -like "*<td>USER UPDATE FAILED</td>*" )
{
$newline=$lines1.Replace('<td>','<td style="background-color:#FFA07A">')
$modchtml2 += $newline  
}
elseif($lines1 -like "*<td>User metadata inserted successfully.</td>*" -or $lines1 -like "*<td>User metadata marked as DELETED successfully.</td>*" -or $lines1 -like "*<td>User metadata Updated successfully.</td>*") 
{
$newline1=$lines1.Replace('<td>','<td style="background-color:GreenYellow">')
$modchtml2 += $newline1 
}
elseif($lines1 -like "*<td>Provided client name doesnot exist on selected environment. Please check latest client names list and try again.</td>*")
{
$newline=$lines1.Replace('<td>','<td style="background-color:#FFDAB9">')
$modchtml2 += $newline  
}
elseif($lines1 -like "*<td>User is already having access as per security matrix so no action was taken.</td>*" -or $lines1 -like "*<td>User is already not having access on database. No action was taken..</td>*") 
{
$newline1=$lines1.Replace('<td>','<td style="background-color:#B0E0E6">')
$modchtml2 += $newline1 
}
else
{
$newline1=$lines1.Replace('<td>','<td style="background-color:#AFEEEE">')
$modchtml2 += $newline1 
}
}

$modchtml2 | out-file -Append $htmlout


#content Four
$content4 = @"
<html> 
<body> 
<H1><font face='roboto' color='#000000' size='4'><strong><span style='background-color: #FFFF00'>UAT </span>-PROCESS EXECUTION STATUS</strong></font></H1>
<table style="align: cernter; border-width: 1px;border-style: solid;border-color: black;border-collapse: collapse;">
    <tr>
    <td style="font-size:1.3em; border-width: 1px;padding: 2px;border-style: groove;border-color: #228B22;background-color:GreenYellow;">$procuatStatus</td>
    </tr>
 </table>
 </body> 
</html>
"@

$content4  | out-file -Append $htmlout

################

#content six
$content6 = @"
<html> 
<body> 
<H1><font face='roboto' color='#000000' size='4'><strong><span style='background-color: #FFFF00'>FAILURE TICKETS: $failtkt assigned to DBA team </span> </strong></font></H1>
 </body> 
</html>
"@

$content6  | out-file -Append $htmlout

##############
#content Five
$footer = @"
<html> 
<head> 
<meta http-equiv="content-type" content="text/html; charset=Windows-1250" /> 
</head> 
<body> 
<div style="margin: 0px; padding: 0px; font-size: 9pt; font-family: Arial; color: black;">
    <br>
    <br>
    <p style="margin: 0px; margin-bottom: 12px;">Regards</p> 
    <p style="margin: 0px; text-transform: uppercase; font-weight: bold;color: Green;">Auto team</p> 
    <p style="margin: 0px;"><a href="mailto:$ADemail">samp.com</a></p> 
    </p> 
</div> 
</body> 
</html>
"@

$footer  | out-file -Append $htmlout


$htmlresult = Get-Content $htmlout
$htmlresult

<#test
Send-MailMessage -from "tool@tool.com" `
				 -to "$emailto" `
				 -cc "daspport@tool.com" `
				 -bcc "user1@tool.com" `
				 -Subject "$R Notification - Security Matrix Processing - $wsheet - $sticket" `
                 -BodyAsHtml -Body "$htmlresult" `
                 -SmtpServer "rel@tool.com"
#>

Send-MailMessage -from "tool@tool.com" `
				 -to "$emailto" `
				 -cc "daspport@tool.com" `
				 -bcc "user1@tool.com" `
				 -Subject "$R Notification - Security Matrix Processing - $wsheet - $sticket" `
                 -BodyAsHtml -Body "$htmlresult" `
                 -SmtpServer "rel@tool.com"
write-host "EMAIL SEND"



Remove-Item -Path $csvout1 -recurse -Force -ea SilentlyContinue
Remove-Item -Path $csvout2 -recurse -Force -ea SilentlyContinue
Remove-Item -Path $htmlout -recurse -Force -ea SilentlyContinue











